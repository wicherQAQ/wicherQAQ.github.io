<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019ECNU机试01</title>
    <url>/2020/04/10/2019ECNU%E6%9C%BA%E8%AF%9501/</url>
    <content><![CDATA[<p><img src="/2020/04/10/2019ECNU%E6%9C%BA%E8%AF%9501/A.png" alt="A"></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;自定义排序规则</span><br><span class="line">bool cmp(int a, int b) &#123;</span><br><span class="line">	return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int* nums &#x3D; new int[n];</span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, nums + i);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;利用c++算法库函数中的快排算法，需要自定义排序规则</span><br><span class="line">	sort(nums, nums + n, cmp);&#x2F;&#x2F;默认sort是升序</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		printf(&quot;%d&quot;, nums[i]);</span><br><span class="line">		if (i !&#x3D; n - 1)</span><br><span class="line">			printf(&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师机试</category>
      </categories>
  </entry>
  <entry>
    <title>2019ECNU机试02</title>
    <url>/2020/04/11/2019ECNU%E6%9C%BA%E8%AF%9502/</url>
    <content><![CDATA[<p><img src="/2020/04/11/2019ECNU%E6%9C%BA%E8%AF%9502/B.png" alt></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>&emsp;&emsp;要最少，则当然是尽量量去用大的。而2元是无限的且1元的有⼀一张，所以不不可能不不存在方案。然后这里里可 以使用贪心策略略（根据日常经验）。而因为5元的零钱有限，所以对此需要判断⼀一下，是否会用完5元的 钱。 PS:不不是所有类似题目都是贪心策略略。如果⾯面额为1，5，7找25零钱，贪心结果 7<em>3+1</em>4 实际上 5*5就已经更更优了了。像这种奇怪面额(面额之间的跨度太大，导致出现极端)的就需要考虑动态规划</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void main()&#123;</span><br><span class="line">    &#x2F;&#x2F;需要找的钱，五元纸币的数目</span><br><span class="line">    int x,a,count&#x3D;0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;x,&amp;a);</span><br><span class="line">        </span><br><span class="line">    while(x&#x2F;5&amp;&amp;a&gt;0)&#123;</span><br><span class="line">        x-&#x3D;5;</span><br><span class="line">        a--;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(x&#x2F;2)&#123;</span><br><span class="line">        x-&#x3D;2;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(x&#x3D;&#x3D;1)</span><br><span class="line">        count++;</span><br><span class="line">    printf(&quot;%d&quot;,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师机试</category>
      </categories>
  </entry>
  <entry>
    <title>2019ECNU机试03</title>
    <url>/2020/04/12/2019ECNU%E6%9C%BA%E8%AF%9503/</url>
    <content><![CDATA[<p><img src="/2020/04/12/2019ECNU%E6%9C%BA%E8%AF%9503/C.png" alt></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    int first&#x3D;1,second&#x3D;1,temp;</span><br><span class="line">    bool flag &#x3D;false;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        temp &#x3D; first+second;</span><br><span class="line">        if(temp&gt;&#x3D;n)&#123;</span><br><span class="line">            if(temp&#x3D;&#x3D;n)</span><br><span class="line">                flag&#x3D;true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        first &#x3D; second;</span><br><span class="line">        second &#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(flag)</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师机试</category>
      </categories>
  </entry>
  <entry>
    <title>2019ECNU机试05</title>
    <url>/2020/04/13/2019ECNU%E6%9C%BA%E8%AF%9505/</url>
    <content><![CDATA[<p><img src="/2020/04/13/2019ECNU%E6%9C%BA%E8%AF%9505/E.png" alt></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct point &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	point(int _x,int _y):x(_x),y(_y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m, q;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);</span><br><span class="line">	vector&lt;point&gt; v;</span><br><span class="line">	int x1, y1,x2,y2;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; q;i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2,&amp;y2);</span><br><span class="line">		point p1(x1, y1);</span><br><span class="line">		point p2(x2, y2);</span><br><span class="line">		v.push_back(p1);</span><br><span class="line">		v.push_back(p2);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;创建一个n行m列的矩阵</span><br><span class="line">	&#x2F;&#x2F;int arr[][] &#x3D; new int[n][m];</span><br><span class="line">	vector&lt;vector&lt;int&gt; &gt; arr(n,vector&lt;int&gt;(m));</span><br><span class="line">	int i, j,k,temp;</span><br><span class="line">	for (i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		for (j &#x3D; 0;j &lt; m;j++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">			arr[i][j] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int sum;</span><br><span class="line">	for (i &#x3D; 0;i &lt; q;i++) &#123;</span><br><span class="line">		sum &#x3D; 0;</span><br><span class="line">		point p1 &#x3D; v[2*i];</span><br><span class="line">		point p2 &#x3D; v[2*i+1];</span><br><span class="line">		int startx &#x3D; min(p1.x,p2.x);</span><br><span class="line">		int endx &#x3D; max(p1.x, p2.x);</span><br><span class="line">		int starty &#x3D; min(p1.y, p2.y);</span><br><span class="line">		int endy &#x3D; max(p1.y, p2.y);</span><br><span class="line">		for (j &#x3D; startx - 1;j &lt;&#x3D; endx - 1;j++) &#123;</span><br><span class="line">			for (k &#x3D; starty - 1;k &lt;&#x3D; endy - 1;k++) &#123;</span><br><span class="line">				sum +&#x3D; arr[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,sum);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师机试</category>
      </categories>
  </entry>
  <entry>
    <title>2019ECNU机试04</title>
    <url>/2020/04/12/2019ECNU%E6%9C%BA%E8%AF%9504/</url>
    <content><![CDATA[<p><img src="/2020/04/12/2019ECNU%E6%9C%BA%E8%AF%9504/D.png" alt></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int getIdx(char c)&#123;</span><br><span class="line">    &#x2F;&#x2F;小写字母</span><br><span class="line">    if(c&gt;&#x3D;97)</span><br><span class="line">        return c-&#39;a&#39;+26;</span><br><span class="line">    return c-&#39;A&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun()&#123;</span><br><span class="line">    char str1[51],str2[51];</span><br><span class="line">    scanf(&quot;%s%s&quot;,str1,str2);</span><br><span class="line">    char res[52]&#x3D;&#123;&#39;\0&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    int len1 &#x3D; strlen(str1);</span><br><span class="line">    int len2 &#x3D; strlen(str2);</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;len1;i++)&#123;</span><br><span class="line">        int idx &#x3D; getIdx(str1[i]);</span><br><span class="line">        if(res[idx]&#x3D;&#x3D;&#39;\0&#39;)</span><br><span class="line">            res[idx]&#x3D;str1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int j&#x3D;0;j&lt;len2;j++)&#123;</span><br><span class="line">        int idx &#x3D; getIdx(str2[j]);</span><br><span class="line">        if(res[idx]&#x3D;&#x3D;&#39;\0&#39;)</span><br><span class="line">            res[idx]&#x3D;str2[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D;0;i&lt;52;i++)&#123;</span><br><span class="line">        if(res[i]!&#x3D;&#39;\0&#39;)</span><br><span class="line">            printf(&quot;%c&quot;,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;利用二路归并，但个人感觉第一种方法好点</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void merge(string str1,string str2,int len1,int len2,char* res) &#123;</span><br><span class="line">	</span><br><span class="line">	int idx1&#x3D;0, idx2&#x3D;0,idx&#x3D;0;</span><br><span class="line">	while (idx1&lt;len1&amp;&amp; idx2&lt;len2) &#123;</span><br><span class="line">		if (str1[idx1] &#x3D;&#x3D; str2[idx2]) &#123;</span><br><span class="line">			res[idx++] &#x3D; str1[idx1];</span><br><span class="line">			idx1++;</span><br><span class="line">			idx2++;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (str1[idx1] &lt; str2[idx2])</span><br><span class="line">			res[idx++] &#x3D; str1[idx1++];</span><br><span class="line">		else</span><br><span class="line">			res[idx++] &#x3D; str2[idx2++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(idx1 &lt; len1)res[idx++] &#x3D; str1[idx1++];</span><br><span class="line">	while (idx2 &lt; len2)res[idx++] &#x3D; str2[idx2++];</span><br><span class="line">	res[idx++] &#x3D; &#39;\0&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fun() &#123;</span><br><span class="line"></span><br><span class="line">	string str1, str2;</span><br><span class="line">	cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line"></span><br><span class="line">	sort(str1.begin(),str1.end());</span><br><span class="line">	sort(str2.begin(), str2.end());</span><br><span class="line">	int len1 &#x3D; str1.size();</span><br><span class="line">	int len2 &#x3D; str2.size();</span><br><span class="line">	char* c &#x3D; new char[len1+ len2+1];</span><br><span class="line"></span><br><span class="line">	merge(str1, str2, len1, len2, c);</span><br><span class="line"></span><br><span class="line">	printf(&quot;%s&quot;,c);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师机试</category>
      </categories>
  </entry>
  <entry>
    <title>2019ECNU机试06</title>
    <url>/2020/05/13/2019ECNU%E6%9C%BA%E8%AF%9506/</url>
    <content><![CDATA[<p><img src="/2020/05/13/2019ECNU%E6%9C%BA%E8%AF%9506/F.png" alt></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里这个计算方法会存在误差，当找到mid需要进一步的缩小值的大小</span><br><span class="line">int cnt(int n) &#123;</span><br><span class="line">	int base &#x3D; 5,sum&#x3D;0;</span><br><span class="line">	while (n&#x2F;base!&#x3D;0) &#123;</span><br><span class="line">		sum +&#x3D; n &#x2F; base;</span><br><span class="line">		base *&#x3D; 5;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fun() &#123;</span><br><span class="line">	int k,n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line"></span><br><span class="line">	int mid, temp, begin&#x3D;1, end&#x3D;2e8,latest;</span><br><span class="line">	</span><br><span class="line">	while (begin &lt;&#x3D; end) &#123;</span><br><span class="line">		mid &#x3D; begin+(end-begin)&#x2F;2;</span><br><span class="line">		temp &#x3D; cnt(mid);</span><br><span class="line">		if (temp &#x3D;&#x3D; k) &#123;</span><br><span class="line">			latest &#x3D; mid;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		if (temp&gt;k) &#123;</span><br><span class="line">			latest &#x3D; mid;</span><br><span class="line">			&#x2F;&#x2F;说明在左边</span><br><span class="line">			end &#x3D; mid - 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else if(temp&lt;k)&#123;</span><br><span class="line">			begin &#x3D; mid + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;进一步缩小值的范围</span><br><span class="line">	while (cnt(latest-1)&gt;&#x3D;k) </span><br><span class="line">		latest--;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d\n&quot;, latest);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师机试</category>
      </categories>
  </entry>
  <entry>
    <title>2019ECNU机试07</title>
    <url>/2020/05/14/2019ECNU%E6%9C%BA%E8%AF%9507/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2019ECNU机试09</title>
    <url>/2020/05/14/2019ECNU%E6%9C%BA%E8%AF%9509/</url>
    <content><![CDATA[<p><img src="/2020/05/14/2019ECNU%E6%9C%BA%E8%AF%9509/I.png" alt></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过了给的两个测试点，但可能还有问题</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; arr(10,vector&lt;string&gt;(10));</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">int n, m, p, q;</span><br><span class="line">bool sp &#x3D; false;&#x2F;&#x2F;默认是双点策略</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y,int _sum) &#123;</span><br><span class="line"></span><br><span class="line">	if (x&#x3D;&#x3D;n&amp;&amp;y&#x3D;&#x3D;0) &#123;</span><br><span class="line">		if (_sum &gt; sum)</span><br><span class="line">			sum &#x3D; _sum;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int i, j;</span><br><span class="line">	for (i &#x3D; x;i &lt; n;i++) &#123;</span><br><span class="line">		for (j &#x3D; y;j &lt; m;j++) &#123;</span><br><span class="line">			if (arr[i][j] !&#x3D; &quot;c&quot;) &#123;</span><br><span class="line">				if (j + 1 &lt; m)</span><br><span class="line">					dfs(i, j + 1, _sum);</span><br><span class="line">				else</span><br><span class="line">					dfs(i + 1, 0, _sum);</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (sp) &#123;</span><br><span class="line">				&#x2F;&#x2F;单点策略</span><br><span class="line">				_sum +&#x3D; p;</span><br><span class="line">				arr[i][j] &#x3D; &quot;&quot;;</span><br><span class="line">				if(j+1&lt;m)</span><br><span class="line">					dfs(i,j+1, _sum);</span><br><span class="line">				else</span><br><span class="line">					dfs(i+1, 0, _sum);</span><br><span class="line">				_sum -&#x3D; p;</span><br><span class="line">				arr[i][j] &#x3D; &quot;c&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				&#x2F;&#x2F;非单点</span><br><span class="line">				if (j + 1 &lt; m &amp;&amp; arr[i][j + 1] &#x3D;&#x3D; &quot;c&quot;) &#123;</span><br><span class="line">					&#x2F;&#x2F;消右边</span><br><span class="line">					_sum +&#x3D; q;</span><br><span class="line">					arr[i][j] &#x3D; &quot;&quot;;</span><br><span class="line">					arr[i][j+1] &#x3D; &quot;&quot;;</span><br><span class="line">					if(j + 2&lt;m)</span><br><span class="line">						dfs(i, j + 2, _sum);</span><br><span class="line">					else</span><br><span class="line">						dfs(i+1, 0, _sum);</span><br><span class="line">					_sum -&#x3D; q;</span><br><span class="line">					arr[i][j] &#x3D; &quot;c&quot;;</span><br><span class="line">					arr[i][j + 1] &#x3D; &quot;c&quot;;</span><br><span class="line">				&#125;</span><br><span class="line">				else if (x + 1 &lt; n &amp;&amp; arr[i+1][j] &#x3D;&#x3D; &quot;c&quot;) &#123;</span><br><span class="line">					&#x2F;&#x2F;消下面</span><br><span class="line">					&#x2F;&#x2F;消右边</span><br><span class="line">					_sum +&#x3D; q;</span><br><span class="line">					arr[i][j] &#x3D; &quot;&quot;;</span><br><span class="line">					arr[i+1][j] &#x3D; &quot;&quot;;</span><br><span class="line">					dfs(i+1, j, _sum);</span><br><span class="line">					_sum -&#x3D; q;</span><br><span class="line">					arr[i][j] &#x3D; &quot;c&quot;;</span><br><span class="line">					arr[i+1][j] &#x3D; &quot;c&quot;;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					&#x2F;&#x2F;只剩一个点</span><br><span class="line">					_sum +&#x3D; p;</span><br><span class="line">					arr[i][j] &#x3D; &quot;&quot;;</span><br><span class="line">					if (j + 1 &lt; m)</span><br><span class="line">						dfs(i, j + 1, _sum);</span><br><span class="line">					else</span><br><span class="line">						dfs(i + 1, 0, _sum);</span><br><span class="line">					_sum -&#x3D; p;</span><br><span class="line">					arr[i][j] &#x3D; &quot;c&quot;;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;p, &amp;q);</span><br><span class="line">	int i, j;</span><br><span class="line">	string c;</span><br><span class="line">	for (i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		for (j &#x3D; 0;j &lt; m;j++) &#123;</span><br><span class="line">			cin &gt;&gt; c;</span><br><span class="line">			arr[i][j] &#x3D; c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;用单点代替双点</span><br><span class="line">	if (2 * p &gt; q)</span><br><span class="line">		sp &#x3D; true;</span><br><span class="line"></span><br><span class="line">	dfs(0,0,0);</span><br><span class="line">	cout &lt;&lt; sum;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师机试</category>
      </categories>
  </entry>
  <entry>
    <title>2020-ECNU-PRE-TEST-01</title>
    <url>/2020/05/11/2020-ECNU-PRE-TEST-01/</url>
    <content><![CDATA[<h2 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A+B Problem"></a>A+B Problem</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>请计算两个整数的和并输出结果。</p>
<p>注意不要有不必要的输出，比如”请输入 a 和 b 的值: “。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一行两个整数。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数表示答案。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a,b;</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">  printf(&quot;%d&quot;,a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ECNU模拟测试</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-ECNU-PRE-TEST-02</title>
    <url>/2020/05/11/2020-ECNU-PRE-TEST-02/</url>
    <content><![CDATA[<h2 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>凯撒加密，是一种古老的加密技术，是把条信息中的每个字母用字母表中固定距离（k）之后的那个字母代替。可先输入一个k，接着输入一个字符串（字符串全是小写的英文字母）。试着编写程序，将字符串中的字符进行K值凯撒加密。例如：k=2，字符 a 经过k值凯撒加密之后变为 c ，而字符 z 经过k值凯撒加密之后变为字符b。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>先输入距离k值，接着输入将要加密的字符串。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出k值凯撒加密之后的字符串</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mjqqt</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">zb</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bd</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  </span><br><span class="line">  char str[1024];</span><br><span class="line">  int k,i&#x3D;0;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">  scanf(&quot;%s&quot;,str);</span><br><span class="line">  while(str[i]!&#x3D;&#39;\0&#39;)&#123;</span><br><span class="line">  	char c &#x3D; (str[i++] - 97 + k) % 26+97;</span><br><span class="line">	printf(&quot;%c&quot;, c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ECNU模拟测试</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-ECNU-PRE-TEST-03</title>
    <url>/2020/05/11/2020-ECNU-PRE-TEST-03/</url>
    <content><![CDATA[<h2 id="新的A-B"><a href="#新的A-B" class="headerlink" title="新的A+B"></a>新的A+B</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>题的目标很简单，就是求两个正整数A和B的和，其中A和B都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入在一行给出A和B，其间以空格分开。问题是A和B不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。</p>
<p>注意：我们把输入中出现的第1个空格认为是A和B的分隔。题目保证至少存在一个空格，并且B不是一个空字符串。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果输入的确是两个正整数，则按格式A + B = 和输出。如果某个输入不合要求，则在相应位置输出?，显然此时和也是?。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 456</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 + 456 &#x3D; 579</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22. 18</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? + 18 &#x3D; ?</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-100 blabla bla...33</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? + ? &#x3D; ?</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	char str1[50];</span><br><span class="line">	char str2[50];</span><br><span class="line">	scanf(&quot;%s%s&quot;, str1, str2);</span><br><span class="line">	bool flag1 &#x3D; true, flag2 &#x3D; true;</span><br><span class="line">	int i &#x3D; 0,num,num1&#x3D;0,num2&#x3D;0;</span><br><span class="line">	while (str1[i] !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">		if (i &gt;&#x3D; 4)</span><br><span class="line">			break;</span><br><span class="line">		num &#x3D; str1[i++] - &#39;0&#39;;</span><br><span class="line">		if(num&gt;&#x3D;0&amp;&amp;num&lt;&#x3D;9)&#123;</span><br><span class="line">			num1 &#x3D; num1 * 10 + num;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			flag1 &#x3D; false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i &#x3D; 0;</span><br><span class="line">	while (str2[i] !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">		if (i &gt;&#x3D; 4)</span><br><span class="line">			break;</span><br><span class="line">		num &#x3D; str2[i++] - &#39;0&#39;;</span><br><span class="line">		if (num &gt;&#x3D; 0 &amp;&amp; num &lt;&#x3D; 9) &#123;</span><br><span class="line">			num2 &#x3D; num2 * 10 + num;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			flag2 &#x3D; false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!flag1) &#123;</span><br><span class="line"></span><br><span class="line">		printf(&quot;?&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		printf(&quot;%d&quot;,num1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot; + &quot;);</span><br><span class="line">	if (!flag2) &#123;</span><br><span class="line"></span><br><span class="line">		printf(&quot;?&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		printf(&quot;%d&quot;, num2);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot; &#x3D; &quot;);</span><br><span class="line">	if (!flag1|| !flag2) &#123;</span><br><span class="line">		printf(&quot;?&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		printf(&quot;%d&quot;, num1+num2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ECNU模拟测试</tag>
      </tags>
  </entry>
  <entry>
    <title>2020ECNU机试01</title>
    <url>/2020/05/15/2020ECNU%E6%9C%BA%E8%AF%9501/</url>
    <content><![CDATA[<p><img src="/2020/05/15/2020ECNU%E6%9C%BA%E8%AF%9501/1.png" alt></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int arr[100], arr1[100], arr2[100];</span><br><span class="line">int countz &#x3D; 0, countf &#x3D; 0, zeroIndx &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正数升序</span><br><span class="line">void incr() &#123;</span><br><span class="line">	bool flag;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; countz;i++) &#123;</span><br><span class="line">		flag &#x3D; false;</span><br><span class="line">		for (int j &#x3D; 0;j &lt; countz - i - 1;j++) &#123;</span><br><span class="line">			if (arr1[j]&gt; arr1[j+1]) &#123;</span><br><span class="line">				int temp &#x3D; arr1[j];</span><br><span class="line">				arr1[j] &#x3D; arr1[j + 1];</span><br><span class="line">				arr1[j + 1] &#x3D; temp;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!flag)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负数降序</span><br><span class="line">void decr() &#123;</span><br><span class="line">	bool flag;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; countf;i++) &#123;</span><br><span class="line">		flag &#x3D; false;</span><br><span class="line">		for (int j &#x3D; 0;j &lt; countf - i - 1;j++) &#123;</span><br><span class="line">			if (arr2[j] &lt; arr2[j + 1]) &#123;</span><br><span class="line">				int temp &#x3D; arr2[j];</span><br><span class="line">				arr2[j] &#x3D; arr2[j + 1];</span><br><span class="line">				arr2[j + 1] &#x3D; temp;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!flag)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n,temp;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	</span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		&#x2F;&#x2F;scanf(&quot;%d&quot;, &amp;temp);</span><br><span class="line">		cin &gt;&gt; temp;</span><br><span class="line">		arr[i] &#x3D; temp;</span><br><span class="line">		if (temp &gt; 0) &#123;</span><br><span class="line">			arr1[countz++] &#x3D; temp;</span><br><span class="line">		&#125;else if (temp &lt; 0)</span><br><span class="line">			arr2[countf++] &#x3D; temp;</span><br><span class="line">		else</span><br><span class="line">			zeroIndx &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	incr();&#x2F;&#x2F;对正数升序</span><br><span class="line">	decr();&#x2F;&#x2F;对负数降序</span><br><span class="line">	int a &#x3D; 0, b &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;正数升序，负数降序</span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		if (arr[i] &gt; 0) &#123;</span><br><span class="line">			arr[i] &#x3D; arr1[a++];</span><br><span class="line">		&#125;</span><br><span class="line">		else if (arr[i] &lt;0) &#123;</span><br><span class="line">			arr[i] &#x3D; arr2[b++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		if(i&#x3D;&#x3D;0)printf(&quot;%d&quot;,arr[i]);</span><br><span class="line">		else </span><br><span class="line">			printf(&quot; %d&quot;,arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>2020ECNU</category>
      </categories>
  </entry>
  <entry>
    <title>51单片机</title>
    <url>/2020/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><h4 id="微型计算机"><a href="#微型计算机" class="headerlink" title="微型计算机"></a>微型计算机</h4><p>&emsp;&emsp;将微处理器CPU、存储器（RAM、ROM）、基本输入/输出（I/O）接口电路和<strong>总线</strong>接口等组装在一块主机板（即微机主板）。各种适配（卡）插在主机板的扩展槽上并与电源、软/硬盘驱动器和光驱等装在同一机箱内，再配上系统软件，就构成了一台完整的微型计算机系统。微型计算机硬件组成如图所示：</p>
<p><img src="/2020/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/1.png" alt="微型计算机"></p>
<p><img src="/2020/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/2.jpg" alt="树莓派4B"></p>
<h4 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h4><p>&emsp;&emsp;单片机又称单片微控制器,它不是完成某一个逻辑功能的芯片,而是把一个计算机系统集成到一个芯片上。概括的讲：一块芯片就成了一台计算机。在一片集成电路芯片上集成中央处理器（CPU）、存储器（ROM/RAM）、I/O接口电路，从而构成了单芯片微型计算机，简称单片机。常用英文字母的缩写MCU（Micro Controller Unit）表示单片机。</p>
<h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>&emsp;&emsp;单片机内部结构示意图如图所示，它由<strong>微处理器CPU</strong>、随机存取存储器<strong>RAM</strong>、只读存储器<strong>ROM</strong>、基本<strong>输入/输出(I/O)</strong>接口电路、<strong>定时器/计数器</strong>和<strong>中断系统</strong>等部件组成，并把它们制作在一块大规模集成电路芯片上，就构成一个完整的单片微型计算机。</p>
<p><img src="/2020/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/3.gif" alt="结构图"></p>
<h4 id="应用系统的组成"><a href="#应用系统的组成" class="headerlink" title="应用系统的组成"></a>应用系统的组成</h4><p>&emsp;&emsp;单片机应用系统是以单片机为核心，再加上接口电路及外设等硬件电路和软件，就构成了单片机应用系统。因此，单片机应用系统的设计人员必须从硬件和软件角度来研究单片机，这样才能研究和开发出单片机应用系统和产品。</p>
<h4 id="80C51单片机系列"><a href="#80C51单片机系列" class="headerlink" title="80C51单片机系列"></a>80C51单片机系列</h4><p>&emsp;&emsp;虽然目前单片机的品种很多，51系列的典型芯片是<code>80C51（CHMOS型的8051）</code>。为此，众多的厂商都介入了以<code>80C51为</code>代表的8位单片机的发展，如<code>Philips</code>、<code>Siemens（Infineon）</code>、<code>Dallas</code>、<code>ATMEL</code>、<code>STC</code>等公司，我们把这些公司生产的与<code>80C51</code>兼容的单片机统称为<code>80C51</code>系列。如：<code>ATMEL</code>公司的<code>AT89S51</code> 、<code>AT89S52</code> 、<code>AT89S53</code>。<code>STC</code>公司的<code>STC89C51</code> 、<code>STC89C52</code> 、<code>STC89C53</code>。</p>
<img src="/2020/02/29/51%E5%8D%95%E7%89%87%E6%9C%BA/4.png" style="zoom:50%;">

<h3 id="单片机的特点及应用领域"><a href="#单片机的特点及应用领域" class="headerlink" title="单片机的特点及应用领域"></a>单片机的特点及应用领域</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>单片机芯片的集成度非常高，它将微型计算机的主要部件都集成在一块芯片上，因此，具有如下特点：</p>
<ol>
<li>体积小、重量轻、价格低、耗电少、易于产品化。</li>
<li>实时控制功能强，运行速度快。因为CPU可以对I/O端口直接进行指令操作，而且位指令操作能力更是其它计算机无法比拟的。</li>
<li>可靠性高。由于CPU、存储器及I/O接口集成在同一芯片内，各部件间的连接紧凑，数据在传送时受干扰的影响较小，且不易受环境条件的影响，所以单片机的可靠性非常高。</li>
</ol>
<h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><ul>
<li>家用电器。家用电器是单片机的重要应用领域之一，前景广阔。如微波炉、电视机、电饭煲、空调器、电冰箱、洗衣机等。</li>
<li>在交通领域中。如交通灯、汽车、火车、飞机等均有单片机的广泛应用。</li>
<li>智能仪器仪表。如各种智能电气测量仪表、智能传感器等。</li>
<li>机电一体化产品。如医疗设备（B超）、机人、数控机床、自动包装机、打印机、复印机等。</li>
<li>实时工业控制。如温度控制、电机转速控制、生产线控制等。</li>
</ul>
<h4 id="80C51与STC89C52的区别"><a href="#80C51与STC89C52的区别" class="headerlink" title="80C51与STC89C52的区别"></a>80C51与STC89C52的区别</h4><ul>
<li><p>Intel公司在1980年推出<code>80C51</code>系列单片机，由于<code>80C51</code>单片机应用早，影响面很大，已经成为工业标准。后来很多著名厂商如<code>Atmel</code>，<code>philps</code>等公司申请了版权，生产了各种与<code>80C51</code>兼容的单片机系列。虽然制造工艺在不断地改进，但内核却没有变化，指令系统完全兼容，而且大多数管脚也兼容。因此，我们称这些与<code>80C51</code>内核相同的单片机为<code>80C51</code>系列单片机或51系列单片机。</p>
</li>
<li><p>由于<code>80C51</code>单片机是早期产品，用户无法将自己编写的应用程序烧写到单片机内的存储器，只能将程序交由芯片厂商代为烧写，并且是一次性的。8751单片机的内部存储器有了改进，用户可以将自己编写的程序写入单片机的内部存储器中，但需要用紫外线灯照射25分钟以上再烧写，烧写次数和电压也是有一定限制的。</p>
</li>
<li><p><code>STC89C52</code>单片机是<code>STC</code>公司生产的产品，它把<code>80C51</code>内核与<code>Flash</code>技术相结合，推出可在线编程的单片机。   <code>STC89C52</code>单片机指令系统、管脚完全与<code>80C51</code>兼容。</p>
</li>
</ul>
<p><strong>单片机的发展趋势</strong></p>
<p>&emsp;&emsp;20世纪80年代以来，单片机有了新的发展，各半导体器件厂商也纷纷推出自己的产品系列。根据市场的需求要求，未来单片机的发展趋势有如下几个方面：</p>
<ol>
<li>单片机的字长由4位、8位、16位发展到32位。</li>
<li>目前8位的单片机仍然占主流地位，只有在精度要求特别高的场合如图像处理等，才采用16位或32位的单片机，用户可以根据需要进行字长的选择。</li>
<li>运行速度不断提高。单片机的使用最高频率由<strong>6MHz</strong>、<strong>12MHz</strong>、<strong>24MHz</strong>、<strong>33MHz</strong>发展到<strong>40MHz</strong>和更高，用户可以根据产品的需要进行速度的选择。</li>
</ol>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
  </entry>
  <entry>
    <title>B树与B+树</title>
    <url>/2020/03/10/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;我们都知道二叉查找树的查找的时间复杂度是<code>O(log N)</code>，其查找效率已经足够高了，那为什么还有B树和B+树的出现呢？难道它两的时间复杂度比二叉查找树还小吗？<br>&emsp;&emsp;答案当然不是，Ｂ树和Ｂ＋树的出现是因为另外一个问题，那就是磁盘IO；众所周知，IO操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。<br>　　所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。一个基本的思路就是：</p>
<ol>
<li>每个节点存储多个元素</li>
<li>摒弃二叉树结构，采用多叉树</li>
</ol>
<p>　　这样就引出来了一个新的查找树结构 ——多路查找树。 根据AVL给我们的启发，一颗平衡多路查找树(B~树)自然可以使得数据的查找效率保证在<code>O(log N)</code>这样的对数级别上。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p>首先得了解什么是B树的阶：</p>
<blockquote>
<p>所有节点度的最大值（孩子节点数）为B树的阶。</p>
</blockquote>
</li>
<li><p>m阶B树的特性</p>
<blockquote>
<ol>
<li>每个节点最多有m棵子树（该节点有m-1个关键字）</li>
<li>根节点若非终端节点（叶子节点），则至少有2棵子树，不受[m/2]向上取整的约束</li>
<li>除根节点外的所有非叶子节点<strong>至少</strong>有[m/2]向上取整棵子树，[m/2]-1向上取整个关键字</li>
<li>所有叶子节点都出现在同一层上，并不带任何信息</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th align="center">关键字数</th>
<th align="center">树高</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[m/2]-1 &lt;= n &lt;= m-1</td>
<td align="center">logm<sup>(n+1)</sup> &lt;= h &lt;= log[m/2]<sup>(n+1)/2+1</sup></td>
</tr>
</tbody></table>
</li>
<li><p>B树的结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>,<span class="title">int</span> <span class="title">order</span>&gt;//<span class="title">order</span>表示<span class="title">B</span>树的阶</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> count;<span class="comment">//节点中关键字的个数</span></span><br><span class="line">	Record data[order<span class="number">-1</span>];<span class="comment">//阶数-1个关键字</span></span><br><span class="line">	node&lt;Record,order&gt;* branch[order];<span class="comment">//分支表</span></span><br><span class="line">	node();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Record</span>,<span class="title">int</span> <span class="title">order</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">btree</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node&lt;Record,order&gt;* root;<span class="comment">//树根</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class Record,int order&gt;</span><br><span class="line">bool search(node&lt;Record,order&gt;* current,Record &amp;target)&#123;</span><br><span class="line">	int posi;</span><br><span class="line">	bool exist;</span><br><span class="line">	if(current!&#x3D;null)&#123;</span><br><span class="line">		exist &#x3D; search(current, target, posi);&#x2F;&#x2F;节点内查找</span><br><span class="line">		if(!exist)</span><br><span class="line">			exist &#x3D; search(current-&gt;branch[posi], target);&#x2F;&#x2F;树内查找</span><br><span class="line">		else</span><br><span class="line">			target &#x3D; current-&gt;data[posi];</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class Record,int order&gt;</span><br><span class="line">bool search_node(node&lt;Record,order&gt;* current,Record &amp;target,int &amp;posi)&#123;</span><br><span class="line">	posi&#x3D;0;</span><br><span class="line">	&#x2F;&#x2F;只要比target小，一直往右移动；posi的位置的data是大于等于target的</span><br><span class="line">	while(posi &lt; current-&gt;count &amp;&amp; target &gt; current-&gt;data[posi])</span><br><span class="line">		posi++;</span><br><span class="line">    if(posi &lt; current-&gt;count &amp;&amp; target &#x3D;&#x3D; current-&gt;data[posi])</span><br><span class="line">    	return 1;</span><br><span class="line">    else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h4><ol>
<li><p>定位</p>
<blockquote>
<p>利用B树的查找，找到最底层中的某个非叶子节点</p>
</blockquote>
</li>
<li><p>插入</p>
<blockquote>
<p>注意关键字个数在[m/2]-1  ~  m-1内，否则进行节点分裂</p>
</blockquote>
<p>例如3阶B树分裂，关键字数范围[1,2]，中间节点上移，以该节点分裂：</p>
<img src="/2020/03/10/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/insert.jpg" style="zoom: 50%;">
</li>
<li><p>code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class Record,int order&gt;</span><br><span class="line">bool insert(const Record &amp;new_entry)&#123;</span><br><span class="line">	Record median;&#x2F;&#x2F;分裂后的中间元素</span><br><span class="line">	node&lt;Record,order&gt;* right_branch,*new_root;</span><br><span class="line">	bool result &#x3D; push_down(root,new_entry,right_branch);</span><br><span class="line">	if(result&#x3D;&#x3D;overflow)&#123;</span><br><span class="line">		new_root &#x3D; new node&lt;Record,order&gt;;</span><br><span class="line">		new_root-&gt;count&#x3D;1;</span><br><span class="line">		new_root-&gt;data[0]&#x3D;median;</span><br><span class="line">		new_root-&gt;branch[0]&#x3D;root;</span><br><span class="line">		new_root-&gt;branch[1]&#x3D;right_branch;</span><br><span class="line">		root &#x3D; new_root;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class Record,int order&gt;</span><br><span class="line">push_down(node&lt;Record,order&gt;* current,</span><br><span class="line">	const Record &amp;new_entry,</span><br><span class="line">	node&lt;Record,order&gt;* &amp;right_branch)&#123;</span><br><span class="line">	int posi;</span><br><span class="line">	if(current&#x3D;&#x3D;null)&#123;</span><br><span class="line">		median &#x3D; new_entry;</span><br><span class="line">		right_branch&#x3D;null;</span><br><span class="line">		result &#x3D; overflow;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if(search(current,new_entry,posi))</span><br><span class="line">			result &#x3D; duplicate_error;</span><br><span class="line">		else</span><br><span class="line">			Record 未完待续。。。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h4><ol>
<li><p>删除终端节点</p>
<ul>
<li>节点关键字数  &gt;  [m/2]-1，直接删除</li>
<li>节点关键字数  =  [m/2]-1<ul>
<li>兄弟够借，通过父亲借兄弟</li>
<li>兄弟不够借，拉父下水一起穷</li>
</ul>
</li>
</ul>
</li>
<li><p>删除非终端节点（找前驱/后继取代法）</p>
<p>找到取代关键字后与法1相同。</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>B树主要用于文件系统以及部分数据库索引，例如：<code>MongoDB</code>。而大部分关系数据库则使用B+树做索引，例如：<code>mysql</code>数据库；</li>
<li>从查找效率考虑一般要求B树的阶数m &gt;= 3;</li>
<li>B-树上算法的执行时间主要由读、写磁盘的次数来决定，故一次I/O操作应读写尽可能多的信息。因此B-树的结点规模一般以一个磁盘页为单位。一个结点包含的关键字及其孩子个数取决于磁盘页的大小。</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>&emsp;&emsp;B+树是Ｂ树的变种，有着比Ｂ树更高的查询效率。下面，我们就来看看B+树和B树有什么不同</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ol>
<li><p>一个关键字对应一个分支，即n个关键字的节点有n棵子树（B树中是k-1个关键字对应k棵子树），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p>
</li>
<li><p>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小<br>自小而大顺序链接。</p>
</li>
<li><p>非叶子节点中的关键字为对应子树的最大关键字（非叶子节点仅起到索引的作用）。</p>
</li>
</ol>
<p>下面是一棵3阶的B+树：</p>
<img src="/2020/03/10/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/1.jpg" style="zoom: 80%;">

<p>&emsp;&emsp;B+树通常有两个指针，一个指向根结点，另一个指向关键字最小的叶子结点。因些，对于B+树进行查找两种运算：一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找。</p>
<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>　　B+树的优势在于查找效率上，下面我们做一具体说明：<br>　　首先，Ｂ＋树的查找和Ｂ树一样，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。<br>　　（1）、不同的是，Ｂ＋树中间节点没有卫星数据（索引元素所指向的数据记录），只有索引，而Ｂ树每个结点中的每个关键字都有卫星数据；这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，Ｂ＋树更加“矮胖”，ＩＯ操作更少</p>
<p><strong>B树的索引数据：</strong></p>
<img src="/2020/03/10/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/2.jpg" style="zoom:80%;">

<p><strong>B+树的索引数据：</strong></p>
<img src="/2020/03/10/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/3.jpg" style="zoom:80%;">

<p>&emsp;&emsp;在数据库的聚集索引<code>（Clustered Index）</code>中，叶子节点直接包含索引数据。在非聚集索引<code>（NonClustered Index）</code>中，叶子节点带有指向索引数据的指针。</p>
<p>　　其次，因为索引数据的不同，导致查询过程也不同；Ｂ树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而Ｂ＋树每次必须查找到叶子结点，性能稳定</p>
<p>　　<strong>在范围查询方面，B+树的优势更加明显</strong></p>
<blockquote>
<ul>
<li>B树的范围查找需要不断依赖中序遍历。首先二分查找到范围下限，在不断通过中序遍历，知道查找到范围的上限即可。整个过程比较耗时。</li>
<li>而B+树的范围查找则简单了许多。首先通过二分查找，找到范围下限，然后同过叶子结点的链表顺序遍历，直至找到上限即可，整个过程简单许多，效率也比较高。</li>
</ul>
</blockquote>
<p>例如：同样查找范围[3-11]，两者的查询过程如下：</p>
<ul>
<li><strong>B树的查找过程：</strong></li>
</ul>
<p><img src="/2020/03/10/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/4.png" alt></p>
<ul>
<li><strong>B+树的查找过程：</strong></li>
</ul>
<img src="/2020/03/10/B%E6%A0%91%E4%B8%8EB-%E6%A0%91/5.png" style="zoom:80%;">

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>　　 B+树的插入与B树的插入过程类似。不同的是B+树在叶结点上进行，如果叶结点中的关键码个数超过m，就必须分裂成关键码数目大致相同的两个结点，并保证上层结点中有这两个结点的最大关键码。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>　　B+树中的关键码在叶结点层删除后，其在上层的复本可以保留，作为一个”分解关键码”存在，如果因为删除而造成结点中关键码数小于ceil(m/2)，其处理过程与B-树的处理一样。在此，我就不多做介绍了。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><strong>B+树相比B树的优势</strong>：</p>
<ol>
<li>单一节点存储更多的元素，使得查询的IO次数更少；　</li>
<li>所有查询都要查找到叶子节点，查询性能稳定；　　</li>
<li>所有叶子节点形成有序链表，便于范围查询。</li>
</ol>
]]></content>
      <categories>
        <category>查找树</category>
      </categories>
      <tags>
        <tag>B Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS深度优先搜索</title>
    <url>/2020/02/17/DFS%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Centos6和7的区别</title>
    <url>/2020/04/10/Centos6%E5%92%8C7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="桌面系统"><a href="#桌面系统" class="headerlink" title="桌面系统"></a>桌面系统</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] GNOME 2.x</span><br><span class="line">[CentOS7] GNOME 3.x（GNOME Shell）</span><br></pre></td></tr></table></figure>

<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] ext4</span><br><span class="line">[CentOS7] xfs</span><br></pre></td></tr></table></figure>

<h3 id="内核版本"><a href="#内核版本" class="headerlink" title="内核版本"></a>内核版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] 2.6.x-x</span><br><span class="line">[CentOS7] 3.10.x-x</span><br></pre></td></tr></table></figure>

<h3 id="启动加载器"><a href="#启动加载器" class="headerlink" title="启动加载器"></a>启动加载器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] GRUB Legacy (+efibootmgr)</span><br><span class="line">[CentOS7] GRUB2</span><br></pre></td></tr></table></figure>

<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] iptables</span><br><span class="line">[CentOS7] firewalld</span><br></pre></td></tr></table></figure>

<h3 id="默认数据库"><a href="#默认数据库" class="headerlink" title="默认数据库"></a>默认数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] MySQL</span><br><span class="line">[CentOS7] MariaDB</span><br></pre></td></tr></table></figure>

<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] &#x2F;bin, &#x2F;sbin, &#x2F;lib, and &#x2F;lib64在&#x2F;下</span><br><span class="line">[CentOS7] &#x2F;bin, &#x2F;sbin, &#x2F;lib, and &#x2F;lib64移到&#x2F;usr下</span><br></pre></td></tr></table></figure>

<h3 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6] &#x2F;etc&#x2F;sysconfig&#x2F;network</span><br><span class="line">[CentOS7] &#x2F;etc&#x2F;hostname</span><br></pre></td></tr></table></figure>

<h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ ntp</span><br><span class="line">$ ntpq -p</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ chrony</span><br><span class="line">$ chronyc sources</span><br></pre></td></tr></table></figure>

<h3 id="修改时间"><a href="#修改时间" class="headerlink" title="修改时间"></a>修改时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ vim &#x2F;etc&#x2F;sysconfig&#x2F;clock</span><br><span class="line">   ZONE&#x3D;&quot;Asia&#x2F;Tokyo&quot;</span><br><span class="line">   UTC&#x3D;fales</span><br><span class="line">$ sudo ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Tokyo &#x2F;etc&#x2F;localtime</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ timedatectl set-timezone Asia&#x2F;Tokyo</span><br><span class="line">$ timedatectl status</span><br></pre></td></tr></table></figure>

<h3 id="修改地区"><a href="#修改地区" class="headerlink" title="修改地区"></a>修改地区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ vim &#x2F;etc&#x2F;sysconfig&#x2F;i18n</span><br><span class="line">   LANG&#x3D;&quot;ja_JP.utf8&quot;</span><br><span class="line">$ &#x2F;etc&#x2F;sysconfig&#x2F;i18n</span><br><span class="line">$ locale</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ localectl set-locale LANG&#x3D;ja_JP.utf8</span><br><span class="line">$ localectl status</span><br></pre></td></tr></table></figure>

<h3 id="服务相关"><a href="#服务相关" class="headerlink" title="服务相关"></a>服务相关</h3><h4 id="启动停止"><a href="#启动停止" class="headerlink" title="启动停止"></a>启动停止</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ service service_name start</span><br><span class="line">$ service service_name stop</span><br><span class="line">$ service sshd restart&#x2F;status&#x2F;reload</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ systemctl start service_name</span><br><span class="line">$ systemctl stop service_name</span><br><span class="line">$ systemctl restart&#x2F;status&#x2F;reload sshd</span><br></pre></td></tr></table></figure>

<h4 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ chkconfig service_name on&#x2F;off</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ systemctl enable service_name</span><br><span class="line">$ systemctl disable service_name</span><br></pre></td></tr></table></figure>

<h4 id="服务一览"><a href="#服务一览" class="headerlink" title="服务一览"></a>服务一览</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ chkconfig --list</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ systemctl list-unit-files</span><br><span class="line">$ systemctl --type service</span><br></pre></td></tr></table></figure>

<h4 id="强制停止"><a href="#强制停止" class="headerlink" title="强制停止"></a>强制停止</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ kill -9 &lt;PID&gt;</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ systemctl kill --signal&#x3D;9 sshd</span><br></pre></td></tr></table></figure>

<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ netstat</span><br><span class="line">$ netstat -I</span><br><span class="line">$ netstat -n</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ ip n</span><br><span class="line">$ ip -s l</span><br><span class="line">$ ss</span><br></pre></td></tr></table></figure>

<h4 id="IP地址MAC地址"><a href="#IP地址MAC地址" class="headerlink" title="IP地址MAC地址"></a>IP地址MAC地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ ifconfig -a</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ ip address show</span><br></pre></td></tr></table></figure>

<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ route -n</span><br><span class="line">$ route -A inet6 -n</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ ip route show</span><br><span class="line">$ ip -6 route show</span><br></pre></td></tr></table></figure>

<h3 id="重启关闭"><a href="#重启关闭" class="headerlink" title="重启关闭"></a>重启关闭</h3><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ shutdown -h now </span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ poweroff</span><br><span class="line">$ systemctl poweroff</span><br></pre></td></tr></table></figure>

<h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ reboot</span><br><span class="line">$ shutdown -r now</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ reboot</span><br><span class="line">$ systemctl reboot</span><br></pre></td></tr></table></figure>

<h4 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">$ init S</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">$ systemctl rescue</span><br></pre></td></tr></table></figure>

<h4 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CentOS6]</span><br><span class="line">[GUICUI]</span><br><span class="line">$ vim &#x2F;etc&#x2F;inittab</span><br><span class="line">  id:3:initdefault:</span><br><span class="line">[CUIGUI]</span><br><span class="line">$ startx</span><br><span class="line"></span><br><span class="line">[CentOS7]</span><br><span class="line">[GUICUI]</span><br><span class="line">$ systemctl isolate multi-user.target</span><br><span class="line">[CUIGUI]</span><br><span class="line">$systemctl isolate graphical.target</span><br><span class="line">默认</span><br><span class="line">$ systemctl set-default graphical.target</span><br><span class="line">$ systemctl set-default multi-user.target</span><br><span class="line">当前</span><br><span class="line">$ systemctl get-default</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>EOJ-1-12-矩形面积交</title>
    <url>/2020/05/12/EOJ-1-12-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E4%BA%A4/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入仅包含两行，每行描述一个矩形。</p>
<p>在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出仅包含一个实数，为交的面积，保留到小数后两位。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 3 3</span><br><span class="line">2 2 4 4</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.00</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  </span><br><span class="line">  double x1, y1, x2, y2;</span><br><span class="line">	double x3, y3, x4, y4;</span><br><span class="line">	scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">	scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x3, &amp;y3, &amp;x4, &amp;y4);</span><br><span class="line"></span><br><span class="line">	double minx1, maxx1, miny1, maxy1, minx2, maxx2, miny2, maxy2;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获得矩形的最小，最大的顶点值</span><br><span class="line">	minx1 &#x3D; min(x1,x2);</span><br><span class="line">	maxx1 &#x3D; max(x1,x2);</span><br><span class="line">	miny1 &#x3D; min(y1,y2);</span><br><span class="line">	maxy1 &#x3D; max(y1,y2);</span><br><span class="line"></span><br><span class="line">	minx2 &#x3D; min(x3, x4);</span><br><span class="line">	maxx2 &#x3D; max(x3, x4);</span><br><span class="line">	miny2 &#x3D; min(y3, y4);</span><br><span class="line">	maxy2 &#x3D; max(y3, y4);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;判断两个矩形是否相切或相离</span><br><span class="line">	if (minx1&gt;&#x3D;maxx2||minx2&gt;&#x3D;maxx1||miny1&gt;&#x3D;maxy2||miny2&gt;&#x3D;maxy1) &#123;</span><br><span class="line">		printf(&quot;0.00&quot;);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		double a, b;</span><br><span class="line">		&#x2F;&#x2F;找到矩形的的内测的各个小点，组成矩形</span><br><span class="line">		a &#x3D; min(maxx1, maxx2) - max(minx1, minx2);</span><br><span class="line">		b &#x3D; min(maxy1, maxy2) - max(miny1,miny2);</span><br><span class="line">		printf(&quot;%.2lf&quot;, a * b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ-1-17-芯片测试</title>
    <url>/2020/05/12/EOJ-1-17-%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。</p>
<p>每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。</p>
<p>给出所有芯片的测试结果，问哪些芯片是好芯片。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据第一行为一个整数n，表示芯片个数。</p>
<p>第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本 身进行测试）。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>按从小到大的顺序输出所有好芯片的编号</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 0 1</span><br><span class="line">0 1 0</span><br><span class="line">1 0 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int arr[20][20];</span><br><span class="line">int main()&#123;</span><br><span class="line">  int n;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  int i,j;</span><br><span class="line">  for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">  	for(j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">    	scanf(&quot;%d&quot;,&amp;arr[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int cnt[20]&#x3D;&#123;0&#125;;</span><br><span class="line">  &#x2F;&#x2F;注意，好芯片比坏芯片多</span><br><span class="line">  </span><br><span class="line">  for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">  	for(j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">    	cnt[i]+&#x3D;arr[j][i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;减去每个芯片自检都为1的结果，因为好芯片比坏芯片多，剩下的数量肯定大于等于半数</span><br><span class="line">    cnt[i]--;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">  	if(cnt[i]&gt;&#x3D;n&#x2F;2)&#123;</span><br><span class="line">    	printf(&quot;%d&quot;,i+1);</span><br><span class="line">      	if(i!&#x3D;n-1)</span><br><span class="line">          printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>EOJ-319-字符串出现次数</title>
    <url>/2020/03/22/EOJ-319-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>定义函数 <code>count(s,t)</code>，计算 t 在 s 中出现的次数。输入数据保证如有多个 t 的话，这些 t 不会相互重叠。</p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>例如：<code>ab</code> 在 <code>abcdabcd</code> 中出现 2 次，<code>aa</code> 在 <code>xyaabb</code> 中出现 1 次，<code>xy</code> 在 <code>x</code> 中出现 0 次。<br>只需按要求写出函数定义，并使用给定的测试程序测试你所定义函数的正确性。<br>不要改动测试程序。<br>测试正确后，将测试程序和函数定义一起提交到考试系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***************************************************************&#x2F;</span><br><span class="line">&#x2F;*                                                             *&#x2F;</span><br><span class="line">&#x2F;*  DON&#39;T MODIFY main function ANYWAY!                         *&#x2F;</span><br><span class="line">&#x2F;*                                                             *&#x2F;</span><br><span class="line">&#x2F;***************************************************************&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int count(char s[],char t[])</span><br><span class="line">&#x2F;* precondition: s 和 t 是两个字符串，t 不会是空串，且 t 不会重叠</span><br><span class="line">   postcondition: 返回 t 在 s 中出现的次数</span><br><span class="line">*&#x2F;</span><br><span class="line">&#123; &#x2F;&#x2F;TODO: your function definition</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;***************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">#define N 80</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;   char s[N+1],t[N+1];</span><br><span class="line">    scanf(&quot;%s%s&quot;,s,t);</span><br><span class="line">&#x2F;&#x2F;********** count is called here ******************</span><br><span class="line">    printf(&quot;%d\n&quot;,count(s,t));</span><br><span class="line">&#x2F;&#x2F;**************************************************</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int count(char s[],char t[])</span><br><span class="line">&#x2F;* precondition: s 和 t 是两个字符串，t 不会是空串，且 t 不会重叠</span><br><span class="line">   postcondition: 返回 t 在 s 中出现的次数</span><br><span class="line">*&#x2F;</span><br><span class="line">&#123; &#x2F;&#x2F;TODO: your function definition</span><br><span class="line">    int cnt &#x3D; 0, s_len &#x3D; strlen(s), t_len &#x3D; strlen(t);</span><br><span class="line">	int i, j;</span><br><span class="line">	for (i &#x3D; 0,j&#x3D;0;i &lt; s_len;i++) &#123;</span><br><span class="line">		if (s[i] &#x3D;&#x3D; t[j]) &#123;</span><br><span class="line">			if (j&#x3D;&#x3D; t_len-1) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;else</span><br><span class="line">			j &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;***************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">#define N 80</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;   char s[N+1],t[N+1];</span><br><span class="line">    scanf(&quot;%s%s&quot;,s,t);</span><br><span class="line">&#x2F;&#x2F;********** count is called here ******************</span><br><span class="line">    printf(&quot;%d\n&quot;,count(s,t));</span><br><span class="line">&#x2F;&#x2F;**************************************************</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>EOJ</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>FSATJSON工具</title>
    <url>/2020/05/30/FSATJSON%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.47&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="案例编码"><a href="#案例编码" class="headerlink" title="案例编码"></a>案例编码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;存储数据</span><br><span class="line">public void fun(JSONObject object)&#123;</span><br><span class="line">	&#x2F;&#x2F;string</span><br><span class="line">  	object.put(&quot;string&quot;,&quot;string&quot;);</span><br><span class="line">  	</span><br><span class="line">    &#x2F;&#x2F;int</span><br><span class="line">    object.put(&quot;int&quot;,2);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;boolean</span><br><span class="line">    object.put(&quot;boolean&quot;,true);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;array</span><br><span class="line">    List&lt;Integer&gt; integers &#x3D; Arrays.asList(1,2,3);</span><br><span class="line">    object.put(&quot;list&quot;,integers);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;null</span><br><span class="line">    object.put(&quot;null&quot;,null);</span><br><span class="line">    </span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">&#123;&quot;boolean&quot;:true,&quot;string&quot;:&quot;string&quot;,&quot;list&quot;:[1,2,3],&quot;int&quot;:2&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解析数据</span><br><span class="line">public void fun(JSONObject object)&#123;</span><br><span class="line">	&#x2F;&#x2F;string</span><br><span class="line">	String s &#x3D; object.getString(&quot;string&quot;);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;int</span><br><span class="line">	int i &#x3D; object.getIntValue(&quot;int&quot;);</span><br><span class="line">	System.out.println(i);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;boolean</span><br><span class="line">	boolean b &#x3D; object.getBooleanValue(&quot;boolean&quot;);</span><br><span class="line"> 	System.out.println(b);</span><br><span class="line"> 	</span><br><span class="line">  	&#x2F;&#x2F;list</span><br><span class="line">  	List&lt;Integer&gt; integers &#x3D; 		JSON.parseArray(object.getJSONArray(&quot;list&quot;).toJSONString(),Integer.class);</span><br><span class="line">  	integers.forEach(System.out::println);</span><br><span class="line">  	&#x2F;&#x2F;null</span><br><span class="line">  	System.out.println(object.getString(&quot;null&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java工具集</category>
      </categories>
  </entry>
  <entry>
    <title>Forward Proxy And Reverse Proxy(正向代理和反向代理)</title>
    <url>/2020/02/21/Forward-Proxy-And-Reverse-Proxy-%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="正向代理（forward-proxy）"><a href="#正向代理（forward-proxy）" class="headerlink" title="正向代理（forward proxy）"></a>正向代理（forward proxy）</h2><blockquote>
<p>是一个位于<strong>客户端和目标服务器之间</strong>的服务器（代理服务器），为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，代理服务器向目标服务器转交请求并将获得的内容返给客户端。</p>
</blockquote>
<blockquote>
<p>例子：如vpn科学上网、转发和重定向</p>
</blockquote>
<h3 id="过程：用户对国外网站的访问需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应返回给用户。"><a href="#过程：用户对国外网站的访问需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应返回给用户。" class="headerlink" title="过程：用户对国外网站的访问需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应返回给用户。"></a>过程：用户对国外网站的访问需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应返回给用户。</h3><ul>
<li>客户端无法直接访问WEB服务器，但是代理服务器可以访问。</li>
<li>代理server帮助client请求数据并缓存到本地，并将数据返回给client。</li>
</ul>
<h3 id="注释：client只需浏览器设置代理服务器ip和port即可，client知道代理服务器和WEB服务器的存在。所以，正向代理其实是“代理服务器”代理了“客户端”，去和“目标服务器”进行交互。目标服务器并不知道正真的client是谁。"><a href="#注释：client只需浏览器设置代理服务器ip和port即可，client知道代理服务器和WEB服务器的存在。所以，正向代理其实是“代理服务器”代理了“客户端”，去和“目标服务器”进行交互。目标服务器并不知道正真的client是谁。" class="headerlink" title="注释：client只需浏览器设置代理服务器ip和port即可，client知道代理服务器和WEB服务器的存在。所以，正向代理其实是“代理服务器”代理了“客户端”，去和“目标服务器”进行交互。目标服务器并不知道正真的client是谁。"></a>注释：client只需浏览器设置代理服务器ip和port即可，client知道代理服务器和WEB服务器的存在。所以，正向代理其实是“代理服务器”代理了“客户端”，去和“目标服务器”进行交互。目标服务器并不知道正真的client是谁。</h3><h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><ul>
<li>突破访问权限，如访问外网。</li>
<li>提高访问速度：代理服务器设置了较大的硬盘缓冲区，将部分请求的结果保存到缓冲区。</li>
<li>隐藏客户端的真实ip：client可通过这种方式隐藏自己的ip。</li>
</ul>
<h2 id="反向代理（reverse-proxy）：指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将返回结果返回给internet上请求连接的客户端，此时，作为客户端一方，代理服务器就像是替服务器端做代理服务，因此称为反向代理。"><a href="#反向代理（reverse-proxy）：指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将返回结果返回给internet上请求连接的客户端，此时，作为客户端一方，代理服务器就像是替服务器端做代理服务，因此称为反向代理。" class="headerlink" title="反向代理（reverse proxy）：指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将返回结果返回给internet上请求连接的客户端，此时，作为客户端一方，代理服务器就像是替服务器端做代理服务，因此称为反向代理。"></a>反向代理（reverse proxy）：指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将返回结果返回给internet上请求连接的客户端，此时，作为客户端一方，代理服务器就像是替服务器端做代理服务，因此称为反向代理。</h2><p>关键字：客户端、负载均衡服务器、服务器</p>
<ul>
<li>client访问WEB服务器，并不知道访问的服务器是代理服务器，client以为代理服务器就是WEB服务器。</li>
<li>代理服务器将WEB服务器的页面缓存到本地，当client访问时直接返回给client。<blockquote>
<p>注释：client浏览器不需要做任何设置，client访问代理server就等同于访问WEB server，client不知道真实WEB server的存在。</p>
</blockquote>
</li>
</ul>
<h3 id="反向代理的用途："><a href="#反向代理的用途：" class="headerlink" title="反向代理的用途："></a>反向代理的用途：</h3><ol>
<li>隐藏服务器的真实ip：可对client隐藏服务器的ip地址</li>
<li>负载均衡：根据所有真实服务器的负载情况，将请求分发到不同的服务器上</li>
<li>提高访问速度：反向代理服务器能够将部分静态资源和短时间大量访问的资源缓存到本地，以提高访问速度。</li>
<li>代理server可作为应用层防火墙，为网站提供对基于WEB的攻击行为的防护，还可以为后端服务器同意提供加密ssl加速，提供http访问认证等。</li>
</ol>
<h3 id="总结：正向代理和反向代理的区别："><a href="#总结：正向代理和反向代理的区别：" class="headerlink" title="总结：正向代理和反向代理的区别："></a>总结：正向代理和反向代理的区别：</h3><ol>
<li>正向代理是客户端的代理（帮助客户端访问无法访问的资源），而反向代理则是服务器的代理（帮助服务器端做负载均衡，安全防护）。</li>
<li>正向代理一般是客户端架设的，反向代理一般是服务器架设的。</li>
<li>正向代理中，服务器不知道正真的客户端到底是谁；而反向代理中，客户端不知道真正的服务器是谁。</li>
<li>正向代理用以解决访问限制问题；而反向代理用以提供负载均衡、安全防护等作用；二者均能提高访问速度。</li>
</ol>
]]></content>
      <tags>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Github上精确查找开源项目</title>
    <url>/2020/04/17/Github%E4%B8%8A%E7%B2%BE%E7%A1%AE%E6%9F%A5%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<img src="/2020/04/17/Github%E4%B8%8A%E7%B2%BE%E7%A1%AE%E6%9F%A5%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/a.png" style="zoom:50%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按照项目名&#x2F;仓库名搜索（大小写不敏感）</span><br><span class="line">in:name xxx</span><br><span class="line">#按照README搜索</span><br><span class="line">in:redame xxx</span><br><span class="line">#按照description搜索</span><br><span class="line">in:description xxx</span><br><span class="line">#stars数大于xxx</span><br><span class="line">stars:&gt;xxx</span><br><span class="line">#forks数大于xxx</span><br><span class="line">forks:&gt;xxx</span><br><span class="line">#编程语言限制</span><br><span class="line">language:xxx</span><br><span class="line">#最新更新时间晚于YYYY-MM-DD</span><br><span class="line">pushed:&gt;YYYY-MM-DD</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Github的使用手册</title>
    <url>/2020/02/12/Github%E7%9A%84%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="Git命令行操作"><a href="#Git命令行操作" class="headerlink" title="Git命令行操作"></a>Git命令行操作</h2><h3 id="本地库的操作"><a href="#本地库的操作" class="headerlink" title="本地库的操作"></a>本地库的操作</h3><h4 id="一、本地库的初始化（创建本地库）"><a href="#一、本地库的初始化（创建本地库）" class="headerlink" title="一、本地库的初始化（创建本地库）"></a>一、本地库的初始化（创建本地库）</h4><ol>
<li><p>在创建好的文件夹目录下执行 <code>git init</code>命令，系统自动生成<code>.git</code>文件夹</p>
</li>
<li><p>设置签名，有项目级别和系统级别的签名（作用：起到表示开发者信息的作用，与<code>github</code>账号没有关系）</p>
<blockquote>
<p>签名形式：<code>user.name</code>  <code>user.email</code></p>
<p>设置项目级别的签名：当前本地库有效，保存在<code>.git/config</code>中     </p>
<p><code>git config user.name [用户名]</code><br><code>git config user.email [邮箱]</code></p>
<p>设置系统级别的签名：当前登陆操作系统的用户范围有效保存在系统的家目录<code>~/gitconfig</code>中(通常只要设置系统级别的就够了)</p>
<p><code>git config --global user.name [用户名]</code><br><code>git config --global user.email [邮箱]</code><br>原则：就近原则，优先使用项目级别</p>
</blockquote>
</li>
</ol>
<h3 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><h4 id="添加、提交、查看状态"><a href="#添加、提交、查看状态" class="headerlink" title="添加、提交、查看状态"></a>添加、提交、查看状态</h4><ul>
<li><code>git status</code></li>
</ul>
<blockquote>
<p>作用：查看工作区和暂存区的状态</p>
<p>提示：</p>
<blockquote>
<p>On branch master（在master分支/主干）</p>
<p>No commits yet（本地库没有东西可提交）</p>
<p>Nothing to commit（暂存区没什么东西）</p>
</blockquote>
</blockquote>
<ul>
<li><code>git add</code></li>
</ul>
<blockquote>
<p>作用：添加到暂存区</p>
</blockquote>
<ul>
<li><code>git rm --cached &lt;file&gt;</code></li>
</ul>
<blockquote>
<p>作用：从暂存区中移除</p>
</blockquote>
<ul>
<li><code>git commit &lt;file&gt;</code></li>
</ul>
<blockquote>
<p>作用：提交暂存区到本地库（需要输入信息，记录本次提交干什么事）</p>
</blockquote>
<ul>
<li><p><code>git checkout -- &lt;file&gt;</code></p>
</li>
<li><p><code>git commit –a</code></p>
</li>
<li><p><code>git reset HEAD &lt;file&gt;</code></p>
</li>
<li><p><code>git commit -m &quot;commit message&quot; &lt;file&gt;</code></p>
</li>
</ul>
<blockquote>
<p>作用：-m “书写添加信息”</p>
</blockquote>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><ul>
<li><code>git log</code></li>
</ul>
<blockquote>
<p>作用：操作日志的显示</p>
</blockquote>
<ul>
<li><code>git log --pretty=oneline</code></li>
</ul>
<blockquote>
<p>作用：操作日志的简洁显示</p>
</blockquote>
<ul>
<li><code>git log –oneline</code></li>
</ul>
<blockquote>
<p>作用：操作日志的更加简洁显示</p>
</blockquote>
<ul>
<li><code>git reflog（常用）</code></li>
</ul>
<blockquote>
<p>作用：操作日志的带指针更加简洁显示</p>
</blockquote>
<h4 id="版本的前进与后退"><a href="#版本的前进与后退" class="headerlink" title="版本的前进与后退"></a>版本的前进与后退</h4><p><em>本质是head索引的变化</em></p>
<ul>
<li>基于索引值的方式</li>
</ul>
<blockquote>
<p>前进/后退：<code>git reset –hard [索引值]</code></p>
</blockquote>
<ul>
<li>后退一步</li>
</ul>
<blockquote>
<p><code>it reset –hard HEAD^</code></p>
</blockquote>
<ul>
<li>后退n步</li>
</ul>
<blockquote>
<p><code>git reset –hard HEAD~n</code></p>
</blockquote>
<h4 id="文件的删除和找回"><a href="#文件的删除和找回" class="headerlink" title="文件的删除和找回"></a>文件的删除和找回</h4><p>前提：已经commit到本地库中</p>
<p>还是通过<code>git reset –hard</code>命令回到某个版本</p>
<p>Hard参数会刷新工作区和暂存区</p>
<h4 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h4><ul>
<li><p><code>git diff [文件名]</code></p>
</li>
<li><p><code>git diff [版本号][文件名]</code></p>
</li>
</ul>
<h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><ul>
<li><p><code>git branch –v</code></p>
<blockquote>
<p>  查看分支</p>
</blockquote>
</li>
<li><p><code>git branch [new branch name]</code></p>
<blockquote>
<p> 创建新的分支</p>
</blockquote>
</li>
<li><p><code>git checkout [branch name]</code></p>
<blockquote>
<p>切换分支</p>
</blockquote>
</li>
<li><p>合并分支</p>
<blockquote>
<p>step1: 切换到被合并的分支上</p>
<p>step2: 合并分支</p>
<blockquote>
<p><code>git merge [需要合并的新的分支]</code></p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="冲突的解决"><a href="#冲突的解决" class="headerlink" title="冲突的解决"></a>冲突的解决</h4><p><em>问题原因：两个分支都修改了相同的文件提交到本地库，git不知道听谁的</em></p>
<ul>
<li><p>1：合并分支</p>
<blockquote>
<p><code>git merge [分支名]</code></p>
</blockquote>
</li>
<li><p>2：修改合并后产生冲突的文件</p>
<blockquote>
<p><code>vim</code></p>
</blockquote>
</li>
<li><p>3：<code>git add [文件名]</code></p>
</li>
<li><p>4：<code>git commit –m “日志”</code></p>
<blockquote>
<p>不需要带文件名</p>
</blockquote>
</li>
</ul>
<h4 id="创建远程github的别名"><a href="#创建远程github的别名" class="headerlink" title="创建远程github的别名"></a>创建远程github的别名</h4><blockquote>
<p>git remote add origin [github的http的url]</p>
<p>git remote –v</p>
<p>fetch（取回）</p>
<p>push（推送）</p>
<p>往<code>github</code>的仓库中推送</p>
<p>git push origin master</p>
<p>分别是别名+分支</p>
</blockquote>
<h4 id="从远程库clone到本地"><a href="#从远程库clone到本地" class="headerlink" title="从远程库clone到本地"></a>从远程库clone到本地</h4><p>git clone [url]</p>
<p>完整的把远程库下载到本地</p>
<p>创建origin别名</p>
<p>初始化本地库</p>
<h4 id="从远程库拉取"><a href="#从远程库拉取" class="headerlink" title="从远程库拉取"></a>从远程库拉取</h4><p>Pull=fetch+merge</p>
<p>法1：</p>
<p>Git pull [远程地址的别名] [远程地址的分支名]</p>
<p>法2：</p>
<p>Git fetch [远程地址的别名] [远程地址的分支名]（不需要登陆，把远程库的内容抓取到本地，本不会合并到本地库）</p>
<p>Git merge [远程地址的别名/远程地址的分支名]（合并远程库）</p>
<h4 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h4><p>Fork到远程库</p>
<p>Pull request到本地仓库</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>HUA-1-182-结构体数组</title>
    <url>/2020/03/02/HUA-1-182-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>输入学生人数n，然后构建一个结构体数组，结构体包含学号和学生成绩（都是int类型），然后输出成绩不及格（&lt;60）的学生的学号。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入n，接着输入n名学生的信息，主要是学号和成绩；</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出成绩不及格学生的学号，每个学号一行。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">121212 5</span><br><span class="line">121213 100</span><br><span class="line">121216 70</span><br><span class="line">121218 60</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">121212</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct stu&#123;</span><br><span class="line">  int id;</span><br><span class="line">  int grade;</span><br><span class="line">  stu(int id,int grade)&#123;</span><br><span class="line">    this-&gt;id &#x3D; id;</span><br><span class="line">    this-&gt;grade &#x3D; grade;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int n;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  int id,grade;</span><br><span class="line">  vector&lt;stu&gt; v;</span><br><span class="line">  while(n&gt;0)&#123;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;id,&amp;grade);</span><br><span class="line">    stu s(id,grade);</span><br><span class="line">    v.push_back(s);</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for(int i&#x3D;0;i&lt;v.size();i++)&#123;</span><br><span class="line">  	if(v[i].grade&lt;60)</span><br><span class="line">      printf(&quot;%d\n&quot;,v[i].id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师OJ刷题</category>
      </categories>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>HUA-1-183-链表操作</title>
    <url>/2020/03/02/HUA-1-183-%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>输入一串int类型的数字以-1结束输入，将读取的不重复的数字构建成链表。并按照指示删除指定数字的节点，最后将剩余的链表的数字依次输出。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入要求链表的输入用-1结束，将不重复的数字构建成链表，比如 1 2 1 2 5 6 4 -1 构建成的链表 1 2 5 6 4；</p>
<p>接着输入要删除的数字。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出删除指定数字后的链表，中间用空格隔开，最后一个数字有空格。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 5 4 6 -1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 5 6</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	node* next;</span><br><span class="line">	node() &#123;&#125;</span><br><span class="line">	node(int _data) :data(_data),next(0) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool is_exist(node* list1,int target) &#123;</span><br><span class="line">	node* temp &#x3D; list1;</span><br><span class="line">	if (!temp-&gt;next)</span><br><span class="line">		return false;</span><br><span class="line">	temp &#x3D; temp -&gt; next;</span><br><span class="line"></span><br><span class="line">	while (temp!&#x3D;0) &#123;</span><br><span class="line">		if (temp-&gt;data &#x3D;&#x3D; target)</span><br><span class="line">			return 1;</span><br><span class="line">		temp &#x3D; temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deletenode(node* list1,int n) &#123;</span><br><span class="line">	node* temp &#x3D; list1;</span><br><span class="line">	node* pre_delete &#x3D; temp;&#x2F;&#x2F;删除节点的前驱节点</span><br><span class="line">	if (!temp-&gt;next)</span><br><span class="line">		return;  </span><br><span class="line"></span><br><span class="line">	temp &#x3D; temp-&gt;next;</span><br><span class="line">	while (temp !&#x3D; 0) &#123;</span><br><span class="line">		if (temp-&gt;data &#x3D;&#x3D; n) &#123;</span><br><span class="line">			pre_delete-&gt;next &#x3D; temp-&gt;next;</span><br><span class="line">			delete(temp);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		pre_delete &#x3D; temp;</span><br><span class="line">		temp &#x3D; temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, delete_n;</span><br><span class="line">	node* p , * pre, * head;&#x2F;&#x2F;p为当前节点，pre表示当前节点的前驱节点，head为头节点</span><br><span class="line">	head &#x3D; new node(0);&#x2F;&#x2F;头节点不存储数据</span><br><span class="line">	pre &#x3D; head;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		if (n &#x3D;&#x3D; -1) </span><br><span class="line">			break;</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">		if (is_exist(head,n))</span><br><span class="line">			continue;</span><br><span class="line">		p &#x3D; new node(n);</span><br><span class="line">		pre-&gt;next &#x3D; p;</span><br><span class="line">		pre &#x3D; p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%d&quot;, &amp;delete_n);</span><br><span class="line">	deletenode(head,delete_n);</span><br><span class="line"></span><br><span class="line">	p &#x3D; head-&gt;next;</span><br><span class="line">	while (p!&#x3D;NULL) &#123;</span><br><span class="line">		printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">		p &#x3D; p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师OJ刷题</category>
      </categories>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>HUA_1-3 FJ的字符串</title>
    <url>/2020/02/27/HUA-1-3-FJ%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="FJ的字符串"><a href="#FJ的字符串" class="headerlink" title="FJ的字符串"></a>FJ的字符串</h3><p>Description：</p>
<p>FJ在沙盘上写了这样一些字符串：　　A1 = “A”　　A2 = “ABA”　　A3 = “ABACABA”　　A4 = “ABACABADABACABA”　　… …　　你能找出其中的规律并写所有的数列AN吗？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>仅有一个数：N ≤ 26。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABACABA</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;将字符串分为左中右，无非是添加第n个字母，原理有点像奥利奥</span><br><span class="line">int main() &#123;</span><br><span class="line">	&#x2F;&#x2F;大写字母A的ascii编码65，a是97</span><br><span class="line">	int n;</span><br><span class="line">	string left, out_s;</span><br><span class="line">	char c &#x3D; 65;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			out_s &#x3D; c;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		left &#x3D; out_s;</span><br><span class="line">		out_s +&#x3D; (c + i);</span><br><span class="line">		out_s.append(left);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%s\n&quot;,out_s.c_str());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师OJ刷题</category>
      </categories>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>HUA-1-5-Sine之舞</title>
    <url>/2020/02/29/HUA-1-5-Sine%E4%B9%8B%E8%88%9E/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。不妨设</p>
<p>An=sin(1–sin(2+sin(3–sin(4+…sin(n))…)</p>
<p>Sn=(…(A1+n)A2+n-1)A3+…+2)An+1</p>
<p>FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>仅有一个数：N&lt;201。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>我的解决方案用到了<code>stringstream</code>处理字符串的拼接，需要导入<code>sstream库</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	&#x2F;&#x2F;用于存储An</span><br><span class="line">	stack&lt;string&gt; stk;</span><br><span class="line">	stringstream s;</span><br><span class="line">	int n, m;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	string An, temp, Sn;</span><br><span class="line">	for (int i &#x3D; n;i &gt; 0;i--) &#123;</span><br><span class="line">		m &#x3D; i;</span><br><span class="line">		&#x2F;&#x2F;构造最内层</span><br><span class="line">		s.str(&quot;&quot;);</span><br><span class="line">		s &lt;&lt; &quot;sin(&quot; &lt;&lt; i &lt;&lt; &#39;)&#39;;</span><br><span class="line">		An &#x3D; s.str();</span><br><span class="line">		while (m &gt; 1) &#123;</span><br><span class="line">			s.str(&quot;&quot;);</span><br><span class="line">			m--;</span><br><span class="line">			&#x2F;&#x2F;奇数</span><br><span class="line">			if (m % 2) </span><br><span class="line">				s &lt;&lt; &quot;sin(&quot; &lt;&lt; m &lt;&lt; &#39;-&#39; &lt;&lt; An &lt;&lt; &#39;)&#39;;				</span><br><span class="line">			else </span><br><span class="line">				s &lt;&lt; &quot;sin(&quot; &lt;&lt; m &lt;&lt; &#39;+&#39; &lt;&lt; An &lt;&lt; &#39;)&#39;;							</span><br><span class="line">			An &#x3D; s.str();</span><br><span class="line">		&#125;</span><br><span class="line">		stk.push(An);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; n;i &gt; 0;i--) &#123;</span><br><span class="line">		s.str(&quot;&quot;);</span><br><span class="line">		temp &#x3D; stk.top();</span><br><span class="line">		stk.pop();</span><br><span class="line">		s &lt;&lt; Sn &lt;&lt; temp &lt;&lt; &quot;+&quot; &lt;&lt; i;</span><br><span class="line">		temp &#x3D; s.str();</span><br><span class="line">		if (stk.size() &gt; 0)</span><br><span class="line">			temp &#x3D; &#39;(&#39; + temp + &#39;)&#39;;</span><br><span class="line">		Sn &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%s\n&quot;, Sn.c_str());</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师OJ刷题</category>
      </categories>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>HUA-1-6-报时助手</title>
    <url>/2020/02/29/HUA-1-6-%E6%8A%A5%E6%97%B6%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定当前的时间，请用英文的读法将它读出来。</p>
<p>时间用时h和分m表示，在英文的读法中，读一个时间的方法是：</p>
<p>如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three o’clock”。</p>
<p>如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。</p>
<p>时和分的读法使用的是英文数字的读法，其中0~20读作：</p>
<p>0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen, 15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。</p>
<p>30读作thirty，40读作forty，50读作fifty。</p>
<p>对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。</p>
<p>按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出时间时刻的英文。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 15</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zero fifteen</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt;int, string&gt; t &#x3D; &#123; &#123;0,&quot;zero&quot;&#125;,&#123;1,&quot;one&quot;&#125;,&#123;2,&quot;two&quot;&#125;,&#123;3,&quot;three&quot;&#125;,&#123;4,&quot;four&quot;&#125;,&#123;5,&quot;five&quot;&#125;,&#123;6,&quot;six&quot;&#125;,&#123;7,&quot;seven&quot;&#125;,&#123;8,&quot;eight&quot;&#125;,&#123;9,&quot;nine&quot;&#125;,&#123;10,&quot;ten&quot;&#125;,&#123;11,&quot;eleven&quot;&#125;,&#123;12,&quot;twelve&quot;&#125;,&#123;13,&quot;thirteen&quot;&#125;,&#123;14,&quot;fourteen&quot;&#125;,&#123;15,&quot;fifteen&quot;&#125;,&#123;16,&quot;sixteen&quot;&#125;,&#123;17,&quot;seventeen&quot;&#125;,&#123;18,&quot;eighteen&quot;&#125;,&#123;19,&quot;nineteen&quot;&#125;,&#123;20,&quot;twenty&quot;&#125;,&#123;30,&quot;thirty&quot;&#125;,&#123;40,&quot;forty&quot;&#125;,&#123;50,&quot;fifty&quot;&#125;,&#123;60,&quot;sixty&quot;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int h, m;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;h, &amp;m);</span><br><span class="line">	map&lt;int, string&gt;::iterator it;</span><br><span class="line">	string hour, min;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;处理时</span><br><span class="line">	if (h &gt; 20) &#123;</span><br><span class="line">		it &#x3D; t.find(20);</span><br><span class="line">		hour &#x3D; it-&gt;second;</span><br><span class="line">		it &#x3D; t.find(h - 20);</span><br><span class="line">		hour &#x3D; hour + &#39; &#39; + it-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		it &#x3D; t.find(h);</span><br><span class="line">		hour &#x3D; it-&gt;second;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;处理分</span><br><span class="line">	if (m &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		printf(&quot;%s %s\n&quot;, hour.c_str(), &quot;o&#39;clock&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (m &lt;&#x3D; 20) &#123;</span><br><span class="line">			it &#x3D; t.find(m);</span><br><span class="line">			min &#x3D; it-&gt;second;</span><br><span class="line">			printf(&quot;%s %s\n&quot;, hour.c_str(), min.c_str());</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (m &gt; 20 &amp;&amp; m &lt;&#x3D; 30) &#123;</span><br><span class="line">			if (m &#x3D;&#x3D; 30) &#123;</span><br><span class="line">				printf(&quot;%s %s\n&quot;, hour.c_str(), &quot;thirty&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			it &#x3D; t.find(m - 20);</span><br><span class="line">			min &#x3D; &quot;twenty &quot; + it-&gt;second;</span><br><span class="line">			printf(&quot;%s %s\n&quot;, hour.c_str(), min.c_str());</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (m &gt; 30 &amp;&amp; m &lt;&#x3D; 40) &#123;</span><br><span class="line">			if (m &#x3D;&#x3D; 40) &#123;</span><br><span class="line">				printf(&quot;%s %s\n&quot;, hour.c_str(), &quot;forty&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			it &#x3D; t.find(m - 30);</span><br><span class="line">			min &#x3D; &quot;thirty &quot; + it-&gt;second;</span><br><span class="line">			printf(&quot;%s %s\n&quot;, hour.c_str(), min.c_str());</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (m &gt; 40 &amp;&amp; m &lt;&#x3D; 50) &#123;</span><br><span class="line">			if (m &#x3D;&#x3D; 50) &#123;</span><br><span class="line">				printf(&quot;%s %s\n&quot;, hour.c_str(), &quot;fifty&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">			it &#x3D; t.find(m - 40);</span><br><span class="line">			min &#x3D; &quot;forty &quot; + it-&gt;second;</span><br><span class="line">			printf(&quot;%s %s\n&quot;, hour.c_str(), min.c_str());</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			it &#x3D; t.find(m - 50);</span><br><span class="line">			min &#x3D; &quot;fifty &quot; + it-&gt;second;</span><br><span class="line">			printf(&quot;%s %s\n&quot;, hour.c_str(), min.c_str());</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师OJ刷题</category>
      </categories>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>HUA-1-9-龟兔赛跑预测</title>
    <url>/2020/03/03/HUA-1-9-%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E9%A2%84%E6%B5%8B/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>&emsp;&emsp;话说这个世界上有各种各样的兔子和乌龟，但是 研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔 子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以 上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。</p>
<p>然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1 米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找 到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt;=100;t&lt;=300;s&lt;=10;l&lt;=10000且为v1,v2的公倍数)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。　第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 5 5 2 20</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 5 5 1 20</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3"></a>Sample Input 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 5 5 3 20</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3"></a>Sample Output 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;乌龟一直爬，兔子跑一会，歇一会</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">  int v1, v2, t, s, l;</span><br><span class="line">	scanf(&quot;%d %d %d %d %d&quot;, &amp;v1, &amp;v2, &amp;t, &amp;s, &amp;l);</span><br><span class="line"></span><br><span class="line">	int time &#x3D; 0, lenOf2 &#x3D; 0,lenOfg &#x3D; 0;&#x2F;&#x2F;兔子所跑长度</span><br><span class="line">	&#x2F;&#x2F;领先tm，休息s秒</span><br><span class="line">	while (lenOf2 &lt; l&amp;&amp; lenOfg&lt;l) &#123;</span><br><span class="line">		lenOfg +&#x3D; v2;</span><br><span class="line">		lenOf2 +&#x3D; v1;</span><br><span class="line">		time++;</span><br><span class="line">		if (lenOf2&gt;&#x3D;l)</span><br><span class="line">			break;</span><br><span class="line">		</span><br><span class="line">		if (lenOf2 - lenOfg &gt;&#x3D; t) &#123;</span><br><span class="line">			if ((lenOfg+v2 * s)&gt;l) &#123;</span><br><span class="line">				int add &#x3D; (l - lenOfg) &#x2F; v2;</span><br><span class="line">				time +&#x3D; add;</span><br><span class="line">                lenOfg  &#x3D; l;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			time +&#x3D; s;</span><br><span class="line">			lenOfg +&#x3D; v2 * s;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (lenOfg &#x3D;&#x3D; lenOf2) &#123;</span><br><span class="line">		printf(&quot;D\n%d&quot;, time);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (lenOfg &gt; lenOf2) &#123;</span><br><span class="line">		printf(&quot;T\n%d&quot;, time);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		printf(&quot;R\n%d&quot;, time);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师OJ刷题</category>
      </categories>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客迁移</title>
    <url>/2020/09/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><ul>
<li>安装node.js</li>
<li>安装cmpn镜像源 <code>npm install -g cnpm --registery=https://registry.npm.taobao.org</code></li>
<li>安装hexo框架 <code>cnpm install -g hexo-cli</code>，并且利用<code>hexo -v</code>来验证</li>
</ul>
<h4 id="拷贝原始数据"><a href="#拷贝原始数据" class="headerlink" title="拷贝原始数据"></a>拷贝原始数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下是需要拷贝的文件和目录</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br></pre></td></tr></table></figure>

<h4 id="安装依赖模块"><a href="#安装依赖模块" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h4><p>执行下面的命令之前，需要把以上拷贝的文件复制到新电脑的博客文件夹下，如<code>/blog</code>下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<h4 id="构建、运行、发布"><a href="#构建、运行、发布" class="headerlink" title="构建、运行、发布"></a>构建、运行、发布</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d	# 要求填写github或其他发布平台的账号密码</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea中git的使用</title>
    <url>/2020/08/01/Idea%E4%B8%ADgit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>工作中多人使用<a href="http://lib.csdn.net/base/git" target="_blank" rel="noopener">版本控制</a>软件协作开发，常见的应用场景归纳如下：</p>
<p>假设小组中有两个人，组长小张，组员小袁</p>
<p>场景一：小张创建项目并提交到远程<a href="http://lib.csdn.net/base/git" target="_blank" rel="noopener">Git</a>仓库</p>
<p>场景二：小袁从远程<a href="http://lib.csdn.net/base/git" target="_blank" rel="noopener">Git</a>仓库上获取项目源码</p>
<p>场景三：小袁修改了部分源码，提交到远程仓库</p>
<p>场景四：小张从远程仓库获取小袁的提交</p>
<p>场景五：小袁接受了一个新功能的任务，创建了一个分支并在分支上开发</p>
<p>场景六：小袁把分支提交到远程Git仓库</p>
<p>场景七：小张获取小袁提交的分支</p>
<p>场景八：小张把分支合并到主干</p>
<h3 id="场景一：小张创建项目并提交到远程Git仓库"><a href="#场景一：小张创建项目并提交到远程Git仓库" class="headerlink" title="场景一：小张创建项目并提交到远程Git仓库"></a>场景一：小张创建项目并提交到远程Git仓库</h3><p>创建好项目，选择VCS - &gt; Import into Version Control -&gt; Create Git Repository</p>
<p><img src="http://img.blog.csdn.net/20160912161234797" alt="img"></p>
<p>接下来指定本地仓库的位置，按个人习惯指定即可，例如这里选择了项目源代码同目录</p>
<p><img src="http://img.blog.csdn.net/20160912161334752" alt="img"></p>
<p>点击OK后创建完成本地仓库，注意，这里仅仅是本地的。下面把项目源码添加到本地仓库。</p>
<p>下图是Git与提交有关的三个命令对应的操作，Add命令是把文件从IDE的工作目录添加到本地仓库的stage区，Commit命令把stage区的暂存文件提交到当前分支的仓库，并清空stage区。Push命令把本地仓库的提交同步到远程仓库。</p>
<p><img src="http://img.blog.csdn.net/20160912164147415" alt="img"></p>
<p>IDEA中对操作做了一定的简化，Commit和Push可以在一步中完成。</p>
<p>具体操作，在项目上点击右键，选择Git菜单</p>
<p><img src="http://img.blog.csdn.net/20160912165901032" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20160912165911954" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20160912165921938" alt="img"></p>
<p>因为是第一次提交，Push前需要指定远程仓库的地址。如下图，点击Define remote后，在弹出的窗口中输入远程仓库地址。</p>
<p><img src="http://img.blog.csdn.net/20160912165942829" alt="img"></p>
<h3 id="场景二：小袁从远程Git仓库上获取项目源码"><a href="#场景二：小袁从远程Git仓库上获取项目源码" class="headerlink" title="场景二：小袁从远程Git仓库上获取项目源码"></a>场景二：小袁从远程Git仓库上获取项目源码</h3><p>即克隆项目，操作如下：</p>
<p><img src="http://img.blog.csdn.net/20160912170148207" alt="img"></p>
<p>输入小张Push时填写的远程仓库地址</p>
<p><img src="http://img.blog.csdn.net/20160912170214880" alt="img"></p>
<p>接下来按向导操作，即可把项目从远程仓库克隆到本地仓库和IDE工作区。</p>
<h3 id="场景三：小袁修改了部分源码，提交到远程仓库"><a href="#场景三：小袁修改了部分源码，提交到远程仓库" class="headerlink" title="场景三：小袁修改了部分源码，提交到远程仓库"></a>场景三：小袁修改了部分源码，提交到远程仓库</h3><p>这个操作和首次提交的流程基本一致，分别是 Add -&gt; Commit -&gt; Push。请参考场景一</p>
<h3 id="场景四：小张从远程仓库获取小袁的提交"><a href="#场景四：小张从远程仓库获取小袁的提交" class="headerlink" title="场景四：小张从远程仓库获取小袁的提交"></a>场景四：小张从远程仓库获取小袁的提交</h3><p>获取更新有两个命令：Fetch和Pull，Fetch是从远程仓库下载文件到本地的origin/master，然后可以手动对比修改决定是否合并到本地的master库。Pull则是直接下载并合并。如果各成员在工作中都执行修改前先更新的规范，则可以直接使用Pull方式以简化操作。</p>
<p><img src="http://img.blog.csdn.net/20160912170628933" alt="img"></p>
<h3 id="场景五：小袁接受了一个新功能的任务，创建了一个分支并在分支上开发"><a href="#场景五：小袁接受了一个新功能的任务，创建了一个分支并在分支上开发" class="headerlink" title="场景五：小袁接受了一个新功能的任务，创建了一个分支并在分支上开发"></a>场景五：小袁接受了一个新功能的任务，创建了一个分支并在分支上开发</h3><p>建分支也是一个常用的操作，例如临时修改bug、开发不确定是否加入的功能等，都可以创建一个分支，再等待合适的时机合并到主干。</p>
<p>创建流程如下：</p>
<p><img src="http://img.blog.csdn.net/20160912171844429" alt="img"></p>
<p>选择New Branch并输入一个分支的名称</p>
<p><img src="http://img.blog.csdn.net/20160912171858663" alt="img"></p>
<p>创建完成后注意IDEA的右下角，如下图，Git: wangpangzi_branch表示已经自动切换到wangpangzi_branch分支，当前工作在这个分支上。</p>
<p>点击后弹出一个小窗口，在Local Branches中有其他可用的本地分支选项，点击后选择Checkout即可切换当前工作的分支(见场景7操作切换其他分支)。</p>
<p><img src="http://img.blog.csdn.net/20160912173123122" alt="img"></p>
<p>如下图，点击Checkout</p>
<p><img src="http://img.blog.csdn.net/20160912173307202" alt="img"></p>
<p>注意，这里创建的分支仅仅在本地仓库，如果想让组长小张获取到这个分支，还需要提交到远程仓库。</p>
<h3 id="场景六：小袁把分支提交到远程Git仓库"><a href="#场景六：小袁把分支提交到远程Git仓库" class="headerlink" title="场景六：小袁把分支提交到远程Git仓库"></a>场景六：小袁把分支提交到远程Git仓库</h3><p>切换到新建的分支，使用Push功能</p>
<p><img src="http://img.blog.csdn.net/20160912173718844" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20160912174243815" alt="img"></p>
<h3 id="场景七：小张获取小袁提交的分支"><a href="#场景七：小张获取小袁提交的分支" class="headerlink" title="场景七：小张获取小袁提交的分支"></a>场景七：小张获取小袁提交的分支</h3><p>使用Pull功能打开更新窗口，点击Remote栏后面的刷新按钮，会在Branches to merge栏中刷新出新的分支。这里并不想做合并，所以不要选中任何分支，直接点击Pull按钮完成操作。</p>
<p><img src="http://img.blog.csdn.net/20160912174329143" alt="img"></p>
<p>更新后，再点击右下角，可以看到在Remote Branches区已经有了新的分支，点击后在弹出的子菜单中选择Checkout as new local branch，在本地仓库中创建该分支。完成后在Local Branches区也会出现该分支的选项，可以按上面的方法，点击后选择Checkout切换。</p>
<p><img src="http://img.blog.csdn.net/20160912174729488" alt="img"></p>
<h3 id="场景八：小张把分支合并到主干"><a href="#场景八：小张把分支合并到主干" class="headerlink" title="场景八：小张把分支合并到主干"></a>场景八：小张把分支合并到主干</h3><p>新功能开发完成，体验很好，项目组决定把该功能合并到主干上。</p>
<p>切换到master分支，选择Merge Changes</p>
<p><img src="http://img.blog.csdn.net/20160912175201306" alt="img"></p>
<p>选择要合并的分支，点击Merge完成</p>
<p><img src="http://img.blog.csdn.net/20160912175359903" alt="img"></p>
]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb编程之Cookie</title>
    <url>/2020/02/21/JavaWeb%E7%BC%96%E7%A8%8B%E4%B9%8BCookie/</url>
    <content><![CDATA[<h1 id="JavaWeb编程之Cookie"><a href="#JavaWeb编程之Cookie" class="headerlink" title="JavaWeb编程之Cookie"></a>JavaWeb编程之Cookie</h1><h2 id="一般cookie存储的信息"><a href="#一般cookie存储的信息" class="headerlink" title="一般cookie存储的信息"></a>一般cookie存储的信息</h2><ol>
<li>保存用户的登陆信息</li>
<li>创建购物车</li>
<li>跟踪用户的行为</li>
</ol>
<p>##cookie格式与常见属性</p>
<ol>
<li>每条cookie都以key-value的形式。</li>
<li>key和value都必须是URL编码。<blockquote>
<p>ps:URL编码是一种浏览器用来打包表单输入格式的。<br>编码规则：</p>
<blockquote>
<ol>
<li>每对key-value由 &amp;; 符分隔</li>
<li>每对来自表单的key-value由=分隔</li>
<li>若用户没有输入值给这个key，那么次key在cookie中依旧存在，但与其相对应的value值不存在</li>
<li>任何特殊的字符，将以百分号%用十六进制编码–如汉字的url编码，胡的ASCII码是-17670，十六进制是BAFA，url编码是%BA%FA</li>
</ol>
</blockquote>
</blockquote>
</li>
<li>两对cookie间以分号和空格分隔</li>
</ol>
<h2 id="cookie的缺点"><a href="#cookie的缺点" class="headerlink" title="cookie的缺点"></a>cookie的缺点</h2><ol>
<li><p>安全性</p>
<blockquote>
<p>由于cookie在http中是明文传递的，其中所存储的数据可以被他人访问，可能会被篡改、盗用。</p>
</blockquote>
</li>
<li><p>可存储内容大小限制</p>
<blockquote>
<p>cookie的大小限制在4kb左右，不适合做大量存储。</p>
</blockquote>
</li>
<li><p>增加流量</p>
<blockquote>
<p>cookie每次请求都会被自动添加到request header请求头中，无形中增加了流量，cookie信息量越大，对服务器请求时间越长。</p>
</blockquote>
</li>
</ol>
<h2 id="附加知识-不同编码中英文所占字节大小"><a href="#附加知识-不同编码中英文所占字节大小" class="headerlink" title="附加知识-不同编码中英文所占字节大小"></a>附加知识-不同编码中英文所占字节大小</h2><blockquote>
<p>字节(Byte):字节是通过网络传输信息（或在硬盘/内存中存储信息）的单位；1Byte = 8bit。</p>
</blockquote>
<ol>
<li>ASCII码：一个英文字母为1Byte，一个中文汉字为2Byte；包括英文和中文的标点符号。</li>
<li>Unicode：一个英文字符占2Byte，一个中文为占2Byte（含繁体）。</li>
<li>UTF-8：一个英文字符占1Byte，一个中文汉字占3Byte（含繁体）。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之反射</title>
    <url>/2020/02/21/Java%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="Java之反射"><a href="#Java之反射" class="headerlink" title="Java之反射"></a>Java之反射</h1><blockquote>
<p>反射的基本思路</p>
<blockquote>
<p>Step1：获得目的类的class字节码对象。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Step2：通过getConstructor()获得构造器的方式获得构造器对象。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Step3：通过构造器类的方法newInstance()获得所反射的对象。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>NOTE:通过反射可以获得<strong>成员变量（属性）</strong>、<strong>成员方法</strong>、<strong>构造方法</strong></p>
</blockquote>
</blockquote>
<h2 id="如何获取class字节码对象-三种方式"><a href="#如何获取class字节码对象-三种方式" class="headerlink" title="如何获取class字节码对象(三种方式)"></a>如何获取class字节码对象(三种方式)</h2><blockquote>
<blockquote>
<p>方式一：通过对象获取</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p &#x3D; new Person(); </span><br><span class="line">Class clazz &#x3D; p.getClass();</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>方式二：类名获取</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Person.class;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>方式三：Class类的静态方法获取</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class clazz &#x3D; Class.forName(&quot;类的全包名&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p><strong>Ps：拿到的class字节码对象具有唯一性。</strong></p>
</blockquote>
</blockquote>
<h2 id="反射获得构造方法"><a href="#反射获得构造方法" class="headerlink" title="反射获得构造方法"></a>反射获得构造方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获得字节码对象</span><br><span class="line">Class clazz &#x3D; Class.forName(&quot;类的全包名&quot;);</span><br><span class="line">&#x2F;&#x2F;获得所有公共构造方法(除私有),返回值为构造方法对象数组</span><br><span class="line">Constructor[] cons &#x3D; clazz.getConstructors();</span><br><span class="line">&#x2F;&#x2F;获得所有构造方法(包括私有)</span><br><span class="line">Constructor[] cons &#x3D; clazz.getDeclaredConstructors();  </span><br><span class="line">&#x2F;&#x2F;获得指定空参构造方法</span><br><span class="line">Constructor con &#x3D; clazz.getConstructor(); </span><br><span class="line">&#x2F;&#x2F;获得指定有参构造方法</span><br><span class="line">Constructor con &#x3D; clazz.getConstructor(String.class,int.class); </span><br><span class="line">&#x2F;&#x2F;获得指定有参构造方法(包括私有)</span><br><span class="line">Constructor con &#x3D; clazz.getDeclaredConstructor(String.class,int.class); </span><br><span class="line">&#x2F;&#x2F;运行时期，取消java的权限检查——暴力反射</span><br><span class="line">con.setAccessible(true);</span><br><span class="line">&#x2F;&#x2F;通过构造方法实例化对象</span><br><span class="line">Object obj&#x3D;con.newInstance();</span><br><span class="line">Object obj&#x3D;con.newInstance(&quot;你好&quot;，22);</span><br></pre></td></tr></table></figure>

<h2 id="反射获取到成员变量和成员方法"><a href="#反射获取到成员变量和成员方法" class="headerlink" title="反射获取到成员变量和成员方法"></a>反射获取到成员变量和成员方法</h2><blockquote>
<blockquote>
<p>NOTE:反射的泛型擦除原理：java是伪泛型，编译后的class文件是没有泛型的，可利用反射绕开泛型。</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获得字节码对象</span><br><span class="line">Class clazz &#x3D; Class.forName(&quot;类的全包名&quot;);</span><br><span class="line">&#x2F;&#x2F;通过字节码对象的newInstance()方法创建实例对象——调用的是空参构造。</span><br><span class="line">Object obj &#x3D; clazz.newInstance();</span><br><span class="line">&#x2F;&#x2F;反射获得成员变量：</span><br><span class="line">Class clazz &#x3D; Class.forName(&quot;类的全包名&quot;);</span><br><span class="line">&#x2F;&#x2F;获得所有公共的成员变量</span><br><span class="line">Field[] fields &#x3D; clazz.getFields();</span><br><span class="line">&#x2F;&#x2F;获得所有成员变量(包括私有)</span><br><span class="line">Field[] fields &#x3D; clazz.getDeclaredFields();</span><br><span class="line">&#x2F;&#x2F;获取指定成员变量名</span><br><span class="line">Field field &#x3D; clazz.getField(&quot;成员变量名&quot;);</span><br><span class="line">&#x2F;&#x2F;设置该对象的某个字段的值</span><br><span class="line">Field.set(obj,value);</span><br><span class="line">&#x2F;&#x2F;获取所有公共成员方法，包括继承</span><br><span class="line">Methods[] methods &#x3D; clazz.getMethods();</span><br><span class="line">Methods method &#x3D; clazz.getMethod(&quot;方法名&quot;，可变参数的class字节码文件，可空参);</span><br><span class="line">&#x2F;&#x2F;同样执行方法也需要对象的支持</span><br><span class="line">method.invoke(obj,参数);</span><br></pre></td></tr></table></figure>

<h2 id="反射的常用方法"><a href="#反射的常用方法" class="headerlink" title="反射的常用方法"></a>反射的常用方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;返回表示声明该Field字段对象的类或接口的Class字节码对象。</span><br><span class="line">java.lang.reflect.Field.getDeclaringClass()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断调用的a字节码对象是否与参数b字节码对象相等或为其父类或接口</span><br><span class="line">java.lang.Class.isAssignableFrom()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取类的所有字段，包括私有字段</span><br><span class="line">java.lang.Class.getDeclaredFields()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回指定对象上由Field表示的字段的值</span><br><span class="line">java.lang.reflect.Field.get()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>HUA_1-4 Huffuman树</title>
    <url>/2020/02/27/HUA-1-4-Huffuman%E6%A0%91/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。</p>
<p>给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下：</p>
<ol>
<li><p>找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。</p>
</li>
<li><p>重复步骤1，直到{pi}中只剩下一个数。</p>
</li>
</ol>
<p>在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。</p>
<p>本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。</p>
<p>例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：</p>
<ol>
<li><p>找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。</p>
</li>
<li><p>找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。</p>
</li>
<li><p>找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。</p>
</li>
<li><p>找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。</p>
</li>
<li><p>现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。</p>
</li>
</ol>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含一个正整数n（n&lt;=100）。接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出用这些数构造Huffman树的总费用。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5 3 8 2 9</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">59</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; node;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int n,num,new_node1,new_node2,total&#x3D;0;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">    node.push(num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  while(node.size()&gt;1)&#123;</span><br><span class="line">	&#x2F;&#x2F;获取堆顶做小的节点</span><br><span class="line">    new_node1 &#x3D; node.top();</span><br><span class="line">    node.pop();</span><br><span class="line">    new_node2 &#x3D; node.top();</span><br><span class="line">    node.pop();</span><br><span class="line">    </span><br><span class="line">    total&#x3D;total+new_node1+new_node2;</span><br><span class="line">    node.push(new_node1+new_node2);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  printf(&quot;%d&quot;,total);</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>华师OJ刷题</category>
      </categories>
      <tags>
        <tag>ECNU_OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Java文件的读写</title>
    <url>/2020/02/21/Java%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h2 id="字节输入输出流复制文件"><a href="#字节输入输出流复制文件" class="headerlink" title="字节输入输出流复制文件"></a>字节输入输出流复制文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    long s &#x3D; System.currentTimeMillis();</span><br><span class="line">    FileInputStream fis &#x3D; null;</span><br><span class="line">    FileOutputStream fos &#x3D; null;</span><br><span class="line">    try&#123;</span><br><span class="line">        fis &#x3D; new FileInputStream(&quot;c:\\t.zip&quot;);</span><br><span class="line">        fos &#x3D; new FileOutputStream(&quot;d:\\t.zip&quot;);</span><br><span class="line">        &#x2F;&#x2F;定义字节数组,缓冲</span><br><span class="line">        byte[] bytes &#x3D; new byte[1024*10];</span><br><span class="line">        &#x2F;&#x2F;读取数组,写入数组</span><br><span class="line">        int len &#x3D; 0 ; </span><br><span class="line">		while((len &#x3D; fis.read(bytes))!&#x3D;-1)&#123;</span><br><span class="line">			fos.write(bytes, 0, len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;catch(IOException ex)&#123;</span><br><span class="line">		System.out.println(ex);</span><br><span class="line">		throw new RuntimeException(&quot;文件复制失败&quot;);</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			if(fos!&#x3D;null)</span><br><span class="line">				fos.close();</span><br><span class="line">		&#125;catch(IOException ex)&#123;</span><br><span class="line">			throw new RuntimeException(&quot;释放资源失败&quot;);</span><br><span class="line">		&#125;finally&#123;</span><br><span class="line">			try&#123;</span><br><span class="line">				if(fis!&#x3D;null)</span><br><span class="line">					fis.close();</span><br><span class="line">			&#125;catch(IOException ex)&#123;</span><br><span class="line">				throw new RuntimeException(&quot;释放资源失败&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="buffered缓冲流高效文件复制代码"><a href="#buffered缓冲流高效文件复制代码" class="headerlink" title="buffered缓冲流高效文件复制代码"></a>buffered缓冲流高效文件复制代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void copy_4(File src,File desc)throws IOException&#123;</span><br><span class="line">	BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(src));</span><br><span class="line">	BufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(desc));</span><br><span class="line">	int len &#x3D; 0 ;</span><br><span class="line">	byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">	while((len &#x3D; bis.read(bytes))!&#x3D;-1)&#123;</span><br><span class="line">		bos.write(bytes,0,len);</span><br><span class="line">	&#125;</span><br><span class="line">	bos.close();</span><br><span class="line">	bis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-120-三角形最小路径和</title>
    <url>/2020/04/01/LeetCode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自底向上，每个dp[i][j]为当前位置的最小路径和</span><br><span class="line">&#x2F;&#x2F;时间复杂度O(N!)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N*N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        int n &#x3D; triangle.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));</span><br><span class="line">        &#x2F;&#x2F;边界初始化</span><br><span class="line">        for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">            dp[n - 1][i] &#x3D; triangle[n - 1][i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;自底向上，dp[i][j]意思是过第i层j列点的最短路径</span><br><span class="line">        for (int i &#x3D; n - 2;i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line">            for (int j &#x3D; 0;j &lt;&#x3D; i;j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;转移方程，dp[i][j]等于下一层相邻两个的最小值再加上该点的值</span><br><span class="line">                dp[i][j] &#x3D; min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11-盛水最多的容器</title>
    <url>/2020/05/06/LeetCode-11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
 <img src="/2020/05/06/LeetCode-11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/question_11.jpg" style="zoom:50%;">



<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 </p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxArea(vector&lt;int&gt;&amp; height) &#123;</span><br><span class="line">        int i &#x3D; 0, j &#x3D; height.size() - 1, res &#x3D; 0;</span><br><span class="line">        while(i &lt; j)&#123;</span><br><span class="line">            int h &#x3D; min(height[i], height[j]);</span><br><span class="line">            res &#x3D; max(res, h * (j - i));</span><br><span class="line">            &#x2F;&#x2F;让指针移动后的容器面积增大，就要使移动后的容器的高尽量大</span><br><span class="line">            if(height[i] &lt; height[j])</span><br><span class="line">                ++i;</span><br><span class="line">            else </span><br><span class="line">                --j;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-130-被围绕的区域</title>
    <url>/2020/03/26/LeetCode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>


<p>解释:</p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：</span><br><span class="line">&#x2F;&#x2F;step1:先对边缘上的O做dfs，找出与其相连的所有O，并将他们全部改为V(Visited)</span><br><span class="line">&#x2F;&#x2F;step2:遍历二维数组，遇到O就改为X,遇到V就改回O</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</span><br><span class="line">        if(board.empty())return;</span><br><span class="line">        int i,j,row &#x3D; board.size(),col&#x3D;board[0].size();</span><br><span class="line">        &#x2F;&#x2F;对边缘的0做dfs,将其改为V(visited)</span><br><span class="line">        for(i&#x3D;0;i&lt;row;i++)&#123;</span><br><span class="line">            DFS_EDG(i,0,board);</span><br><span class="line">            DFS_EDG(i,col-1,board);</span><br><span class="line">        &#125;</span><br><span class="line">        for(j&#x3D;0;j&lt;col;j++)&#123;</span><br><span class="line">            DFS_EDG(0,j,board);</span><br><span class="line">            DFS_EDG(row-1,j,board);</span><br><span class="line">        &#125;</span><br><span class="line">        for(i&#x3D;0;i&lt;row;i++)&#123;</span><br><span class="line">            for(j&#x3D;0;j&lt;col;j++)&#123;</span><br><span class="line">                if(board[i][j]&#x3D;&#x3D;&#39;O&#39;)board[i][j]&#x3D;&#39;X&#39;;</span><br><span class="line">                if(board[i][j]&#x3D;&#x3D;&#39;V&#39;)board[i][j]&#x3D;&#39;O&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void DFS_EDG(int row,int col,vector&lt;vector&lt;char&gt; &gt;&amp; board)&#123;</span><br><span class="line">        &#x2F;&#x2F;边界判断</span><br><span class="line">        if(row&gt;&#x3D;0&amp;&amp;row&lt;board.size()&amp;&amp;col&gt;&#x3D;0&amp;&amp;col&lt;board[0].size()&amp;&amp;board[row][col]&#x3D;&#x3D;&#39;O&#39;)&#123;</span><br><span class="line">            board[row][col]&#x3D;&#39;V&#39;;</span><br><span class="line">            &#x2F;&#x2F;上下左右四个方向去dfs</span><br><span class="line">            DFS_EDG(row-1,col,board);</span><br><span class="line">            DFS_EDG(row+1,col,board);</span><br><span class="line">            DFS_EDG(row,col-1,board);</span><br><span class="line">            DFS_EDG(row,col+1,board);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-198-打家劫舍</title>
    <url>/2020/04/07/LeetCode-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N)</span><br><span class="line">&#x2F;&#x2F;时间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        if(len&lt;&#x3D;1)</span><br><span class="line">            return len&#x3D;&#x3D;0? 0:nums[0];</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; dp(len,0);</span><br><span class="line">        dp[0]&#x3D;nums[0];</span><br><span class="line">        dp[1]&#x3D;max(nums[0],nums[1]);</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;2;i&lt;len;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;转移方程，dp[i]为dp[i-1]与dp[i-2]+nums[i]的较大值</span><br><span class="line">            dp[i]&#x3D;max(dp[i-1],nums[i]+dp[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-139-单词拆分</title>
    <url>/2020/04/15/LeetCode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(NxM)字符串的长度x字典中的单词数量</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">        int len &#x3D; s.size(),wordcounts &#x3D; wordDict.size();</span><br><span class="line">        vector&lt;bool&gt; dp(len+1,false);</span><br><span class="line">        dp[0]&#x3D;true;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;len;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;遍历字典，每次比较i位置往前推字典中单词的长度，并判断回退到的那个位置是否为true</span><br><span class="line">            for(int j&#x3D;0;j&lt;wordcounts;j++)&#123;</span><br><span class="line">                int wordlen &#x3D; wordDict[j].size();</span><br><span class="line">                &#x2F;&#x2F;只有字典的单词长度小于等于匹配单词长度</span><br><span class="line">                if(i-wordlen&gt;&#x3D;0)&#123;</span><br><span class="line">                    string temp &#x3D; s.substr(i-wordlen,wordlen);</span><br><span class="line">                    if(wordDict[j]&#x3D;&#x3D;temp.c_str()&amp;&amp;dp[i-wordlen])&#123;</span><br><span class="line">                        dp[i]&#x3D;true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-20-有效的括号</title>
    <url>/2020/05/06/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>


<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>


<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        stack&lt;char&gt; stk;</span><br><span class="line">        bool res &#x3D;true;</span><br><span class="line">        int len &#x3D; s.size(),idx&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;字符串长度为奇数时直接返回false</span><br><span class="line">        &#x2F;&#x2F;空字符串处理</span><br><span class="line">        if(len&#x3D;&#x3D;0)</span><br><span class="line">            return res;</span><br><span class="line">        stk.push(s[idx]);</span><br><span class="line">        &#x2F;&#x2F;结束条件：括号全部删除，栈清空；或已经没有可用的字符了</span><br><span class="line">        while(++idx&lt;len)&#123;</span><br><span class="line">            &#x2F;&#x2F;判断左括号还是有括号</span><br><span class="line">            if(s[idx]&#x3D;&#x3D;&#39;(&#39;||s[idx]&#x3D;&#x3D;&#39;[&#39;||s[idx]&#x3D;&#x3D;&#39;&#123;&#39;)</span><br><span class="line">                stk.push(s[idx]);</span><br><span class="line">            else&#123;</span><br><span class="line">                if(stk.empty())&#123;</span><br><span class="line">                    res &#x3D; false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    &#x2F;&#x2F;匹配对应的括号</span><br><span class="line">                    char c &#x3D; stk.top();</span><br><span class="line">                    if(match(c,s[idx]))</span><br><span class="line">                        stk.pop();</span><br><span class="line">                    else&#123;</span><br><span class="line">                        res &#x3D; false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">        if(!stk.empty())</span><br><span class="line">            res&#x3D;false;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;匹配函数</span><br><span class="line">    bool match(char top,char c)&#123;</span><br><span class="line">        if((top&#x3D;&#x3D;&#39;(&#39;&amp;&amp;c&#x3D;&#x3D;&#39;)&#39;)||(top&#x3D;&#x3D;&#39;[&#39;&amp;&amp;c&#x3D;&#x3D;&#39;]&#39;)||(top&#x3D;&#x3D;&#39;&#123;&#39;&amp;&amp;c&#x3D;&#x3D;&#39;&#125;&#39;))</span><br><span class="line">            return true;      </span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-213-打家劫舍II</title>
    <url>/2020/04/08/LeetCode-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</url>
    <content><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度:O(N)</span><br><span class="line">&#x2F;&#x2F;空间复杂度：O(2N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 第一次求nums[0]...nums[n-2],第二次求nums[1]...nums[n-1],两次中的最大值即为结果。</span><br><span class="line"> * 在第一次求解中，如果nums[0]取了，那么nums[n-1]不可取，这个时候我们还需要求出nums[0]不取，nums[n-1]取的情况，所以求解第二次。</span><br><span class="line"> * 如果在第一次求解中，如果nums[0]不取，那么nums[n-1]可取，这个时候第一次求解是第二次求解的子集。</span><br><span class="line"> * 即(nums[0]...nums[n-2])与(nums[1]...nums[n-2])的结果是一样的</span><br><span class="line"> * 所以通过两次求解即可得出结果。</span><br><span class="line"> *&#x2F;</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        vector&lt;int&gt; dp1(len,0);</span><br><span class="line">        vector&lt;int&gt; dp2(len,0);</span><br><span class="line">        if(len&lt;&#x3D;1)</span><br><span class="line">            return len&#x3D;&#x3D;0?0:nums[0];</span><br><span class="line">        </span><br><span class="line">        dp1[1]&#x3D;nums[0];</span><br><span class="line">        dp2[1]&#x3D;nums[1];</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;2;i&lt;len;i++)&#123;</span><br><span class="line">            dp1[i]&#x3D;max(dp1[i-1],dp1[i-2]+nums[i-1]);</span><br><span class="line">            dp2[i]&#x3D;max(dp2[i-1],dp2[i-2]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return max(dp1[len-1],dp2[len-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-200-岛屿数量</title>
    <url>/2020/03/25/LeetCode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：遍历二维数组，遇到为1的就利用dfs向四周扩散，将该岛沉没，并将岛数量加1</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        int i,j;</span><br><span class="line">        &#x2F;&#x2F;从左至右，从上到下遍历数组</span><br><span class="line">        for(i&#x3D;0;i&lt;grid.size();i++)&#123;</span><br><span class="line">            for(j&#x3D;0;j&lt;grid[0].size();j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;遇到1就沉没这个小岛，计数+1</span><br><span class="line">                if(grid[i][j]&#x3D;&#x3D;&#39;1&#39;)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    &#x2F;&#x2F;递归的沉没小岛</span><br><span class="line">                    DFS(i,j,grid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int row,int col,vector&lt;vector&lt;char&gt;&gt;&amp; grid)&#123;</span><br><span class="line">        if(row&lt;0||row&gt;&#x3D;grid.size()||col&lt;0||col&gt;&#x3D;grid[row].size()||grid[row][col]&#x3D;&#x3D;&#39;0&#39;)</span><br><span class="line">            return;</span><br><span class="line">        &#x2F;&#x2F;沉没</span><br><span class="line">        grid[row][col]&#x3D;&#39;0&#39;;</span><br><span class="line">        &#x2F;&#x2F;上</span><br><span class="line">        DFS(row-1,col,grid);</span><br><span class="line">        &#x2F;&#x2F;下</span><br><span class="line">        DFS(row+1,col,grid);</span><br><span class="line">        &#x2F;&#x2F;左</span><br><span class="line">        DFS(row,col-1,grid);</span><br><span class="line">        &#x2F;&#x2F;右</span><br><span class="line">        DFS(row,col+1,grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-131-分割回文串</title>
    <url>/2020/03/14/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：利用DFS回溯，每次获取符合回文的字符串，加入到数组中，继续操作剩下的字符串</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;</span><br><span class="line">        if(s.length()&#x3D;&#x3D;0)return res;</span><br><span class="line">        vector&lt;string&gt; _res;</span><br><span class="line">        DFS(s,s.length(),_res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;回溯</span><br><span class="line">    void DFS(string str,int length,vector&lt;string&gt; _res)&#123;</span><br><span class="line">            if (length &lt;&#x3D; 0) &#123;</span><br><span class="line">                res.push_back(_res);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; 1;i &lt;&#x3D; length;i++) &#123;</span><br><span class="line">                string temp &#x3D; str.substr(0, i);</span><br><span class="line">                if(isPalindrome(temp,temp.length()))&#123;</span><br><span class="line">                    _res.push_back(temp);</span><br><span class="line">                    DFS(str.substr(i, length - i), length - i, _res);</span><br><span class="line">                    &#x2F;&#x2F;每次都得把前一次的回文串移除</span><br><span class="line">                    &#x2F;&#x2F;整个for循环只寻找当前层可能存在的回文串，找到并处理完当前回文的回溯逻辑需要</span><br><span class="line">                    &#x2F;&#x2F;删除，这样不会对同层下一次的迭代造成干扰</span><br><span class="line">                    _res.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断回文</span><br><span class="line">    bool isPalindrome(string s,int length)&#123;</span><br><span class="line">        if(length &#x3D;&#x3D;1)</span><br><span class="line">            return true;</span><br><span class="line">        for (int j &#x3D; 0;j &lt; length &#x2F; 2;j++) &#123;</span><br><span class="line">            if (s[j] !&#x3D; s[length- 1 - j])</span><br><span class="line">                  return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-215-数组中的第k个最大的元素</title>
    <url>/2020/05/14/LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;利用优先队列容器，注意c++中，优先队列默认是大顶堆</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; pq;&#x2F;&#x2F;优先队列</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            pq.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int res&#x3D;0;</span><br><span class="line">        while(k--&gt;0)&#123;</span><br><span class="line">            res &#x3D; pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode-230-二叉搜索树中第K小的元素</title>
    <url>/2020/03/10/LeetCode-230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p>
<p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>进阶：<br>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;迭代版思路：利用栈模拟树的中序遍历</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;        </span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        int n&#x3D;0;</span><br><span class="line">        TreeNode* cur&#x3D;root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        while(cur || !stk.empty())&#123;</span><br><span class="line">            if(cur)&#123;</span><br><span class="line">                stk.push(cur);</span><br><span class="line">                cur&#x3D;cur-&gt;left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur&#x3D;stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                n++;</span><br><span class="line">                if(n&#x3D;&#x3D;k)</span><br><span class="line">                    return cur-&gt;val;</span><br><span class="line">                cur&#x3D;cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;递归版：全局变量计数，二叉树中序遍历</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int count,res;</span><br><span class="line"></span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        inOrder(root,k);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void inOrder(TreeNode* root, int k)&#123;</span><br><span class="line">        if(!root)return;</span><br><span class="line">        inOrder(root-&gt;left,k);</span><br><span class="line">        count++;</span><br><span class="line">        if(count&#x3D;&#x3D;k)&#123;</span><br><span class="line">            res &#x3D; root-&gt;val;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-279-完全平方数</title>
    <url>/2020/04/04/LeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N*SQRT(N))</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n+1,0x7fffffff);</span><br><span class="line">        dp[0]&#x3D;0;</span><br><span class="line">        dp[1]&#x3D;1;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j*j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">                dp[i]&#x3D;min(dp[i],dp[i-j*j]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-216-组合总和III</title>
    <url>/2020/03/20/LeetCode-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</url>
    <content><![CDATA[<p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong><em>k\</em></strong> 个数的组合<strong><em>。\</em></strong>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        DFS(1,n,k,temp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int start,int sum,int k,vector&lt;int&gt;&amp; temp)&#123;</span><br><span class="line">        if(k&#x3D;&#x3D;0&amp;&amp;sum&#x3D;&#x3D;0)&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;start;i&lt;10;i++)&#123;</span><br><span class="line">            if(sum-i&gt;&#x3D;0)&#123;</span><br><span class="line">                temp.push_back(i);</span><br><span class="line">                DFS(i+1,sum-i,k-1,temp);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;else</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-242-有效的字母异位词</title>
    <url>/2020/05/22/LeetCode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>


<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>说明:<br>你可以假设字符串只包含小写字母。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if(s.size()!&#x3D;t.size())</span><br><span class="line">            return false;</span><br><span class="line">        &#x2F;&#x2F;用来记录字符出现的次数</span><br><span class="line">        int count[26]&#x3D;&#123;0&#125;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;s.size();i++)&#123;</span><br><span class="line">            count[s[i]-97]++;</span><br><span class="line">            count[t[i]-97]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;26;i++)&#123;</span><br><span class="line">            if(count[i]!&#x3D;0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>顺序存储</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-322-零钱兑换</title>
    <url>/2020/04/12/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>解释: 11 = 5 + 5 + 1<br>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间O(N*M)</span><br><span class="line">&#x2F;&#x2F;空间O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">    	&#x2F;&#x2F;初始化赋为最大值</span><br><span class="line">        vector&lt;int&gt; dp(amount + 1, 0x7fffffff);</span><br><span class="line">        dp[0] &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1;i &lt;&#x3D; amount;i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0;j &lt; coins.size();j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;每次去除减去币值后小于0的，原先dp[i]不存在的</span><br><span class="line">                if (i - coins[j] &gt;&#x3D; 0&amp;&amp; dp[i - coins[j]]!&#x3D; 0x7fffffff) &#123;</span><br><span class="line">                    dp[i] &#x3D; min(dp[i], dp[i - coins[j]] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount]&#x3D;&#x3D; 0x7fffffff? -1: dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-337-打家劫舍III</title>
    <url>/2020/04/09/LeetCode-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/</url>
    <content><![CDATA[<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>示例 1:</p>
<pre><code>输入: [3,2,3,null,3,null,1]
     3
    / \
   2   3
    \   \ 
     3   1   
输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</code></pre><p>示例 2:</p>
<pre><code>输入: [3,4,5,1,3,null,1]
     3
    / \
   4   5
  / \   \ 
 1   3   1
输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</code></pre><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;我们可以先不管这个否是二叉树,我们发现,如果我们选了 cur 这个节点 那么就说明 我们不能选它的所有子节点(还有父节点)。</span><br><span class="line">&#x2F;&#x2F;对于每一个节点，都只有选和不选两种情况。我们每次考虑一棵子树，那么根只有两种情况，选和不选(我们让dp[0]表示不选,dp[1]表示选)。</span><br><span class="line">&#x2F;&#x2F;对于选择了根,那么我们就不能选它的儿子了</span><br><span class="line">&#x2F;&#x2F;如果没有选根，我们就可以任意选了(即选最大的那一个)</span><br><span class="line">&#x2F;&#x2F;然后我们做一次dfs即可</span><br><span class="line">&#x2F;&#x2F;时间复杂度O(N)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        if(!root)return 0;</span><br><span class="line">        &#x2F;&#x2F;后根遍历，树形dp</span><br><span class="line">        vector&lt;int&gt; res &#x3D; postOrder(root); </span><br><span class="line">        return max(res[0],res[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;后续递归遍历二叉树</span><br><span class="line">    vector&lt;int&gt; postOrder(TreeNode* root)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;0)return vector&lt;int&gt;(2,0);</span><br><span class="line">        vector&lt;int&gt; l &#x3D; postOrder(root-&gt;left);</span><br><span class="line">        vector&lt;int&gt; r &#x3D; postOrder(root-&gt;right);</span><br><span class="line">        vector&lt;int&gt; res(2,0);</span><br><span class="line">        &#x2F;&#x2F;0位置存放不含根的最大值，1位置存放含根的最大值</span><br><span class="line">        res[0]&#x3D;max(l[0],l[1])+max(r[0],r[1]);&#x2F;&#x2F;分别为左右子树的最大值和</span><br><span class="line">        res[1]&#x3D;l[0]+r[0]+root-&gt;val;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-343-整数拆分</title>
    <url>/2020/04/03/LeetCode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</span><br></pre></td></tr></table></figure>


<p>说明: 你可以假设 n 不小于 2 且不大于 58。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N!)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int integerBreak(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1, 1);</span><br><span class="line">        &#x2F;&#x2F;有题目可知n&gt;&#x3D;2,dp[2]&#x3D;1,dp[3]&#x3D;2</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1;j &lt; i;j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;dp[i]的取值由两部分决定</span><br><span class="line">                &#x2F;&#x2F;part1：拆分出来的j与dp[i-j]的最大值</span><br><span class="line">                &#x2F;&#x2F;part2：拆分出两数的积</span><br><span class="line">                dp[i] &#x3D; max(dp[i], dp[i - j] * j);</span><br><span class="line">                dp[i] &#x3D; max(dp[i], (i - j) * j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-377-组合总数IV</title>
    <url>/2020/04/13/LeetCode-377-%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0IV/</url>
    <content><![CDATA[<p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br><span class="line"></span><br><span class="line">因此输出为 7。</span><br></pre></td></tr></table></figure>

<p>进阶：</p>
<ul>
<li>如果给定的数组中含有负数会怎么样？</li>
<li>问题会产生什么变化？</li>
<li>我们需要在题目中添加什么限制来允许负数的出现？</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N*M),N为target的大小</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int len &#x3D; nums.size();</span><br><span class="line">        if(len&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;dp[i]表示数i在nums数组中存在的组合方案</span><br><span class="line">        &#x2F;&#x2F;int 10^9</span><br><span class="line">        &#x2F;&#x2F;unsigned long 10^9</span><br><span class="line">        &#x2F;&#x2F;long long 10^18</span><br><span class="line">        vector&lt;unsigned long&gt; dp(target+1,0);</span><br><span class="line">        &#x2F;&#x2F;0位置表示当最终由数target减为0时，存在一种组合方案</span><br><span class="line">        dp[0]&#x3D;1;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;target;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;len;j++)&#123;</span><br><span class="line">                if(nums[j]&lt;&#x3D;i)</span><br><span class="line">                    dp[i]+&#x3D;dp[i-nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-39-组合总和</title>
    <url>/2020/03/18/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;time:O(N^2)</span><br><span class="line">&#x2F;&#x2F;space:O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        DFS(0,0,target,temp,candidates);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int index,int sum,int target,vector&lt;int&gt;&amp; temp,vector&lt;int&gt;&amp; candidates)&#123;</span><br><span class="line">        if(sum&#x3D;&#x3D;target)&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">		&#x2F;&#x2F;由于数字可以重复使用，所以递归到下一层时，起点仍从当前index开始</span><br><span class="line">        for(int i&#x3D;index;i&lt;candidates.size();i++)&#123;</span><br><span class="line">            if(sum+candidates[i]&lt;&#x3D;target)&#123;</span><br><span class="line">                temp.push_back(candidates[i]);</span><br><span class="line">                &#x2F;&#x2F;从index节点出发，与后面的数字进行组合</span><br><span class="line">                DFS(i,sum+candidates[i],target,temp,candidates);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;关于此类问题的回溯模板</span><br><span class="line">DFS(nums,ans,temp,sum,target,start)&#123;</span><br><span class="line">	if(sum&#x3D;&#x3D;target)&#123;</span><br><span class="line">		ans.push_back(temp);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;start;i&lt;nums.size();i++)&#123;</span><br><span class="line">		temp.push_back(nums[i]);</span><br><span class="line">		DFS(nums,ans,temp,sum+nums[i],target,start+1);</span><br><span class="line">		temp.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-392-判断子序列</title>
    <url>/2020/04/21/LeetCode-392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 true.</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;axc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line"></span><br><span class="line">返回 false.</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N),N为子序列的长度</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N*M)),substr函数的空间复杂度</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubsequence(string s, string t) &#123;</span><br><span class="line">        bool res&#x3D;true;</span><br><span class="line">        int idx&#x3D;0;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;s.size();i++)&#123;</span><br><span class="line">            idx &#x3D; t.find(s[i]);</span><br><span class="line">            if(idx&lt;0)&#123;</span><br><span class="line">                res&#x3D;false;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;每次基于已找到的剩余子串开始找</span><br><span class="line">                t &#x3D; t.substr(idx+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-40-组合总和II</title>
    <url>/2020/03/19/LeetCode-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;time:O(2^n)</span><br><span class="line">&#x2F;&#x2F;space:O(kn)</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        DFS(0,0,target,temp,candidates);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int index,int sum,int target,vector&lt;int&gt;&amp; temp,vector&lt;int&gt;&amp; candidates)&#123;</span><br><span class="line">        if(sum&#x3D;&#x3D;target)&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;index;i&lt;candidates.size();i++)&#123;</span><br><span class="line">            if(sum+candidates[i]&lt;&#x3D;target)&#123;</span><br><span class="line">                &#x2F;&#x2F;同一层出现相同元素，只使用第一个，这样可以避免出现重复项，前提需要先对candidates排好序</span><br><span class="line">                if(i&gt;index&amp;&amp;candidates[i]&#x3D;&#x3D;candidates[i-1])</span><br><span class="line">                    continue;</span><br><span class="line">                temp.push_back(candidates[i]);</span><br><span class="line">                &#x2F;&#x2F;从index节点出发，与后面的数字进行组合</span><br><span class="line">                DFS(i+1,sum+candidates[i],target,temp,candidates);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-41-缺失的第一个正数</title>
    <url>/2020/05/21/LeetCode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(nlogn)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int res&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;先排序</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;因为是最小的正整数</span><br><span class="line">            &#x2F;&#x2F;遇到nums存在，则+1</span><br><span class="line">            &#x2F;&#x2F;遇到比res大，则直接返回</span><br><span class="line">            if(nums[i]&#x3D;&#x3D;res)</span><br><span class="line">                res++;</span><br><span class="line">            else if(nums[i]&gt;res)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode-401-二进制手表</title>
    <url>/2020/03/23/LeetCode-401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</url>
    <content><![CDATA[<p>二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。</p>
<p>每个 LED 代表一个 0 或 1，最低位在右侧。</p>
<img src="/2020/03/23/LeetCode-401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/Binary_clock_samui_moon.jpg" style="zoom:50%;">

<p>例如，上面的二进制手表读取 “3:25”。</p>
<p>给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。</p>
<p>案例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;time complexity O(2^n)</span><br><span class="line">&#x2F;&#x2F;space complexity(kn)</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; readBinaryWatch(int num) &#123;</span><br><span class="line">        vector&lt;int&gt; bitList &#x3D; &#123; 1,2,4,8,1,2,4,8,16,32 &#125;;</span><br><span class="line">        &#x2F;&#x2F;0位置存储时，1位置存储分</span><br><span class="line">        vector&lt;int&gt; record(2, 0);</span><br><span class="line">        DFS(num, 0, bitList, record);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int num, int start, vector&lt;int&gt;&amp; bitList, vector&lt;int&gt;&amp; record) &#123;</span><br><span class="line">        if (num &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;注意小时部分超过11，或者分钟部分超过59要剪枝</span><br><span class="line">            if (record[0] &gt; 11 || record[1] &gt; 59)</span><br><span class="line">                return;</span><br><span class="line">            &#x2F;&#x2F;c++11 to_string将数字转为字符形式</span><br><span class="line">            res.push_back(to_string(record[0]) + &quot;:&quot; + (record[1] &lt; 10 ? &quot;0&quot; + to_string(record[1]) : to_string(record[1])));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; start;i &lt; bitList.size();i++) &#123;</span><br><span class="line">            if (i &lt;&#x3D; 3)</span><br><span class="line">                record[0] +&#x3D; bitList[i];</span><br><span class="line">            else</span><br><span class="line">                record[1] +&#x3D; bitList[i];</span><br><span class="line">            DFS(num - 1, i + 1, bitList, record);</span><br><span class="line">            if (i &lt;&#x3D; 3)</span><br><span class="line">                record[0] -&#x3D; bitList[i];</span><br><span class="line">            else</span><br><span class="line">                record[1] -&#x3D; bitList[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-46-全排列</title>
    <url>/2020/03/15/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;有两种思路：</span><br><span class="line">&#x2F;&#x2F;1.每个位置可以放的数</span><br><span class="line">&#x2F;&#x2F;2.枚举当前数可放哪些位置</span><br><span class="line">&#x2F;&#x2F;实践复杂度O(N^2)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O（N）</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; cs;</span><br><span class="line">        </span><br><span class="line">        int length &#x3D; nums.size();</span><br><span class="line">        if (length&#x3D;&#x3D;0|| length&#x3D;&#x3D;1) &#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;访问标记位,解决每次从数组中复制新数组，复杂度保持不变</span><br><span class="line">        int *visited &#x3D; new int[length];</span><br><span class="line">        for (int i &#x3D; 0;i &lt; length;i++) </span><br><span class="line">            visited[i] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        DFS(nums, nums.size(), cs, visited);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(vector&lt;int&gt;&amp; nums,int length,vector&lt;int&gt;&amp; cs,int* visited)&#123;</span><br><span class="line">        if (length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            res.push_back(cs);</span><br><span class="line">            return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0;i &lt; nums.size();i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;迭代过程中查看是否以访问</span><br><span class="line">            if (!visited[i]) &#123;</span><br><span class="line">                cs.push_back(nums[i]);</span><br><span class="line">                visited[i] &#x3D; 1;</span><br><span class="line">                &#x2F;&#x2F;继续递归</span><br><span class="line">                DFS(nums, length - 1, cs, visited);</span><br><span class="line">                &#x2F;&#x2F;注意清空之前操作的数，避免对同层造成影响</span><br><span class="line">                visited[i] &#x3D; 0;</span><br><span class="line">                cs.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-417-太平洋大西洋水流问题</title>
    <url>/2020/03/27/LeetCode-417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p>
<p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p>
<p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p>
<p>提示：</p>
<p>输出坐标的顺序不重要<br>m 和 n 都小于150</p>
<p>示例：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：分别利用两个二维数组，分别标记从各自的边缘通过dfs能够逆流到的位置</span><br><span class="line">&#x2F;&#x2F;最后对比两个表，相交的点就是所求坐标</span><br><span class="line">&#x2F;&#x2F;time complexity:O(2^n)</span><br><span class="line">&#x2F;&#x2F;space complexity:O(2nxm)</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if(matrix.empty())return res;</span><br><span class="line">        int row&#x3D;matrix.size(),col&#x3D;matrix[0].size(),i,j;</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; pacifics(row, vector&lt;bool&gt;(col, 0));&#x2F;&#x2F;能到太平洋的坐标</span><br><span class="line">        vector&lt;vector&lt;bool&gt;&gt; atlantics(row, vector&lt;bool&gt;(col, 0));&#x2F;&#x2F;能到大西洋的坐标</span><br><span class="line">        &#x2F;&#x2F;逆向思维，从太平洋大西洋的边缘进入，</span><br><span class="line">        for(int i &#x3D; 0; i &lt; row; i++)&#123;</span><br><span class="line">            DFS(matrix, i, 0, matrix[i][0], pacifics);</span><br><span class="line">            DFS(matrix, i, col-1, matrix[i][col-1], atlantics);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; col; j++)&#123;</span><br><span class="line">            DFS(matrix, 0, j, matrix[0][j], pacifics);</span><br><span class="line">            DFS(matrix, row-1, j, matrix[row-1][j], atlantics);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 既能 touch pacific 又能 touch atlantic 的 grid 放进结果中</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; row; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; col; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;若该点两大洋重合，则加入res</span><br><span class="line">                if (pacifics[i][j] &amp;&amp; atlantics[i][j]) &#123;</span><br><span class="line">                    res.push_back(&#123; i, j &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 逆流而上， 标记能流到的地方</span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt; &amp; matrix, int i, int j, int pre, vector&lt;vector&lt;bool&gt;&gt; &amp; ocean)&#123;</span><br><span class="line">        &#x2F;&#x2F;边缘检测，直接返回</span><br><span class="line">        if(i &lt; 0 || j &lt; 0 || i &gt;&#x3D; matrix.size() || j &gt;&#x3D; matrix[0].size()) return;</span><br><span class="line">        &#x2F;&#x2F;已经流经过</span><br><span class="line">        if(ocean[i][j]) return;</span><br><span class="line">        &#x2F;&#x2F;因为是逆向，所以是&lt;就返回</span><br><span class="line">        if(matrix[i][j] &lt; pre) return;</span><br><span class="line">        ocean[i][j] &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;四个方向递归</span><br><span class="line">        DFS(matrix, i+1, j, matrix[i][j], ocean);</span><br><span class="line">        DFS(matrix, i-1, j, matrix[i][j], ocean);</span><br><span class="line">        DFS(matrix, i, j+1, matrix[i][j], ocean);</span><br><span class="line">        DFS(matrix, i, j-1, matrix[i][j], ocean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-51-N皇后</title>
    <url>/2020/03/28/LeetCode-51-N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="/2020/03/28/LeetCode-51-N%E7%9A%87%E5%90%8E/8-queens.png" alt></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(!n)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(n)用于申请的记录每行选取位置的数组nums</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; temp;</span><br><span class="line">        &#x2F;&#x2F;开辟n大小的数组，初始化为-1</span><br><span class="line">        &#x2F;&#x2F;用于申请的记录每行选取位置的数组nums</span><br><span class="line">        vector&lt;int&gt; nums(n, -1);</span><br><span class="line">        DFS(0, n, temp, nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int deepth,int n,vector&lt;string&gt;&amp; temp,vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">    	&#x2F;&#x2F;递归终止条件</span><br><span class="line">        if(deepth&#x3D;&#x3D;n)&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;初始化长度为n的.字符串</span><br><span class="line">        string s(n,&#39;.&#39;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            s[i]&#x3D;&#39;Q&#39;;</span><br><span class="line">            temp.push_back(s);</span><br><span class="line">            &#x2F;&#x2F;判断是否可以放置皇后</span><br><span class="line">            if(isValid(deepth,i,nums))&#123;</span><br><span class="line">                nums[deepth] &#x3D; i;</span><br><span class="line">                &#x2F;&#x2F;带着当前的结果去下一层找</span><br><span class="line">                DFS(deepth+1,n,temp,nums);</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[deepth] !&#x3D; -1)</span><br><span class="line">                nums[deepth] &#x3D; -1;</span><br><span class="line">            s[i]&#x3D;&#39;.&#39;;</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;判断位置是否可用</span><br><span class="line">    bool isValid(int row, int col, vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;检测当前列是否用过</span><br><span class="line">        for (int i &#x3D; 0;i &lt; nums.size();i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;第i行已经用过col列或row,col处于i行皇后的对角线位置</span><br><span class="line">            if (nums[i] &#x3D;&#x3D; col || (nums[i] !&#x3D; -1&amp;&amp;abs(row - i) &#x3D;&#x3D; abs(col - nums[i])))</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-47-全排列II</title>
    <url>/2020/03/16/LeetCode-47-%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Time O(n!+logN)</span><br><span class="line">&#x2F;&#x2F;Space O(n+n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;每个数可以出现的位置</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;bool&gt; used(nums.size(),false);</span><br><span class="line">        vector&lt;int&gt; cs(nums.size());</span><br><span class="line">        DFS(0,0,nums,cs,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;index为cs数组中的位置</span><br><span class="line">    void DFS(int index,int start,vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; cs,vector&lt;bool&gt;&amp; used)&#123;</span><br><span class="line">        if(index&#x3D;&#x3D;cs.size())&#123;</span><br><span class="line">            res.push_back(cs);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;枚举当前数可以放在哪些位置</span><br><span class="line">        for(int i&#x3D;start;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(!used[i])&#123;</span><br><span class="line">                used[i]&#x3D;true;</span><br><span class="line">                cs[i] &#x3D; nums[index];</span><br><span class="line">                &#x2F;&#x2F;若后一个数与前一个数相同，则后一个数只能放到该数的后面</span><br><span class="line">                if(index+1&lt;nums.size()&amp;&amp;nums[index+1]&#x3D;&#x3D;nums[index])</span><br><span class="line">                    DFS(index+1,i+1,nums,cs,used);</span><br><span class="line">                else</span><br><span class="line">                    DFS(index+1,0,nums,cs,used);</span><br><span class="line">                used[i]&#x3D;false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-52-N皇后II</title>
    <url>/2020/03/29/LeetCode-52-N%E7%9A%87%E5%90%8EII/</url>
    <content><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="/2020/03/29/LeetCode-52-N%E7%9A%87%E5%90%8EII/8-queens.png" alt></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 4 皇后问题存在如下两个不同的解法。</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">&#x2F;&#x2F;时间复杂度：O(n^2)</span><br><span class="line">&#x2F;&#x2F;空间复杂度：O(N) 标记数组</span><br><span class="line">public:</span><br><span class="line">    int totalNQueens(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;标记数组，索引表示行，值表示列</span><br><span class="line">        vector&lt;int&gt; nums(n,-1);</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        DFS(0,n,nums,count);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int deepth,int n,vector&lt;int&gt;&amp; nums,int&amp; count)&#123;</span><br><span class="line">        if(deepth&#x3D;&#x3D;n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F;检测第i列是否合法</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            if(valid(deepth,i,nums))&#123;</span><br><span class="line">                nums[deepth]&#x3D;i;</span><br><span class="line">                DFS(deepth+1,n,nums,count);</span><br><span class="line">                nums[deepth]&#x3D;-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool valid(int row,int col,vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.size();i++)</span><br><span class="line">            &#x2F;&#x2F;判断是否同列或在对角线</span><br><span class="line">            if(col&#x3D;&#x3D;nums[i]||(nums[i]&gt;&#x3D;0&amp;&amp;abs(row-i)&#x3D;&#x3D;abs(col-nums[i])))</span><br><span class="line">                return false;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-560-和为k的子数组</title>
    <url>/2020/05/15/LeetCode-560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int len &#x3D; nums.size(), count &#x3D; 0,sum,i,j;</span><br><span class="line">        for(i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">            sum&#x3D;0;</span><br><span class="line">            for(j&#x3D;i;j&lt;len;j++)&#123;</span><br><span class="line">                sum+&#x3D;nums[j];</span><br><span class="line">                if(sum&#x3D;&#x3D;k)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode-62-不同路径</title>
    <url>/2020/04/06/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/2020/04/06/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/robot_maze.png" alt></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>1 &lt;= m, n &lt;= 100</li>
<li>题目数据保证答案小于等于 2 * 10 ^ 9</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(NxM)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(NxM)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0));</span><br><span class="line">        int i,j;</span><br><span class="line">        for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">            &#x2F;&#x2F;初始化边缘为1</span><br><span class="line">                dp[0][i]&#x3D;1;</span><br><span class="line">        </span><br><span class="line">        for(j&#x3D;0;j&lt;m;j++)</span><br><span class="line">                dp[j][0]&#x3D;1;</span><br><span class="line">        </span><br><span class="line">        for(i&#x3D;1;i&lt;m;i++)&#123;</span><br><span class="line">            for(j&#x3D;1;j&lt;n;j++)&#123;</span><br><span class="line">            	&#x2F;&#x2F;每个位置的路径数等于其左边路径数+上边路径数</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-63-不同路径II</title>
    <url>/2020/04/06/LeetCode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="/2020/04/06/LeetCode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/robot_maze.png" alt></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(NxM)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(NxM)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        &#x2F;&#x2F;关于如何处理障碍物:到达障碍物的路径是0</span><br><span class="line">        int row &#x3D; obstacleGrid.size(),col&#x3D;obstacleGrid[0].size(),i,j;</span><br><span class="line">        &#x2F;&#x2F;数可能会超过int型</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(row,vector&lt;long long&gt;(col,0));</span><br><span class="line"></span><br><span class="line">        for(i&#x3D;0;i&lt;col;i++)</span><br><span class="line">            &#x2F;&#x2F;初始化边缘，一直右走，非障碍物则初始化为1，直到遇到障碍物则break</span><br><span class="line">            if(obstacleGrid[0][i]!&#x3D;1)</span><br><span class="line">                dp[0][i]&#x3D;1;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        for(j&#x3D;0;j&lt;row;j++)&#123;</span><br><span class="line">            if(obstacleGrid[j][0]!&#x3D;1)</span><br><span class="line">                dp[j][0]&#x3D;1;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(i&#x3D;1;i&lt;row;i++)&#123;</span><br><span class="line">            for(j&#x3D;1;j&lt;col;j++)&#123;</span><br><span class="line">                if(obstacleGrid[i][j]&#x3D;&#x3D;1)</span><br><span class="line">                    continue;  </span><br><span class="line">                &#x2F;&#x2F;结果为左上的和</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[row-1][col-1];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-64-最小路径和</title>
    <url>/2020/04/02/LeetCode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(NxM)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(NxM)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int row,col,i,j;</span><br><span class="line">        row &#x3D; grid.size();</span><br><span class="line">        col &#x3D; grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(row,vector&lt;int&gt;(col,0));</span><br><span class="line">        dp[0][0]&#x3D;grid[0][0];</span><br><span class="line">        &#x2F;&#x2F;dp初始化边缘</span><br><span class="line">        for(i&#x3D;1;i&lt;col;i++)</span><br><span class="line">            dp[0][i]&#x3D;dp[0][i-1]+grid[0][i];</span><br><span class="line">        &#x2F;&#x2F;dp初始化边缘</span><br><span class="line">        for(j&#x3D;1;j&lt;row;j++)</span><br><span class="line">            dp[j][0]&#x3D;dp[j-1][0]+grid[j][0];</span><br><span class="line"></span><br><span class="line">        for(i&#x3D;1;i&lt;row;i++)&#123;</span><br><span class="line">            for(j&#x3D;1;j&lt;col;j++)&#123;</span><br><span class="line">                &#x2F;&#x2F;d[i][j]的值为上方或左侧中较小的dp值加当前点的值</span><br><span class="line">                dp[i][j]&#x3D;min(dp[i][j-1],dp[i-1][j])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[row-1][col-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-7-整数反转</title>
    <url>/2020/05/07/LeetCode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>


<p> 示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>


<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>


<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N),N为数的长度</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int reverse(int x) &#123;</span><br><span class="line">        long res &#x3D; 0;  </span><br><span class="line">        &#x2F;&#x2F;负数的情况不需要单独考虑</span><br><span class="line">        do &#123;</span><br><span class="line">            int num &#x3D; x % 10;</span><br><span class="line">            res &#x3D; res * 10 + num;</span><br><span class="line">            x &#x2F;&#x3D; 10;</span><br><span class="line">        &#125; while (x);</span><br><span class="line">        &#x2F;&#x2F;将结果强转为int型与原数进行比较，判断 是否有丢失</span><br><span class="line">        return (int)res!&#x3D;res?0:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>进制转化</tag>
        <tag>数的反转</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-77-组合</title>
    <url>/2020/03/17/LeetCode-77-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;time:O(n!)</span><br><span class="line">&#x2F;&#x2F;space:O(k)</span><br><span class="line">class Solution &#123;   </span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        &#x2F;&#x2F;数字从1开始</span><br><span class="line">        DFS(1,res,temp,k,n);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void DFS(int index,vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; temp,int k,int n)&#123;</span><br><span class="line">        &#x2F;&#x2F;k表示剩下几位需要填充数字</span><br><span class="line">        if (k &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;观察都为升序1-2、1-3、1-4这种，2-1这种被剪枝了，最小就从i开始</span><br><span class="line">        for (int i &#x3D; index;i &lt;&#x3D; n;i++) &#123;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            DFS(i + 1, res, temp, k - 1, n);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-70-爬楼梯</title>
    <url>/2020/03/31/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 思路：当前台阶的跳法总数&#x3D;当前台阶后退一阶的台阶的跳法总数+当前台阶后退二阶的台阶的跳法总数</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;注意n&#x3D;1的情况，数组越界</span><br><span class="line">        vector&lt;int&gt; dp;</span><br><span class="line">        dp.push_back(0);&#x2F;&#x2F;初始化</span><br><span class="line">        dp.push_back(1);</span><br><span class="line">        dp.push_back(2);</span><br><span class="line"></span><br><span class="line">        int temp;</span><br><span class="line">        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        	&#x2F;&#x2F;转移方程dp[i]&#x3D;dp[i-1]+dp[i-2]</span><br><span class="line">            temp&#x3D;dp[i-1]+dp[i-2];</span><br><span class="line">            dp.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-78-子集</title>
    <url>/2020/03/22/LeetCode-78-%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;time O(2^n)</span><br><span class="line">&#x2F;&#x2F;space O(kn)</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        res.push_back(temp);&#x2F;&#x2F;先将空集放入数组</span><br><span class="line">        </span><br><span class="line">        if(nums.empty())           </span><br><span class="line">            return res;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据子集的长度递增的方式依次回溯求出</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;nums.size();i++)</span><br><span class="line">            DFS(i,0,nums,temp);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;参数</span><br><span class="line">    &#x2F;&#x2F;集合长度</span><br><span class="line">    void DFS(int length ,int start ,vector&lt;int&gt;&amp; nums ,vector&lt;int&gt;&amp; temp)&#123;</span><br><span class="line">        if(length&#x3D;&#x3D;0)&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;start;i&lt;nums.size();i++)&#123;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            DFS(length-1,i+1,nums,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-90-子集II</title>
    <url>/2020/03/22/LeetCode-90-%E5%AD%90%E9%9B%86II/</url>
    <content><![CDATA[<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意理解去重的思路</span><br><span class="line">&#x2F;&#x2F;time O(2^n)</span><br><span class="line">&#x2F;&#x2F;space O(kn)</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;与无相同元素的区别：</span><br><span class="line">    &#x2F;&#x2F;添加了排序，并在同层使用第一个</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;int&gt; temp;</span><br><span class="line">        res.push_back(temp);&#x2F;&#x2F;先将空集放入数组</span><br><span class="line">        </span><br><span class="line">        if(nums.empty())           </span><br><span class="line">            return res;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据子集的长度递增的方式依次回溯求出</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;nums.size();i++)</span><br><span class="line">            DFS(i,0,nums,temp);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;参数</span><br><span class="line">    &#x2F;&#x2F;集合长度</span><br><span class="line">    void DFS(int length ,int start ,vector&lt;int&gt;&amp; nums ,vector&lt;int&gt;&amp; temp)&#123;</span><br><span class="line">        if(length&#x3D;&#x3D;0)&#123;</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;start;i&lt;nums.size();i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;同一层出现相同元素，只使用第一个，这样可以避免出现重复项，前提需要先对candidates排好序</span><br><span class="line">            if(i&gt;start&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1])</span><br><span class="line">                continue;</span><br><span class="line">            temp.push_back(nums[i]);</span><br><span class="line">            DFS(length-1,i+1,nums,temp);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-91-解码方法</title>
    <url>/2020/04/05/LeetCode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>


<p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;12&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;226&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;时间复杂度O(N)</span><br><span class="line">&#x2F;&#x2F;空间复杂度O(N)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        int len &#x3D; s.size();</span><br><span class="line">        vector&lt;int&gt; dp(len+1,0);</span><br><span class="line">        &#x2F;&#x2F;因为所给字符串为非空字符串，dp[0]位置设为1仅为了头两位是合法数字如&quot;24&quot;提供作用</span><br><span class="line">        dp[0]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;dp其他所有位置都是默认初始化为0</span><br><span class="line">        &#x2F;&#x2F;当字符串为&quot;0&quot;时，返回0</span><br><span class="line">        if(s[0]!&#x3D;&#39;0&#39;)</span><br><span class="line">             dp[1]&#x3D;1;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;len;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;当前位置不为0，则解码方式与前一位的解码方式相同</span><br><span class="line">            if(s[i-1]!&#x3D;&#39;0&#39;)</span><br><span class="line">                dp[i]&#x3D;dp[i-1];</span><br><span class="line">            int current &#x3D; (s[i-2]-&#39;0&#39;)*10+(s[i-1]-&#39;0&#39;);</span><br><span class="line">            &#x2F;&#x2F;两位数在合法的数字区间内，则dp[i]为单独一位的方式数+两位的方式数</span><br><span class="line">            if(current&gt;9&amp;&amp;current&lt;27)</span><br><span class="line">                dp[i]+&#x3D;dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-93-复原IP地址</title>
    <url>/2020/03/13/LeetCode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</span><br><span class="line">        &#x2F;&#x2F;预处理，长度为12，只有一种结果，直接返回</span><br><span class="line">        if(s.length()&#x3D;&#x3D;12)&#123;</span><br><span class="line">            for (int j &#x3D; 0;j &lt;4;j+&#x3D;3) &#123;</span><br><span class="line">                string str &#x3D; s.substr(j, 3);</span><br><span class="line">                if (str[0] &#x3D;&#x3D; &#39;0&#39; || stoi(str) &gt; 255)</span><br><span class="line">                    return res;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i&#x3D;3;i&lt;&#x3D;11;i+&#x3D;4)</span><br><span class="line">                s.insert(i,&quot;.&quot;);</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;递归dfs处理字符串</span><br><span class="line">        dfs(s,&quot;&quot;,0,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dfs(string s,string temp,int index,int count)&#123;</span><br><span class="line">        &#x2F;&#x2F;记录递归的层数</span><br><span class="line">        if(count&gt;4)return;</span><br><span class="line">        if(count&#x3D;&#x3D;4&amp;&amp;index&#x3D;&#x3D;s.length())</span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        for(int i&#x3D;1;i&lt;4;i++)&#123;</span><br><span class="line">            if(index+i&gt;s.length())return;</span><br><span class="line">            string str &#x3D; s.substr(index,i);</span><br><span class="line">            &#x2F;&#x2F;stoi(str)将字符串转为数字</span><br><span class="line">            if((str.length()&gt;1&amp;&amp;str[0]&#x3D;&#x3D;&#39;0&#39;)||stoi(str)&gt;255)</span><br><span class="line">                return;</span><br><span class="line">            dfs(s,temp+str+(count&#x3D;&#x3D;3?&quot;&quot;:&quot;.&quot;),index+i,count+1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/02/08/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd [用户名] &#x2F;&#x2F;添加用户</span><br><span class="line">passwd [密码]	&#x2F;&#x2F;设置密码</span><br></pre></td></tr></table></figure>

<h3 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h3><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><blockquote>
<p>change the permissions mode of a file——修改文件的使用权限，包括read、write、execute权限。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod (u&#x2F;g&#x2F;o)(+&#x2F;-&#x2F;&#x3D;)wrx [文件名] &#x2F;&#x2F;为用户、用户组、其他增加、减少、设定相关权限</span><br><span class="line">chmod 777 [文件名]</span><br></pre></td></tr></table></figure>

<h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><blockquote>
<p>change file ownership——修改文件的所有者</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown [用户] [文件或目录]</span><br></pre></td></tr></table></figure>

<h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><blockquote>
<p>change file group ownership——修改文件的所有用户组的权限        </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp [用户组] [文件或目录]</span><br><span class="line">umask &#x2F;&#x2F;查看缺省创建的权限更改</span><br></pre></td></tr></table></figure>

<h3 id="文件和目录的权限与执行"><a href="#文件和目录的权限与执行" class="headerlink" title="文件和目录的权限与执行"></a>文件和目录的权限与执行</h3><table>
<thead>
<tr>
<th>类型</th>
<th>read权限</th>
<th>write权限</th>
<th>execute权限</th>
</tr>
</thead>
<tbody><tr>
<td>文件</td>
<td>cat/more/head/tail/less</td>
<td>vim</td>
<td>script command</td>
</tr>
<tr>
<td>目录</td>
<td>ls</td>
<td>touch/mkdir/rmdir/rm</td>
<td>cd</td>
</tr>
</tbody></table>
<p><em>注:删除一个文件的前提是对文件<strong>所在的目录</strong>有r写权限，而非对该文件有w写权限</em></p>
<h3 id="挂载移动设备"><a href="#挂载移动设备" class="headerlink" title="挂载移动设备"></a>挂载移动设备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l &#x2F;dev&#x2F;sda	&#x2F;&#x2F;查看系统分区信息	</span><br><span class="line">df -h				&#x2F;&#x2F;查看已挂载</span><br></pre></td></tr></table></figure>

<h4 id="挂载u盘"><a href="#挂载u盘" class="headerlink" title="挂载u盘"></a>挂载u盘</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install exfat-fuse			&#x2F;&#x2F;安装支持exfat文件系统</span><br><span class="line">sudo mount -t exfat &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usb 	&#x2F;&#x2F;挂载</span><br><span class="line">sudo umount &#x2F;mnt&#x2F;usb					&#x2F;&#x2F;卸载</span><br></pre></td></tr></table></figure>

<h4 id="挂载移动硬盘"><a href="#挂载移动硬盘" class="headerlink" title="挂载移动硬盘"></a>挂载移动硬盘</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ntfs-3g				&#x2F;&#x2F;安装支持ntfs文件系统</span><br><span class="line">sudo mount -t ntfs-3g &#x2F;dev&#x2F;sda4 &#x2F;mnt&#x2F;ssd	&#x2F;&#x2F;挂载</span><br><span class="line">sudo umount &#x2F;mnt&#x2F;usb 						&#x2F;&#x2F;卸载</span><br></pre></td></tr></table></figure>

<h3 id="服务类命令"><a href="#服务类命令" class="headerlink" title="服务类命令"></a>服务类命令</h3><h4 id="centos6"><a href="#centos6" class="headerlink" title="centos6"></a>centos6</h4><p>注册在系统中的标准化程序</p>
<p>有方便统一的管理方式（常用的方法）</p>
<ul>
<li>service 服务名 start</li>
<li>service 服务名 stop</li>
<li>service 服务名 restart</li>
<li>service 服务名 reload</li>
<li>service 服务名 status</li>
</ul>
<p>查看服务的方法 /etc/init.d/服务名</p>
<p>通过chkconfig命令设置开机自启动</p>
<ul>
<li>查看服务 chkconfig –list | grep xxx</li>
<li>chkconfig –level 5 服务名 on</li>
</ul>
<h4 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h4><p>注册在系统中的标准化程序</p>
<p>有方便统一的管理方式（常用的方法）</p>
<ul>
<li>systemctl start 服务名(xxx.service)</li>
<li>systemctl stop 服务名(xxx.service)</li>
<li>systemctl restart 服务名(xxx.service)</li>
<li>systemctl reload 服务名(xxx.service)</li>
<li>systemctl status 服务名(xxx.service)</li>
</ul>
<p>查看服务的方法 /usr/lib/systemd/system</p>
<p>查看服务的命令</p>
<ul>
<li>systemctl list-unit-files</li>
<li>systemctl –type service</li>
</ul>
<p>通过systemctl命令设置自启动</p>
<ul>
<li>systemctl enable service_name</li>
<li>systemctl disable service_name</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的Shell编程</title>
    <url>/2020/09/03/Linux%E7%9A%84Shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="Linux的Shell编程"><a href="#Linux的Shell编程" class="headerlink" title="Linux的Shell编程"></a>Linux的Shell编程</h4><p> Shell 编程一般指 shell 脚本编程。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>使用 vi 编辑器新建一个文件 hello.sh </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></table></figure>

<h5 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 方式1</span><br><span class="line">sh hello.sh</span><br><span class="line"></span><br><span class="line"># 方式2</span><br><span class="line">chmod +x .&#x2F;hello.sh   #使脚本具有执行权限</span><br><span class="line">.&#x2F;hello.sh    #执行脚本</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">str="hello"</span><br><span class="line">echo $&#123;str&#125;world</span><br></pre></td></tr></table></figure>

<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo $HOME</span><br></pre></td></tr></table></figure>

<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><table>
<thead>
<tr>
<th>$#</th>
<th>传递到脚本的参数个数</th>
</tr>
</thead>
<tbody><tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程 ID 号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的 ID 号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。 0 表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "第一个参数为： $1";</span><br><span class="line">echo "参数个数为： $#";</span><br><span class="line">echo "传递的参数作为一个字符串显示： $*";</span><br></pre></td></tr></table></figure>

<p>执行: ./test.sh 1 2 3 </p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=1;</span><br><span class="line">b=2;</span><br><span class="line">echo `expr $a + $b`;</span><br><span class="line">echo  $((a+b));</span><br><span class="line">echo  $[a+b];</span><br></pre></td></tr></table></figure>

<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "please input your name:" NAME ## read命令用于从控制台读取输入数据</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># printf '%s\n' $NAME</span></span></span><br><span class="line">if [ $NAME = root ]</span><br><span class="line">	then</span><br><span class="line">		echo "hello $&#123;NAME&#125;, welcome !"</span><br><span class="line">	elif [ $NAME = itcast ]</span><br><span class="line">	then</span><br><span class="line">		echo "hello $&#123;NAME&#125;, welcome !"</span><br><span class="line">	else</span><br><span class="line">		echo "Get out Please!"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>方式1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for N in 1 2 3 </span><br><span class="line">do</span><br><span class="line">    echo $N</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for ((i = 0; i &lt;= 5; i++)) </span><br><span class="line"> do </span><br><span class="line">    echo "welcome $i times" </span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">echo "这个函数会对输入的两个数字进行相加运算..."</span><br><span class="line">echo "输入第一个数字: "</span><br><span class="line">read aNum</span><br><span class="line">echo "输入第二个数字: "</span><br><span class="line">read anotherNum</span><br><span class="line">echo "两个数字分别为 $aNum 和 $anotherNum !"</span><br><span class="line">return $(($aNum+$anotherNum))</span><br><span class="line">&#125; </span><br><span class="line">funWithReturn</span><br><span class="line">echo "输入的两个数字之和为 $? !"</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的文件目录与注意事项</title>
    <url>/2020/02/08/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="Linux服务器注意事项"><a href="#Linux服务器注意事项" class="headerlink" title="Linux服务器注意事项"></a>Linux服务器注意事项</h3><blockquote>
<ol>
<li>Linux严格区分大小写</li>
<li>远程服务器不允许关机，只能重启</li>
<li>重启时应关闭服务</li>
<li>不要在服务器访问高峰运行高负载命令</li>
<li>远程配置防火墙时不要把自己踢出服务器（每5分钟清空规则）</li>
<li>指定合理的密码规范并定期更新</li>
<li>合理分配权限-够用就好</li>
<li>定期备份重要数据和日志    </li>
</ol>
</blockquote>
<h3 id="Linux中所有内容以文件形式保存，包括硬件"><a href="#Linux中所有内容以文件形式保存，包括硬件" class="headerlink" title="Linux中所有内容以文件形式保存，包括硬件"></a>Linux中所有内容以文件形式保存，包括硬件</h3><blockquote>
<ol>
<li>Linux中的所有存储设备必须挂载之后才能用，包括硬盘、U盘和光盘</li>
<li>硬盘文件    <code>/dev/sd[a-p]</code></li>
<li>光盘文件    <code>/dev/sro</code></li>
</ol>
</blockquote>
<h3 id="Linux不靠扩展名区分文件类型"><a href="#Linux不靠扩展名区分文件类型" class="headerlink" title="Linux不靠扩展名区分文件类型"></a>Linux不靠扩展名区分文件类型</h3><blockquote>
<ul>
<li>压缩包：<code>*.gz</code>、<code>*.bz2</code>、<code>*.tar.bz2</code>、<code>*.tgz</code></li>
<li>二进制软件包：<code>*.rpm</code>、<code>*.deb</code></li>
<li>网页文件：<code>*.html</code>、<code>*.php</code></li>
<li>脚本文件：<code>*.sh</code></li>
<li>配置文件：<code>*.conf</code></li>
</ul>
</blockquote>
<h3 id="Linux各目录的作用"><a href="#Linux各目录的作用" class="headerlink" title="Linux各目录的作用"></a>Linux各目录的作用</h3><table>
<thead>
<tr>
<th align="center">目录</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/bin/</td>
<td>存放系统命令目录，普通用户和超级用户都可以执行，单用户模式下可以执行</td>
</tr>
<tr>
<td align="center">/sbin/</td>
<td>保存和系统环境相关的命令，只有超级用户可以使用，但有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td align="center">/usr/bin</td>
<td>同/bin/，但这些命令与系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td align="center">/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。            （注：sbin中保存的命令只有超级用户可以使用）</td>
</tr>
<tr>
<td align="center">/boot/</td>
<td>系统的启动目录，保存系统启动相关文件，如内核文件和启动引导程序（grup）文件等</td>
</tr>
<tr>
<td align="center">/dev/</td>
<td>设备文件保存位置，用来保存所有硬件设备文件</td>
</tr>
<tr>
<td align="center">/etc/</td>
<td>配置文件保存位置。系统所有采用默认安装方式的（rpm安装）的服务的配置文件全部保存在这里，如用户账户和密码，服务的启动脚本，常用服务的配置文件。</td>
</tr>
<tr>
<td align="center">/home/</td>
<td>普通用户家目录。建理每个用户时每个用户都要有一个默认登陆位置</td>
</tr>
<tr>
<td align="center">/lib/</td>
<td>系统调用函数库</td>
</tr>
<tr>
<td align="center">/lost_found/</td>
<td>系统意外奔溃或关机，产生的碎片保存位置。用来修复已损坏的文件系统</td>
</tr>
<tr>
<td align="center">/media/</td>
<td>挂载目录，用来挂载媒体设备</td>
</tr>
<tr>
<td align="center">/mnt/</td>
<td>挂载U盘、移动硬盘、其他OS分区</td>
</tr>
<tr>
<td align="center">/misc/</td>
<td>挂载NSF服务的共享目录</td>
</tr>
<tr>
<td align="center">/opt/</td>
<td>第三方软件保存位置。手工安装源码软件包可以安装这里。不过更习惯把软件放到/usr/local/下</td>
</tr>
<tr>
<td align="center">/proc/</td>
<td>虚拟文件系统，该目录中的数据并不保存到硬盘中，而是保存到内存中，主要保存系统的内核、进程、外部设备状态等</td>
</tr>
<tr>
<td align="center">/sys/</td>
<td>虚拟文件系统，与/proc/相似，都是保存在内存中，主要时保存与内核相关信息</td>
</tr>
<tr>
<td align="center">/root/</td>
<td>超级用户家目录。</td>
</tr>
<tr>
<td align="center">/srv/</td>
<td>服务数据目录。一些系统服务启动后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td align="center">/tmp/</td>
<td>临时目录</td>
</tr>
<tr>
<td align="center">/usr/</td>
<td>系统软件资源目录</td>
</tr>
<tr>
<td align="center">/var/</td>
<td>动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件</td>
</tr>
</tbody></table>
<h3 id="设置网络"><a href="#设置网络" class="headerlink" title="设置网络"></a>设置网络</h3><ul>
<li>桥连接 — 虚拟机的网段和本机在同一个网段，局域网内可以互相访问，但有可能出现<code>IP</code>地址重复</li>
<li><code>NAT</code>（常用） — 母机上会出现两个<code>ip</code>，<code>linux</code>可以访问外网，不会造成<code>ip</code>冲突，但是别的机器不能访问<code>linux</code></li>
<li>主机模式 — <code>linux</code>是独立主机，不能访问外网</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的压缩与解压命令</title>
    <url>/2020/02/08/Linux%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;在Linux中通常要使用压缩和解压缩命令对软件源包进行压缩和解压操作。下面是常见的格式和相关压缩命令。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="zip格式"><a href="#zip格式" class="headerlink" title="zip格式"></a>zip格式</h4><ul>
<li><p>压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip [压缩文件名] [源文件]   -r 压缩目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip [zip文件]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="gz格式"><a href="#gz格式" class="headerlink" title="gz格式"></a>gz格式</h4><ul>
<li><p>压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip [源文件] 源文件消失  -r 压缩目录</span><br><span class="line">gzip -c [源文件] [压缩文件] 源文件保留</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip -d [压缩文件] 压缩包不保留</span><br><span class="line">gunzip [压缩文件]  -r 解压目录</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="bz2格式"><a href="#bz2格式" class="headerlink" title="bz2格式"></a>bz2格式</h4><ul>
<li><p>压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bzip2 [源文件] 不保留源文件</span><br><span class="line">bzip2 -k [源文件] 保留源文件</span><br></pre></td></tr></table></figure>

<p><em>注：<code>bzip2</code>命令不能压缩目录</em></p>
</li>
<li><p>解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bzip2 -d [压缩文件] -d：不保留压缩文件</span><br><span class="line">bunzip2 [压缩文件] -k：保留压缩文件</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -cvf [打包文件名] [源文件]</span><br><span class="line">	-c  打包</span><br><span class="line">	-v  显示过程</span><br><span class="line">	-f  指定打包后的文件名</span><br></pre></td></tr></table></figure>

<h4 id="拆包命令"><a href="#拆包命令" class="headerlink" title="拆包命令"></a>拆包命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xcf [打包文件名]</span><br><span class="line">	-x  拆包</span><br><span class="line">	-v  显示过程</span><br><span class="line">	-f  指定打包后的文件名</span><br></pre></td></tr></table></figure>

<h4 id="tar-gz压缩格式"><a href="#tar-gz压缩格式" class="headerlink" title=".tar.gz压缩格式"></a>.tar.gz压缩格式</h4><h5 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf [压缩包名] [源文件]  -z：压缩文件.tar.gz格式</span><br></pre></td></tr></table></figure>

<h5 id="拆包解压"><a href="#拆包解压" class="headerlink" title="拆包解压"></a>拆包解压</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf [源文件压缩包名]  -x：解压缩.tar.gz格式</span><br></pre></td></tr></table></figure>

<h4 id="tar-bz2压缩格式"><a href="#tar-bz2压缩格式" class="headerlink" title=".tar.bz2压缩格式"></a>.tar.bz2压缩格式</h4><h5 id="打包压缩-1"><a href="#打包压缩-1" class="headerlink" title="打包压缩"></a>打包压缩</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -jcvf [压缩包名] [源文件]  -z：压缩文件.tar.bz2格式</span><br></pre></td></tr></table></figure>

<h5 id="拆包解压-1"><a href="#拆包解压-1" class="headerlink" title="拆包解压"></a>拆包解压</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -jxvf [源文件压缩包名]  -x：解压缩.tar. bz2格式</span><br></pre></td></tr></table></figure>

<h5 id="others"><a href="#others" class="headerlink" title="others"></a>others</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -ztvf [压缩文件的包名]  -t：代表查看压缩文件中的内容，但不解压</span><br><span class="line">tar -zxvf [源文件压缩包名] -C &#x2F;tmp  -C:指定解压的路径</span><br><span class="line">tar -zcvf test.tar.gz aa.txt bb.txt cc.txt  可同时打包多个文件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下安装JDK</title>
    <url>/2020/02/08/Linux%E4%B8%8B%E5%AE%89%E8%A3%85JDK/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;安装文件中附带<code>Linux</code>下的<code>JDK1.8</code>安装包。如系统环境不一致，请根据实际情况从官网下载对应版本的<code>JDK1.8</code>。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>将安装包解压<br>将<code>jdk</code>压缩包拷贝到系统中（目录可自行指定，本例中为<code>“/usr/local”</code>），并进行解压。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u161-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量<br>配置相关环境变量，修改<code>/etc/profile</code>文件，增加<code>jdk</code>的相关内容（<code>JAVA_HOME</code>、<code>PATH</code>等信息）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_161</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br></pre></td></tr></table></figure>

<p>如果想让相关配置立即生效，需要执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证<br>检测<code>jdk</code>安装是否正确，可以执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java –version</span><br></pre></td></tr></table></figure>

<p>如果能返回java的版本等信息，证明jdk已成功安装。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的软件安装命令</title>
    <url>/2020/02/08/Linux%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h3><ul>
<li><p>源码包（提供开源软件代码）</p>
<blockquote>
<p>脚本安装（为源码包写一个安装界面）</p>
</blockquote>
</li>
<li><p>二进制包（经过编译后的rpm包、系统默认包——类似于Windows中的.exe）</p>
<blockquote>
<p>red hat为<em>.rpm; debian为</em>.deb。</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>distribution代表</th>
<th>软件管理机制</th>
<th>使用命令</th>
<th>在线升级机制（命令）</th>
</tr>
</thead>
<tbody><tr>
<td>red hat/fedora</td>
<td>RPM</td>
<td>rpm,rpmbuild</td>
<td>YUM(yum)</td>
</tr>
<tr>
<td>Debian/Ubuntu</td>
<td>DPKG</td>
<td>dpkg</td>
<td>APT(apt-get)16.04</td>
</tr>
</tbody></table>
<h3 id="源码包的优点："><a href="#源码包的优点：" class="headerlink" title="源码包的优点："></a>源码包的优点：</h3><ul>
<li>开源，可修改源代码</li>
<li>可自由选择所需功能</li>
<li>软件是编译安装，更加适合自己的系统，更加稳定</li>
<li>卸载方便（直接删除安装目录）</li>
</ul>
<h3 id="源码包的缺点："><a href="#源码包的缺点：" class="headerlink" title="源码包的缺点："></a>源码包的缺点：</h3><ol>
<li>安装过程步骤较多</li>
<li>编译时间比安装二进制包长</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决</li>
</ol>
<h3 id="二进制包的优点："><a href="#二进制包的优点：" class="headerlink" title="二进制包的优点："></a>二进制包的优点：</h3><ol>
<li>包管理系统简单，通过几个命令就可以实现安装、升级、查询、卸载</li>
<li>安装速度快</li>
</ol>
<h3 id="二进制包的缺点："><a href="#二进制包的缺点：" class="headerlink" title="二进制包的缺点："></a>二进制包的缺点：</h3><ol>
<li>看不到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>包依赖性问题解决繁琐</li>
</ol>
<h3 id="安装位置"><a href="#安装位置" class="headerlink" title="安装位置"></a>安装位置</h3><h4 id="rpm包安装位置（默认）"><a href="#rpm包安装位置（默认）" class="headerlink" title="rpm包安装位置（默认）"></a>rpm包安装位置（默认）</h4><table>
<thead>
<tr>
<th>目录</th>
<th>注解</th>
</tr>
</thead>
<tbody><tr>
<td>/etc/</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>可执行命令安装目录</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/share/doc/</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>/usr/share/man/</td>
<td>帮助文件保存位置</td>
</tr>
</tbody></table>
<h4 id="源码包安装位置（一般）"><a href="#源码包安装位置（一般）" class="headerlink" title="源码包安装位置（一般）"></a>源码包安装位置（一般）</h4><table>
<thead>
<tr>
<th>目录</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>/usr/local/软件名</td>
<td>一般用户安装位置</td>
</tr>
</tbody></table>
<h4 id="安装位置不同带来的影响（服务的管理方法不同）"><a href="#安装位置不同带来的影响（服务的管理方法不同）" class="headerlink" title="安装位置不同带来的影响（服务的管理方法不同）"></a>安装位置不同带来的影响（服务的管理方法不同）</h4><ul>
<li><p>rpm包安装的服务可以使用系统服务管理，命令service来管理</p>
<blockquote>
<p>如rpm安装的apache的启动方式：</p>
<ol>
<li>/etc/rc.d/init.d/httpd start</li>
<li>service httpd start</li>
</ol>
</blockquote>
</li>
<li><p>源码包安装只能使用绝对路径来管理；service对其不起作用</p>
</li>
</ul>
<h3 id="RPM特性与安装命令"><a href="#RPM特性与安装命令" class="headerlink" title="RPM特性与安装命令"></a>RPM特性与安装命令</h3><h4 id="RPM包依赖性"><a href="#RPM包依赖性" class="headerlink" title="RPM包依赖性"></a>RPM包依赖性</h4><ul>
<li>树形依赖</li>
<li>环形依赖</li>
<li>模块依赖（查询网站：<a href="http://www.rpmfind.net）" target="_blank" rel="noopener">www.rpmfind.net）</a></li>
</ul>
<h4 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh 包全名</span><br><span class="line">	-i（install）</span><br><span class="line">	-v（verbose）显示详细信息</span><br><span class="line">	-h（hash）显示进度</span><br><span class="line">	--nodeps 不检测依赖性</span><br></pre></td></tr></table></figure>

<h4 id="rpm升级"><a href="#rpm升级" class="headerlink" title="rpm升级"></a>rpm升级</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -Uvh 包全名</span><br><span class="line">	-U(update)</span><br></pre></td></tr></table></figure>

<h4 id="rpm卸载"><a href="#rpm卸载" class="headerlink" title="rpm卸载"></a>rpm卸载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e 包名</span><br><span class="line">	-e（erase）卸载</span><br><span class="line">	--nodeps 不检查依赖性</span><br></pre></td></tr></table></figure>

<h4 id="others"><a href="#others" class="headerlink" title="others"></a>others</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -q  包名	 查询是否安装 </span><br><span class="line">rpm -qa		  查询所有已安装的rpm包</span><br><span class="line">rpm -qi 包名	 查询软件包详情</span><br><span class="line">rpm -ql 包名	 查询软件包中文件的安装位置（打算安装位置）</span><br><span class="line">rpm -qf 文件名 查询系统文件属于哪个rpm包</span><br><span class="line">rpm -qR 包名	 查询软件包的依赖性</span><br></pre></td></tr></table></figure>

<h3 id="YUM在线管理"><a href="#YUM在线管理" class="headerlink" title="YUM在线管理"></a>YUM在线管理</h3><ol>
<li>解决rpm包繁琐的依赖性问题</li>
<li>可在无网络环境下用cd解决yum源问题</li>
</ol>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list</span><br><span class="line">yum search 关键字</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install 包名	-y自动回答yes</span><br></pre></td></tr></table></figure>

<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y update 包名</span><br></pre></td></tr></table></figure>

<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y remove 包名</span><br></pre></td></tr></table></figure>

<h4 id="yum软件组管理命令"><a href="#yum软件组管理命令" class="headerlink" title="yum软件组管理命令"></a>yum软件组管理命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum grouplist</span><br><span class="line">yum groupinstall &quot;软件组名&quot;	组名有空格则加双引号</span><br><span class="line">yum groupremove &quot;软件组名&quot;</span><br></pre></td></tr></table></figure>

<p>注：yum的问题</p>
<ol>
<li>yum -y install更新系统内核，会导致系统启动不了，不能在远程机上执行</li>
<li>yum卸载若有系统相关依赖包，会导致系统异常（尽量不要卸载）</li>
</ol>
<h3 id="源码包安装"><a href="#源码包安装" class="headerlink" title="源码包安装"></a>源码包安装</h3><ol>
<li><p>安装准备</p>
<blockquote>
<ul>
<li>安装gcc编译器</li>
<li>下载源码包</li>
</ul>
</blockquote>
</li>
<li><p>注意事项</p>
<blockquote>
<ul>
<li>源代码保存位置：/usr/local/src</li>
<li>软件安装位置：/usr/local/src</li>
<li>如何确定安装过程报错<ul>
<li>安装过程停止</li>
<li>并出现error、warning、not提示</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>安装过程</p>
<blockquote>
<p>make 编译<br>make clean 清空出错的编译文件<br>make install 编译安装</p>
</blockquote>
</li>
<li><p>源码包卸载</p>
<blockquote>
<p>直接删除软件目录，如： rm -rf /usr/local/apache2/</p>
</blockquote>
</li>
</ol>
<h3 id="Debian之Ubuntu软件安装"><a href="#Debian之Ubuntu软件安装" class="headerlink" title="Debian之Ubuntu软件安装"></a>Debian之Ubuntu软件安装</h3><p><em><code>ubuntu16.04</code>版本后<code>apt-get</code>可简化写为apt</em></p>
<h4 id="在线安装apt-get"><a href="#在线安装apt-get" class="headerlink" title="在线安装apt-get"></a>在线安装apt-get</h4><ul>
<li><p>安装 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install 包名</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove 软件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>软件列表的更新    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">ps:软件列表是ubuntu提供的可安装程序的所有链接；一般在安装之前先更新一下</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空缓存 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get clean  清空在线安装缓存在本地的安装包</span><br><span class="line">位置： &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="软件包的安装（-deb格式）"><a href="#软件包的安装（-deb格式）" class="headerlink" title="软件包的安装（*.deb格式）"></a>软件包的安装（*.deb格式）</h4><ul>
<li><p>安装    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i 包全名</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -r 软件名</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的查找命令</title>
    <url>/2020/02/08/Linux%E7%9A%84%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;Linux中文件类型有二进制文件binary、目录directory、软链接link</p>
<h3 id="find查找"><a href="#find查找" class="headerlink" title="find查找"></a>find查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find [搜索范围] [匹配条件]</span><br></pre></td></tr></table></figure>

<h4 id="名称查找"><a href="#名称查找" class="headerlink" title="名称查找"></a>名称查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -name *init??		&#x2F;&#x2F;init为部分文件名，*代表通配符，?代表一个占位符</span><br></pre></td></tr></table></figure>

<h4 id="大小查找"><a href="#大小查找" class="headerlink" title="大小查找"></a>大小查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -size +n&#x2F;-n&#x2F;n		&#x2F;&#x2F;n表示文件的大小，204800为100MB,+表示大于，-表示小于</span><br></pre></td></tr></table></figure>

<h4 id="所有者查找"><a href="#所有者查找" class="headerlink" title="所有者查找"></a>所有者查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;home -user username</span><br></pre></td></tr></table></figure>

<h4 id="与或查找"><a href="#与或查找" class="headerlink" title="与或查找"></a>与或查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -size +type f&#x2F;d&#x2F;l -a&#x2F;o -inum 31223		</span><br><span class="line">&#x2F;&#x2F;注：f[文件] d[目录] l[软链接文件] -inum:根据i节点查找</span><br></pre></td></tr></table></figure>

<h4 id="查找并执行命令"><a href="#查找并执行命令" class="headerlink" title="查找并执行命令"></a>查找并执行命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -name inittab -exec ls-l &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="grep查找"><a href="#grep查找" class="headerlink" title="grep查找"></a>grep查找</h3><p> <em>在文件中搜索匹配符合条件的行并输出</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep [选项] [字符串] [文件名]  </span><br><span class="line">例如：grep -i mysql &#x2F;root&#x2F;install.log	-i忽略大小写</span><br><span class="line">	 grep -v ^# &#x2F;etc&#x2F;inittab	-v排除指定字符</span><br></pre></td></tr></table></figure>

<blockquote>
<p>find命令与grep的区别：</p>
<ol>
<li>find命令在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配。</li>
<li>grep命令在文件中搜索符合条件的字符串，如果需要匹配，使用正则表达式进行匹配。</li>
</ol>
</blockquote>
<h3 id="which查找"><a href="#which查找" class="headerlink" title="which查找"></a>which查找</h3><p><em>搜索命令所在目录及别名信息</em> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which ls</span><br></pre></td></tr></table></figure>

<h3 id="locate查找"><a href="#locate查找" class="headerlink" title="locate查找"></a>locate查找</h3><p> <em>文件资料库中查找文件</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate -i [文件名]		&#x2F;&#x2F;-i不区分大小写</span><br><span class="line">update更新文件资料库</span><br></pre></td></tr></table></figure>


<p>注：无法查找/tmp中的内容</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>使用”#“表示其后为标题，”#“的数量表征了其后标题的级数，使用时应注意”#“后务必要追加一个空格。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/1.png" alt></p>
<p>由<strong>#</strong>的数量决定是几号标题，数量越多字越小。</p>
<h2 id="二、文本样式"><a href="#二、文本样式" class="headerlink" title="二、文本样式"></a>二、文本样式</h2><h3 id="1-粗体"><a href="#1-粗体" class="headerlink" title="1.粗体"></a>1.粗体</h3><p>使用一对”**“或“__”括起来的内容将会被粗体展示。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/2.png" alt></p>
<h3 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.斜体</h3><p>使用一对”*“或“_”括起来的内容将会被斜体展示。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/3.png" alt></p>
<h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3.删除线"></a>3.删除线</h3><p>使用一对”~~“括起来的内容将会被斜体展示。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/4.png" alt></p>
<h3 id="4-角标"><a href="#4-角标" class="headerlink" title="4.角标"></a>4.角标</h3><ul>
<li><p>上角标</p>
<p>使用一对”^“括起来的内容是上角标。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/5.png" alt></p>
</li>
<li><p>下角标</p>
<p>使用一对”~“括起来的内容是下角标。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/6.png" alt></p>
</li>
</ul>
<h3 id="5-脚注"><a href="#5-脚注" class="headerlink" title="5.脚注"></a>5.脚注</h3><p>使用（X代指数字）表示一个注脚，使用 给出注解的解释。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/7.png" alt></p>
<h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><ul>
<li><p>无序列表</p>
<p>使用“-”、“+”、“*”（三者功能相同）表示其后是一个列表，符号后同样需要追加空格。如：</p>
<p><img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/8.png" alt></p>
</li>
<li><p>有序列表</p>
<p>使用“X.”（X代指数字）表示其后是一个有序列表，“.”后需追加空格。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/9.png" alt></p>
</li>
<li><p>待办事项</p>
<p>使用“[ ]”表示一个方框(一对方括号间有一个空格)，使用“[X]”表示一个被勾选的方框（x不区分大小写）。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/10.png" alt></p>
</li>
</ul>
<h2 id="四、引用"><a href="#四、引用" class="headerlink" title="四、引用"></a>四、引用</h2><p>使用“&gt;”可以引用文本。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/11.png" alt></p>
<h2 id="五、插入"><a href="#五、插入" class="headerlink" title="五、插入"></a>五、插入</h2><h3 id="1-插入链接"><a href="#1-插入链接" class="headerlink" title="1.插入链接"></a>1.插入链接</h3><p>使用下面的格式可以插入一个链接。</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/12.png" alt></p>
<p>如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/13.png" alt></p>
<h3 id="2-插入图片"><a href="#2-插入图片" class="headerlink" title="2.插入图片"></a>2.插入图片</h3><p>使用下面的格式可以插入一张图片。</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/14.png" alt></p>
<p>如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/15.png" alt></p>
<h3 id="3-插入代码"><a href="#3-插入代码" class="headerlink" title="3.插入代码"></a>3.插入代码</h3><p>使用一对“```”括起来的内容被展示为一段代码。如：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/16.png" alt></p>
<p>将产生以下效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，使用一对“`”括起来的内容被当作是单行代码。</p>
<h2 id="六、表格"><a href="#六、表格" class="headerlink" title="六、表格"></a>六、表格</h2><p>使用下面的格式可以生成一个表格：</p>
<p> <img src="/2020/02/12/Markdown%E8%AF%AD%E6%B3%95/17.png" alt></p>
<p>其中,中划线后的冒号可以控制对齐方式，在左边即左对齐，在右边即右对齐。</p>
<table>
<thead>
<tr>
<th align="center">科目</th>
<th align="center">分数</th>
<th align="right">排名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">语文</td>
<td align="center">90</td>
<td align="right">1</td>
</tr>
<tr>
<td align="center">数学</td>
<td align="center">90</td>
<td align="right">1</td>
</tr>
<tr>
<td align="center">英语</td>
<td align="center">90</td>
<td align="right">1</td>
</tr>
</tbody></table>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-1006 Sign In and Sign Out</title>
    <url>/2020/02/27/PAT-1006-Sign-In-and-Sign-Out/</url>
    <content><![CDATA[<p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer <em>M</em>, which is the total number of records, followed by <em>M</em> lines, each in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ID_number Sign_in_time Sign_out_time</span><br></pre></td></tr></table></figure>

<p>where times are given in the format <code>HH:MM:SS</code>, and <code>ID_number</code> is a string with no more than 15 characters.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>
<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">CS301111 15:30:28 17:00:10</span><br><span class="line">SC3021234 08:00:00 11:25:25</span><br><span class="line">CS301133 21:45:00 21:58:40</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC3021234 CS301133</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string first_per;&#x2F;&#x2F;存储第一个人的id</span><br><span class="line">string last_per;&#x2F;&#x2F;存储第二个人的id</span><br><span class="line">string firsttime &#x3D; &quot;23:59:59&quot;;</span><br><span class="line">string lasttime &#x3D; &quot;00:00:00&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找到一天中谁开的门，谁锁的门</span><br><span class="line">void _1006() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;&#x2F;&#x2F;总人数</span><br><span class="line">	string id, intime, outtime;</span><br><span class="line">	&#x2F;&#x2F;&#x2F;&#x2F;char id[20],intime[20],outtime[20];</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		cin &gt;&gt; id &gt;&gt; intime &gt;&gt; outtime;</span><br><span class="line">		&#x2F;&#x2F;	scanf(&quot;%s%s%s&quot;, id, intime, outtime);</span><br><span class="line">		if (intime &lt; firsttime) &#123;</span><br><span class="line">			firsttime &#x3D; intime;</span><br><span class="line">			first_per &#x3D; id;</span><br><span class="line">		&#125;</span><br><span class="line">		if (outtime &gt; lasttime) &#123;</span><br><span class="line">			lasttime &#x3D; outtime;</span><br><span class="line">			last_per &#x3D; id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; first_per + &quot; &quot; + last_per &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT刷题</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1008-Elevator</title>
    <url>/2020/03/25/PAT-A-1008-Elevator/</url>
    <content><![CDATA[<p>The highest building in our city has only one elevator. A request list is made up with <em>N</em> positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.</p>
<p>For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a positive integer <em>N</em>, followed by <em>N</em> positive numbers. All the numbers in the input are less than 100.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the total time on a single line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 3 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">41</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;上升6s，下降4s，每层停留5s</span><br><span class="line">void _1008() &#123;</span><br><span class="line">	int n, x;</span><br><span class="line">	scanf_s(&quot;%d&quot;, &amp;n);</span><br><span class="line">	queue&lt;int&gt; seq;</span><br><span class="line">	while (n &gt; 0) &#123;</span><br><span class="line">		n--;</span><br><span class="line">		scanf_s(&quot;%d&quot;, &amp;x);</span><br><span class="line">		seq.push(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int total &#x3D; 0, current &#x3D; 0;</span><br><span class="line">	while (!seq.empty()) &#123;</span><br><span class="line">		int t &#x3D; seq.front();</span><br><span class="line">		seq.pop();</span><br><span class="line">		&#x2F;&#x2F;上升</span><br><span class="line">		if (t &gt; current) </span><br><span class="line">			total +&#x3D; (t - current) * 6;</span><br><span class="line">		&#x2F;&#x2F;下降</span><br><span class="line">		else </span><br><span class="line">			total +&#x3D; (current - t) * 4;</span><br><span class="line">		total +&#x3D; 5;</span><br><span class="line">		current &#x3D; t;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1009-Product of Polynomials</title>
    <url>/2020/03/18/PAT-A-1009-Product-of-Polynomials/</url>
    <content><![CDATA[<p>This time, you are supposed to find <em>A</em>×<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p><em>K</em> <em>N</em>1 <em>a<strong>N<em>1 *N</em>2 *a</strong>N<em>2 … <em>N</em></em>K</em> <em>a<strong>N</strong>K</em></p>
<p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>N**i</em> and <em>a<strong>N</strong>i</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10, 0≤<em>N**K</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the product of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be <strong>NO</strong> extra space at the end of each line. Please be accurate up to 1 decimal place.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2.4 0 3.2</span><br><span class="line">2 2 1.5 1 0.5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 3.6 2 6.0 1 1.6</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：f2的每一项与f1的每一项相乘；利用数组的索引值当作项的指数</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">double f1[1001]&#x3D;&#123;0.0&#125;;</span><br><span class="line">double res[2001]&#x3D;&#123;0.0&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n, m;</span><br><span class="line">	&#x2F;&#x2F;多项式中的项数</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	int i, j;</span><br><span class="line">	int exp;</span><br><span class="line">	double coe;</span><br><span class="line">	for (i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		scanf(&quot;%d%lf&quot;, &amp;exp, &amp;coe);</span><br><span class="line">		f1[exp] &#x3D; coe;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;输入多项式二</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">	for (i &#x3D; 0;i &lt; m;i++) &#123;</span><br><span class="line">		scanf(&quot;%d %lf&quot;, &amp;exp, &amp;coe);</span><br><span class="line">		&#x2F;&#x2F;输入项与f1的每一项相乘</span><br><span class="line">		for (j &#x3D; 0;j &lt; 1001;j++) &#123;</span><br><span class="line">			&#x2F;&#x2F;先判断f1中这一项存不存在</span><br><span class="line">			if (f1[j] !&#x3D; 0.0)</span><br><span class="line">				res[exp + j] +&#x3D; f1[j] * coe;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;统计结果的项数</span><br><span class="line">	int count &#x3D; 0;</span><br><span class="line">	for (i &#x3D; 0;i &lt; 2001;i++) &#123;</span><br><span class="line">		if (res[i]!&#x3D;0.0)</span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d&quot;, count);</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 2000;i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line">		if (res[i]!&#x3D;0.0) </span><br><span class="line">			printf(&quot; %d %.1f&quot;, i, res[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1011 World Cup Betting</title>
    <url>/2020/03/18/PAT-A-1011-World-Cup-Betting/</url>
    <content><![CDATA[<p>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>
<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely <code>W</code> for win, <code>T</code> for tie, and <code>L</code> for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>
<p>For example, 3 games’ odds are given as the following:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> W    T    L</span><br><span class="line">1.1  2.5  1.7</span><br><span class="line">1.2  3.1  1.6</span><br><span class="line">4.1  1.2  1.1</span><br></pre></td></tr></table></figure>

<p>To obtain the maximum profit, one must buy <code>W</code> for the 3rd game, <code>T</code> for the 2nd game, and <code>T</code> for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places).</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to <code>W</code>, <code>T</code> and <code>L</code>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.1 2.5 1.7</span><br><span class="line">1.2 3.1 1.6</span><br><span class="line">4.1 1.2 1.1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T T W 39.31</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char res[3] &#x3D; &#123; &#39;W&#39; &#125;;</span><br><span class="line">double _max[3] &#x3D; &#123; 0.0 &#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	&#x2F;&#x2F;输入三场比赛</span><br><span class="line">	double w, t, l;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; 3;i++) &#123;</span><br><span class="line">		scanf(&quot;%lf%lf%lf&quot;, &amp;w, &amp;t, &amp;l);</span><br><span class="line">		if (w &gt; t&amp;&amp; w &gt; l) &#123;</span><br><span class="line">			res[i] &#x3D; &#39;W&#39;;</span><br><span class="line">			_max[i] &#x3D; w;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (t &gt; w&amp;&amp; t &gt; l) &#123;</span><br><span class="line">			res[i] &#x3D; &#39;T&#39;;</span><br><span class="line">			_max[i] &#x3D; t;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (l &gt; w&amp;&amp; l &gt; t) &#123;</span><br><span class="line">			res[i] &#x3D; &#39;L&#39;;</span><br><span class="line">			_max[i] &#x3D; l;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	double ans &#x3D; (_max[0] * _max[1] * _max[2] * 0.65 - 1) * 2;</span><br><span class="line">	printf(&quot;%c %c %c %.2lf&quot;, res[0], res[1], res[2], ans);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>查找元素</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-1002 A+B for Polynomials</title>
    <url>/2020/02/27/PAT-1002-A-B-for-Polynomials/</url>
    <content><![CDATA[<p>This time, you are supposed to find <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are two polynomials.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p><em>K</em> <em>N</em>1 <em>a<strong>N<em>1 *N</em>2 *a</strong>N<em>2 … <em>N</em></em>K</em> <em>a<strong>N</strong>K</em></p>
<p>where <em>K</em> is the number of nonzero terms in the polynomial, <em>N**i</em> and <em>a<strong>N</strong>i</em> (<em>i</em>=1,2,⋯,<em>K</em>) are the exponents and coefficients, respectively. It is given that 1≤<em>K</em>≤10，0≤<em>N**K</em>&lt;⋯&lt;<em>N</em>2&lt;<em>N</em>1≤1000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2.4 0 3.2</span><br><span class="line">2 2 1.5 1 0.5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 1.5 1 2.9 0 3.2</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;注意点</span><br><span class="line">&#x2F;&#x2F;coefficients可以是负数</span><br><span class="line">&#x2F;&#x2F;系数为0不进行输出</span><br><span class="line">&#x2F;&#x2F;如果size为0，直接输出0</span><br><span class="line">&#x2F;&#x2F;最后没有空格</span><br><span class="line">float poly[1001];</span><br><span class="line"></span><br><span class="line">void _1002() &#123;</span><br><span class="line">	stack&lt;float&gt; coefficients;</span><br><span class="line">	stack&lt;int&gt; exponents;</span><br><span class="line">	&#x2F;&#x2F;每行几个多项式</span><br><span class="line">	int n, exp;</span><br><span class="line">	float cof;</span><br><span class="line">	&#x2F;&#x2F;共两行</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 2; ++i) &#123;</span><br><span class="line">		(void)scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">			(void)scanf(&quot;%d%f&quot;, &amp;exp, &amp;cof);</span><br><span class="line">			poly[exp] +&#x3D; cof;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;次数从高到底</span><br><span class="line">	for (int i &#x3D; 0; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">		if (poly[i] !&#x3D; 0) &#123;</span><br><span class="line">			coefficients.push(poly[i]);</span><br><span class="line">			exponents.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int count &#x3D; coefficients.size();</span><br><span class="line">	printf(&quot;%d&quot;, count);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">		float coe &#x3D; coefficients.top();</span><br><span class="line">		int exp &#x3D; exponents.top();</span><br><span class="line">		coefficients.pop();</span><br><span class="line">		exponents.pop();</span><br><span class="line">		printf(&quot; %d %.1f&quot;, exp, coe);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT刷题</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1013-Reversible Primes</title>
    <url>/2020/03/26/PAT-A-1013-Reversible-Primes/</url>
    <content><![CDATA[<p>A <strong>reversible prime</strong> in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.</p>
<p>Now given any two positive integers <em>N</em> (&lt;105) and <em>D</em> (1&lt;<em>D</em>≤10), you are supposed to tell if <em>N</em> is a reversible prime with radix <em>D</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>The input file consists of several test cases. Each case occupies a line which contains two integers <em>N</em> and <em>D</em>. The input is finished by a negative <em>N</em>.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line <code>Yes</code> if <em>N</em> is a reversible prime with radix <em>D</em>, or <code>No</code> if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">73 10</span><br><span class="line">23 2</span><br><span class="line">23 10</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isPrime(int n)&#123;</span><br><span class="line">    if(n&lt;&#x3D;1)return false;</span><br><span class="line">    int sqr&#x3D;(int)sqrt(1.0*n);</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;sqr;i++)</span><br><span class="line">        if(n%i&#x3D;&#x3D;0)return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int change[200];	</span><br><span class="line">	int n,d,count;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;</span><br><span class="line">        if(n&lt;0)break;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;d);</span><br><span class="line">        if(isPrime(n))&#123;</span><br><span class="line">            count&#x3D;0;</span><br><span class="line">            &#x2F;&#x2F;进行进制转化(按照从左到右低位到高位的存储)</span><br><span class="line">            do&#123;</span><br><span class="line">                change[count++]&#x3D;n%d;</span><br><span class="line">                n&#x2F;&#x3D;d;</span><br><span class="line">            &#125;while(n!&#x3D;0);</span><br><span class="line">            &#x2F;&#x2F;转为10进制</span><br><span class="line">            int product&#x3D;1;</span><br><span class="line">            for(int i&#x3D;count-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">                n+&#x3D;change[i]*product;</span><br><span class="line">                product*&#x3D;d;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(isPrime(n))</span><br><span class="line">                printf(&quot;Yes\n&quot;);</span><br><span class="line">            else</span><br><span class="line">                printf(&quot;No\n&quot;);</span><br><span class="line">        &#125;else</span><br><span class="line">            printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1019-General Palindromic Number</title>
    <url>/2020/03/19/PAT-A-1019-General-Palindromic-Number/</url>
    <content><![CDATA[<p>A number that will be the same when it is written forwards or backwards is known as a <strong>Palindromic Number</strong>. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.</p>
<p>Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number <em>N</em>&gt;0 in base <em>b</em>≥2, where it is written in standard notation with <em>k</em>+1 digits <em>a**i</em> as ∑<em>i</em>=0<em>k</em>(<em>a<strong>i</strong>b**i</em>). Here, as usual, 0≤<em>a**i</em>&lt;<em>b</em> for all <em>i</em> and <em>a**k</em> is non-zero. Then <em>N</em> is palindromic if and only if <em>a**i</em>=<em>a*<em>k</em>−*i</em> for all <em>i</em>. Zero is written 0 in any base and is also palindromic by definition.</p>
<p>Given any positive decimal integer <em>N</em> and a base <em>b</em>, you are supposed to tell if <em>N</em> is a palindromic number in base <em>b</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case consists of two positive numbers <em>N</em> and <em>b</em>, where 0&lt;<em>N</em>≤109 is the decimal number and 2≤<em>b</em>≤109 is the base. The numbers are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, first print in one line <code>Yes</code> if <em>N</em> is a palindromic number in base <em>b</em>, or <code>No</code> if not. Then in the next line, print <em>N</em> as the number in base <em>b</em> in the form “<em>a**k</em> <em>a*</em>k<em>−1 … *a</em>0”. Notice that there must be no extra space at the end of output.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">1 1 0 1 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">121 5</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">4 4 1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int num,base,r[40],i&#x3D;0;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;num,&amp;base);</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        r[i++]&#x3D;num%base;</span><br><span class="line">        num&#x2F;&#x3D;base;</span><br><span class="line">    &#125;while(num!&#x3D;0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;最终i为进制转换后的长度</span><br><span class="line">    bool ans &#x3D; true;</span><br><span class="line"></span><br><span class="line">    for(int j&#x3D;0;j&lt;i&#x2F;2;j++)&#123;</span><br><span class="line">        if(r[j]!&#x3D;r[i-1-j])</span><br><span class="line">            ans&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ans)</span><br><span class="line">        printf(&quot;Yes\n&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;No\n&quot;);</span><br><span class="line">    </span><br><span class="line">    for(int j&#x3D;i-1;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,r[j]);</span><br><span class="line">        if(j!&#x3D;0)</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1031-Hello World for U</title>
    <url>/2020/03/19/PAT-A-1031-Hello-World-for-U/</url>
    <content><![CDATA[<p>Given any string of <em>N</em> (≥5) characters, you are asked to form the characters into the shape of <code>U</code>. For example, <code>helloworld</code> can be printed as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h  d</span><br><span class="line">e  l</span><br><span class="line">l  r</span><br><span class="line">lowo</span><br></pre></td></tr></table></figure>

<p>That is, the characters must be printed in the original order, starting top-down from the left vertical line with <em>n</em>1 characters, then left to right along the bottom line with <em>n</em>2 characters, and finally bottom-up along the vertical line with <em>n</em>3 characters. And more, we would like <code>U</code> to be as squared as possible – that is, it must be satisfied that <em>n</em>1=<em>n</em>3=<em>m<strong>a</strong>x</em> { <em>k</em> | <em>k</em>≤<em>n</em>2 for all 3≤<em>n</em>2≤<em>N</em> } with <em>n</em>1+<em>n</em>2+<em>n</em>3−2=<em>N</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the input string in the shape of U as specified in the description.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helloworld!</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h   !</span><br><span class="line">e   d</span><br><span class="line">l   l</span><br><span class="line">lowor</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	char str[81];</span><br><span class="line">	scanf(&quot;%s&quot;, str);</span><br><span class="line"></span><br><span class="line">	int N &#x3D; strlen(str);</span><br><span class="line">	&#x2F;&#x2F;需要注意的就是n1,n2,n3均包括交点</span><br><span class="line">	int n1 &#x3D; (N + 2) &#x2F; 3, n3 &#x3D; n1, n2 &#x3D; N + 2 - 2 * n1;&#x2F;&#x2F;计算出各条边的长度</span><br><span class="line">	for (int i &#x3D; 0;i &lt; n1 - 1;i++) &#123;</span><br><span class="line">		printf(&quot;%c&quot;, str[i]);</span><br><span class="line">		for (int j &#x3D; 0;j &lt; n2 - 2;j++)</span><br><span class="line">			printf(&quot; &quot;);</span><br><span class="line">		printf(&quot;%c\n&quot;, str[N - 1 - i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; n1 - 1;i &lt; N - n1+1;i++)</span><br><span class="line">		printf(&quot;%c&quot;, str[i]);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>图形输出</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1027-Colors in Mars</title>
    <url>/2020/03/19/PAT-A-1027-Colors-in-Mars/</url>
    <content><![CDATA[<p>People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for <code>Red</code>, the middle 2 digits for <code>Green</code>, and the last 2 digits for <code>Blue</code>. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which occupies a line containing the three decimal color values.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the Mars RGB value in the following format: first output <code>#</code>, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a <code>0</code> to its left.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 43 71</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#123456</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char radix[13]&#x3D;&#123;&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int r,g,b;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;r,&amp;g,&amp;b);</span><br><span class="line">    printf(&quot;#&quot;);</span><br><span class="line">    printf(&quot;%c%c&quot;,radix[r&#x2F;13],radix[r%13]);</span><br><span class="line">    printf(&quot;%c%c&quot;,radix[g&#x2F;13],radix[g%13]);</span><br><span class="line">    printf(&quot;%c%c&quot;,radix[b&#x2F;13],radix[b%13]);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1020-Tree Traversals</title>
    <url>/2020/05/13/PAT-A-1020-Tree-Traversals/</url>
    <content><![CDATA[<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 1 5 7 6 4</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1 6 3 5 7 2</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	node* lc, * rc;</span><br><span class="line">	node(int data) :data(data), lc(0), rc(0) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int postseq[30], inseq[30];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用后序遍历和中序遍历构建树，并返回根节点</span><br><span class="line">node* buildTree(int postL, int postR, int inL, int inR) &#123;</span><br><span class="line">	if (postL &gt; postR)</span><br><span class="line">		return 0;</span><br><span class="line">	node* root &#x3D; new node(postseq[postR]);</span><br><span class="line">	int i;</span><br><span class="line">	for (i &#x3D; inL;i &lt;&#x3D; inR;i++) &#123;</span><br><span class="line">		if (root-&gt;data &#x3D;&#x3D; inseq[i])</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;左子树的节点个数</span><br><span class="line">	int lnums &#x3D; i - inL;</span><br><span class="line">	root-&gt;lc &#x3D; buildTree(postL, postL + lnums - 1, inL, i - 1);</span><br><span class="line">	root-&gt;rc &#x3D; buildTree(postL + lnums, postR - 1, i + 1, inR);</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void levelOrder(node* root) &#123;</span><br><span class="line">	queue&lt;node*&gt; q;</span><br><span class="line">	q.push(root);</span><br><span class="line">	node* temp;</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	while (!q.empty()) &#123;</span><br><span class="line">		temp &#x3D; q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		if (cnt++ &#x3D;&#x3D; 0)</span><br><span class="line">			printf(&quot;%d&quot;, temp-&gt;data);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot; %d&quot;, temp-&gt;data);</span><br><span class="line">		if (temp-&gt;lc!&#x3D;0) &#123;</span><br><span class="line">			q.push(temp-&gt;lc);</span><br><span class="line">		&#125;</span><br><span class="line">		if (temp-&gt;rc !&#x3D; 0) &#123;</span><br><span class="line">			q.push(temp-&gt;rc);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, i, j;&#x2F;&#x2F;节点的个数</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (i &#x3D; 0;i &lt; n;i++)</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;postseq[i]);</span><br><span class="line"></span><br><span class="line">	for (j &#x3D; 0;j &lt; n;j++)</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;inseq[j]);</span><br><span class="line"></span><br><span class="line">	node* root &#x3D; buildTree(0, n - 1, 0, n - 1);</span><br><span class="line">	levelOrder(root);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT-A(25)</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1036 Boys vs Girls</title>
    <url>/2020/03/18/PAT-A-1036-Boys-vs-Girls/</url>
    <content><![CDATA[<p>This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a positive integer <em>N</em>, followed by <em>N</em> lines of student information. Each line contains a student’s <code>name</code>, <code>gender</code>, <code>ID</code> and <code>grade</code>, separated by a space, where <code>name</code> and <code>ID</code> are strings of no more than 10 characters with no space, <code>gender</code> is either <code>F</code> (female) or <code>M</code> (male), and <code>grade</code> is an integer between 0 and 100. It is guaranteed that all the grades are distinct.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference <em>g<strong>r</strong>a<strong>d</strong>e<strong>F<em>−</em>g</strong>r<strong>a</strong>d<strong>e</strong>M</em>. If one such kind of student is missing, output <code>Absent</code> in the corresponding line, and output <code>NA</code> in the third line instead.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Joe M Math990112 89</span><br><span class="line">Mike M CS991301 100</span><br><span class="line">Mary F EE990830 95</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mary EE990830</span><br><span class="line">Joe Math990112</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Jean M AA980920 60</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Absent</span><br><span class="line">Jean AA980920</span><br><span class="line">NA</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct stu&#123;</span><br><span class="line">    char name[11];</span><br><span class="line">    char gender;</span><br><span class="line">    char id[11];</span><br><span class="line">    int grade;</span><br><span class="line">&#125;FH,ML,temp;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F;先对女高男低做初始化</span><br><span class="line">	FH.grade &#x3D; -1;</span><br><span class="line">	ML.grade &#x3D; 101;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		scanf(&quot;%s %c%s%d&quot;, temp.name, &amp;temp.gender, temp.id, &amp;temp.grade);</span><br><span class="line">		if (temp.gender &#x3D;&#x3D; &#39;M&#39;&amp;&amp;temp.grade &lt; ML.grade)</span><br><span class="line">			ML &#x3D; temp;</span><br><span class="line">		if (temp.gender &#x3D;&#x3D; &#39;F&#39;&amp;&amp;temp.grade &gt; FH.grade)</span><br><span class="line">			FH &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool absent &#x3D; false;</span><br><span class="line">	if (FH.grade &#x3D;&#x3D; -1) &#123;&#x2F;&#x2F;没有女生</span><br><span class="line">		printf(&quot;Absent\n&quot;);</span><br><span class="line">		absent &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;%s %s\n&quot;, FH.name, FH.id);</span><br><span class="line"></span><br><span class="line">	if (ML.grade &#x3D;&#x3D; 101) &#123;&#x2F;&#x2F;没有男生</span><br><span class="line">		printf(&quot;Absent\n&quot;);</span><br><span class="line">		absent &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;%s %s\n&quot;, ML.name, ML.id);</span><br><span class="line"></span><br><span class="line">	if (absent)printf(&quot;NA\n&quot;);</span><br><span class="line">	else printf(&quot;%d\n&quot;, FH.grade - ML.grade);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>查找元素</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1042 Shuffling Machine</title>
    <url>/2020/03/16/PAT-A-1042-Shuffling-Machine/</url>
    <content><![CDATA[<p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ <strong>automatic shuffling machines</strong>. Your task is to simulate a shuffling machine.</p>
<p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S1, S2, ..., S13, </span><br><span class="line">H1, H2, ..., H13, </span><br><span class="line">C1, C2, ..., C13, </span><br><span class="line">D1, D2, ..., D13, </span><br><span class="line">J1, J2</span><br></pre></td></tr></table></figure>

<p>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the <em>i</em>-th position is <em>j</em>, it means to move the card from position <em>i</em> to position <em>j</em>. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>K</em> (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 54;</span><br><span class="line">char mp[5] &#x3D; &#123; &#39;S&#39;,&#39;H&#39;,&#39;C&#39;,&#39;D&#39;,&#39;J&#39; &#125;;&#x2F;&#x2F;牌的编号与花色的对应关系</span><br><span class="line">int start[N + 1], _end[N + 1], _next[N + 1];&#x2F;&#x2F;next存储调整后的相对位置</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;输入</span><br><span class="line">	for (int i &#x3D; 1;i &lt;&#x3D; N;i++) &#123;</span><br><span class="line">		start[i] &#x3D; i;&#x2F;&#x2F;初始化牌的编码</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;_next[i]);&#x2F;&#x2F;输入每个位置上的牌在操作后的位置</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int j &#x3D; 0;j &lt; n;j++) &#123;</span><br><span class="line">		for (int i &#x3D; 1;i &lt;&#x3D; N;i++)</span><br><span class="line">			_end[_next[i]] &#x3D; start[i];&#x2F;&#x2F;把第i个位置上的牌的编号存于next[i]</span><br><span class="line">		for (int i &#x3D; 1;i &lt;&#x3D; N;i++)</span><br><span class="line">			start[i] &#x3D; _end[i];&#x2F;&#x2F;把end数组赋值给start数组供下次使用</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 1;i &lt;&#x3D; N;i++) &#123;</span><br><span class="line">		start[i]--;</span><br><span class="line">		printf(&quot;%c%d&quot;, mp[start[i] &#x2F; 13], start[i] % 13 + 1);</span><br><span class="line">		if (i !&#x3D; N)</span><br><span class="line">			printf(&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1049-Counting Ones</title>
    <url>/2020/03/25/PAT-A-1049-Counting-Ones/</url>
    <content><![CDATA[<p>The task is simple: given any positive integer <em>N</em>, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to <em>N</em>. For example, given <em>N</em> being 12, there are five 1’s in 1, 10, 11, and 12.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives the positive <em>N</em> (≤230).</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the number of 1’s in one line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,a&#x3D;1,ans&#x3D;0;</span><br><span class="line">	&#x2F;&#x2F;从低位到高位遍历一个数，将其分为left now right三个部分，并讨论now&#x3D;0、1、大于1三种情况下的结果</span><br><span class="line">    int left,now,right;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从低位到高位遍历每个数</span><br><span class="line">    while(n&#x2F;a!&#x3D;0)&#123;</span><br><span class="line">        left &#x3D; n&#x2F;(a*10);</span><br><span class="line">        now &#x3D; n&#x2F;a%10;</span><br><span class="line">        &#x2F;&#x2F;任何数取余1都为0</span><br><span class="line">        right &#x3D; n%a;</span><br><span class="line">        if(now&#x3D;&#x3D;0)</span><br><span class="line">            ans+&#x3D;left*a;</span><br><span class="line">        else if(now&#x3D;&#x3D;1)</span><br><span class="line">            ans+&#x3D;left*a+right+1;</span><br><span class="line">        else</span><br><span class="line">            ans+&#x3D;(left+1)*a;</span><br><span class="line">        a*&#x3D;10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1065 A+B and C</title>
    <url>/2020/03/16/PAT-A-1065-A-B-and-C/</url>
    <content><![CDATA[<p>Given three integers <em>A</em>, <em>B</em> and <em>C</em> in [−2^63,2^63], you are supposed to tell whether <em>A</em>+<em>B</em>&gt;<em>C</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>The first line of the input gives the positive number of test cases, <em>T</em> (≤10). Then <em>T</em> test cases follow, each consists of a single line containing three integers <em>A</em>, <em>B</em> and <em>C</em>, separated by single spaces.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line <code>Case #X: true</code> if <em>A</em>+<em>B</em>&gt;<em>C</em>, or <code>Case #X: false</code> otherwise, where <em>X</em> is the case number (starting from 1).</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">9223372036854775807 -9223372036854775808 0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: false</span><br><span class="line">Case #2: true</span><br><span class="line">Case #3: false</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,count&#x3D;1;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    LL a,b,c;</span><br><span class="line">    bool flag&#x3D;false;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        LL res &#x3D;a+b;</span><br><span class="line">        &#x2F;&#x2F;若两个数都为正，结果为负则为溢出，两数之和必定大于c；下面同理</span><br><span class="line">        if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;res&lt;0)flag&#x3D;true;&#x2F;&#x2F;正溢出</span><br><span class="line">        else if(a&lt;0&amp;&amp;b&lt;0&amp;&amp;res&gt;&#x3D;0)flag&#x3D;false;&#x2F;&#x2F;注意负溢出包括0</span><br><span class="line">        else if(res&gt;c)flag &#x3D;true;</span><br><span class="line">        else flag &#x3D;false;</span><br><span class="line">        </span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            &#x2F;&#x2F;a+b&gt;c</span><br><span class="line">            printf(&quot;Case #%d: true\n&quot;,count++);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             &#x2F;&#x2F;a+b&lt;c</span><br><span class="line">            printf(&quot;Case #%d: false\n&quot;,count++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1051-Pop Sequence</title>
    <url>/2020/03/30/PAT-A-1051-Pop-Sequence/</url>
    <content><![CDATA[<p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：用栈来实际模拟出栈序列，关键是要注意栈的大小限制和控制出栈的while循环</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int M,N,K;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;M,&amp;N,&amp;K);</span><br><span class="line">    stack&lt;int&gt; stk;</span><br><span class="line">    int *nums &#x3D;new int[N];</span><br><span class="line">    for(int i&#x3D;0;i&lt;K;i++)&#123;</span><br><span class="line">        while(!stk.empty())</span><br><span class="line">            stk.pop();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;读入N个数   </span><br><span class="line">        for(int j&#x3D;0;j&lt;N;j++)</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;nums[j]);</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F;比较指针</span><br><span class="line">        int point&#x3D;0;bool flag &#x3D;true;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">            stk.push(i);</span><br><span class="line">            if((int)stk.size()&gt;M)&#123;</span><br><span class="line">                flag&#x3D;false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            while(!stk.empty()&amp;&amp;nums[point]&#x3D;&#x3D;stk.top())&#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                point++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(stk.empty()&amp;&amp;flag)</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        else    </span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>栈的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1046 Shortest Distance</title>
    <url>/2020/03/16/PAT-A-1046-Shortest-Distance/</url>
    <content><![CDATA[<p>The task is really simple: given <em>N</em> exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer <em>N</em> (in [3,105]), followed by <em>N</em> integer distances <em>D</em>1 <em>D</em>2 ⋯ <em>D**N</em>, where <em>D**i</em> is the distance between the <em>i</em>-th and the (<em>i</em>+1)-st exits, and <em>D**N</em> is between the <em>N</em>-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer <em>M</em> (≤104), with <em>M</em> lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to <em>N</em>. It is guaranteed that the total round trip distance is no more than 107.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print your results in <em>M</em> lines, each contains the shortest distance between the corresponding given pair of exits.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1 2 4 14 9</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int *dis &#x3D; new int[n+1];&#x2F;&#x2F;存放1号顶点到i号顶点的距离</span><br><span class="line">    int *A &#x3D; new int[n+1];&#x2F;&#x2F;存放输入的边</span><br><span class="line">    int sum;&#x2F;&#x2F;存储总的距离</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;A[i]);</span><br><span class="line">        sum+&#x3D;A[i];</span><br><span class="line">        dis[i]&#x3D;sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ans;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;ans);</span><br><span class="line">    int v1,v2,distance;</span><br><span class="line">    while(ans--)&#123;</span><br><span class="line">        &#x2F;&#x2F;输入顶点v1和V2</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;v1,&amp;v2);</span><br><span class="line">        if(v1&gt;v2)swap(v1,v2);</span><br><span class="line">        int temp &#x3D; dis[v2-1]-dis[v1-1];</span><br><span class="line">        printf(&quot;%d\n&quot;,min(temp,sum-temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1058-A+B in Hogwarts</title>
    <url>/2020/03/19/PAT-A-1058-A-B-in-Hogwarts/</url>
    <content><![CDATA[<p>If you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute <em>A</em>+<em>B</em> where <em>A</em> and <em>B</em> are given in the standard form of <code>Galleon.Sickle.Knut</code> (<code>Galleon</code> is an integer in [0,107], <code>Sickle</code> is an integer in [0, 17), and <code>Knut</code> is an integer in [0, 29)).</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which occupies a line with <em>A</em> and <em>B</em> in the standard form, separated by one space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case you should output the sum of <em>A</em> and <em>B</em> in one line, with the same format as the input.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.2.1 10.16.27</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14.1.28</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;1：17  1：29</span><br><span class="line">	int galleon,sickle,knut,_galleon,_sickle,_knut;</span><br><span class="line">	scanf(&quot;%d.%d.%d %d.%d.%d.&quot;,&amp;galleon,&amp;sickle,&amp;knut,&amp;_galleon,&amp;_sickle,&amp;_knut);</span><br><span class="line"></span><br><span class="line">    int g,s,h;</span><br><span class="line">    int carry&#x3D;0;&#x2F;&#x2F;进位</span><br><span class="line">    h&#x3D;(knut+_knut)%29;</span><br><span class="line">    carry&#x3D;(knut+_knut)&#x2F;29;</span><br><span class="line">    s&#x3D;(sickle+_sickle+carry)%17;</span><br><span class="line">    carry&#x3D;(sickle+_sickle+carry)&#x2F;17;</span><br><span class="line">    g&#x3D;galleon+_galleon+carry;   </span><br><span class="line"></span><br><span class="line">    printf(&quot;%d.%d.%lld&quot;,g,s,h);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1069-he Black Hole of Numbers</title>
    <url>/2020/03/22/PAT-A-1069-he-Black-Hole-of-Numbers/</url>
    <content><![CDATA[<p>For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number <code>6174</code> – the <strong>black hole</strong> of 4-digit numbers. This number is named Kaprekar Constant.</p>
<p>For example, start from <code>6767</code>, we’ll get:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7766 - 6677 &#x3D; 1089</span><br><span class="line">9810 - 0189 &#x3D; 9621</span><br><span class="line">9621 - 1269 &#x3D; 8352</span><br><span class="line">8532 - 2358 &#x3D; 6174</span><br><span class="line">7641 - 1467 &#x3D; 6174</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives a positive integer <em>N</em> in the range (0,104).</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>If all the 4 digits of <em>N</em> are the same, print in one line the equation <code>N - N = 0000</code>. Else print each step of calculation in a line until <code>6174</code> comes out as the difference. All the numbers must be printed as 4-digit numbers.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6767</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7766 - 6677 &#x3D; 1089</span><br><span class="line">9810 - 0189 &#x3D; 9621</span><br><span class="line">9621 - 1269 &#x3D; 8352</span><br><span class="line">8532 - 2358 &#x3D; 6174</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2222</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2222 - 2222 &#x3D; 0000</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sort默认是递增，因此只需要写一个递减</span><br><span class="line">bool cmp_desc(int a,int b)&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;数组作为参数传递时：在函数中对数组元素的修改就等同于对原数组元素的修改</span><br><span class="line">&#x2F;&#x2F;数组可作为参数但不能作为返回值</span><br><span class="line">&#x2F;&#x2F;将数组转为数字法1</span><br><span class="line">int to_num_1(int num[])&#123;</span><br><span class="line">    int res&#x3D;0,i&#x3D;4,product&#x3D;1;</span><br><span class="line">    for(i&#x3D;3;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">        res+&#x3D;num[i]*product;</span><br><span class="line">        product*&#x3D;10;</span><br><span class="line">    &#125; </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将数组转为数字法2</span><br><span class="line">int to_num_2(int num[])&#123;</span><br><span class="line">    int res&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;4;i++)</span><br><span class="line">        res&#x3D;res*10+num[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将数字转为数组</span><br><span class="line">void to_arr(int num,int res[])&#123;</span><br><span class="line">    for(int i&#x3D;3;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">        res[i]&#x3D;num%10;</span><br><span class="line">        num&#x2F;&#x3D;10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,MIN,MAX;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int num[4];</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        to_arr(n,num);</span><br><span class="line">        sort(num,num+4);&#x2F;&#x2F;递增排序</span><br><span class="line">        MIN &#x3D; to_num_1(num);</span><br><span class="line">        sort(num,num+4,cmp_desc);&#x2F;&#x2F;递减排序</span><br><span class="line">        MAX &#x3D; to_num_1(num);</span><br><span class="line">        n&#x3D;MAX-MIN;</span><br><span class="line">        printf(&quot;%04d - %04d &#x3D; %04d\n&quot;,MAX,MIN,n);</span><br><span class="line">        &#x2F;&#x2F;循环出口</span><br><span class="line">        if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;6174)break;</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1081-Rational Sum</title>
    <url>/2020/03/25/PAT-A-1081-Rational-Sum/</url>
    <content><![CDATA[<p>Given <em>N</em> rational numbers in the form <code>numerator/denominator</code>, you are supposed to calculate their sum.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a positive integer <em>N</em> (≤100), followed in the next line <em>N</em> rational numbers <code>a1/b1 a2/b2 ...</code> where all the numerators and denominators are in the range of <strong>long int</strong>. If there is a negative number, then the sign must appear in front of the numerator.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output the sum in the simplest form <code>integer numerator/denominator</code> where <code>integer</code> is the integer part of the sum, <code>numerator</code> &lt; <code>denominator</code>, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2&#x2F;5 4&#x2F;15 1&#x2F;30 -2&#x2F;60 8&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 1&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4&#x2F;3 2&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input 3:"></a>Sample Input 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1&#x2F;3 -1&#x2F;6 1&#x2F;8</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output 3:"></a>Sample Output 3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7&#x2F;24</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return !b? a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Fraction&#123;</span><br><span class="line">    ll up,down;&#x2F;&#x2F;分子和分母</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;化简</span><br><span class="line">void reduction(Fraction&amp; f1)&#123;</span><br><span class="line">    &#x2F;&#x2F;正负的化简</span><br><span class="line">    if(f1.down&lt;0)&#123;</span><br><span class="line">        f1.up&#x3D;-f1.up;</span><br><span class="line">        f1.down&#x3D;-f1.down;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;为0的化简</span><br><span class="line">    if(f1.up&#x3D;&#x3D;0)</span><br><span class="line">        f1.down&#x3D;1;</span><br><span class="line">    else&#123;</span><br><span class="line">        &#x2F;&#x2F;约去公约数</span><br><span class="line">        ll d &#x3D; gcd(abs(f1.up),abs(f1.down));</span><br><span class="line">        f1.up&#x2F;&#x3D;d;</span><br><span class="line">        f1.down&#x2F;&#x3D;d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    f1.up&#x3D;f1.up*f2.down+f1.down*f2.up;</span><br><span class="line">    f1.down&#x3D;f1.down*f2.down;</span><br><span class="line">    reduction(f1);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showFraction(Fraction&amp; f1)&#123;</span><br><span class="line">    if(f1.down&#x3D;&#x3D;1)</span><br><span class="line">        printf(&quot;%lld\n&quot;,f1.up);</span><br><span class="line">    else if(abs(f1.up)&gt;f1.down)&#x2F;&#x2F;假分式</span><br><span class="line">        printf(&quot;%lld %lld&#x2F;%lld\n&quot;,f1.up&#x2F;f1.down,abs(f1.up)%f1.down,f1.down);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%lld&#x2F;%lld\n&quot;,f1.up,f1.down);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    Fraction sum,temp;</span><br><span class="line">    sum.up&#x3D;0,sum.down&#x3D;1;</span><br><span class="line"></span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%lld&#x2F;%lld&quot;,&amp;temp.up,&amp;temp.down);</span><br><span class="line">        add(sum,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showFraction(sum);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1073-Scientific Notation</title>
    <url>/2020/03/28/PAT-A-1073-Scientific-Notation/</url>
    <content><![CDATA[<p>Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9]<code>.</code>[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent’s signs are always provided even when they are positive.</p>
<p>Now given a real number <em>A</em> in scientific notation, you are supposed to print <em>A</em> in the conventional notation while keeping all the significant figures.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input contains one test case. For each case, there is one line containing the real number <em>A</em> in scientific notation. The number is no more than 9999 bytes in length and the exponent’s absolute value is no more than 9999.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the input number <em>A</em> in the conventional notation, with all the significant figures kept, including trailing zeros.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+1.23400E-03</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.00123400</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1.2E+10</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-12000000000</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	char str[10000];</span><br><span class="line">	scanf(&quot;%s&quot;, str);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;E的位置</span><br><span class="line">	int ePos &#x3D; 0;</span><br><span class="line">	while (str[ePos] !&#x3D; &#39;E&#39;)</span><br><span class="line">		ePos++;</span><br><span class="line"></span><br><span class="line">	int len &#x3D; strlen(str);</span><br><span class="line">	if (str[0] &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">		printf(&quot;-&quot;);</span><br><span class="line"></span><br><span class="line">	int exp &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; ePos + 2;i &lt; len;i++)</span><br><span class="line">		exp &#x3D; exp * 10 + (str[i] - &#39;0&#39;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;特判指数为0</span><br><span class="line">	if (exp &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		for (int i &#x3D; 1;i &lt; ePos;i++)</span><br><span class="line">			printf(&quot;%c&quot;, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (str[ePos + 1] &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">		printf(&quot;0.&quot;);</span><br><span class="line">		&#x2F;&#x2F;添加的0的个数为exp-1</span><br><span class="line">		for (int i &#x3D; 0;i &lt; exp - 1;i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line">		printf(&quot;%c&quot;,str[1]);</span><br><span class="line">		for (int i &#x3D; 3;i &lt; ePos;i++)</span><br><span class="line">			printf(&quot;%c&quot;, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int i &#x3D; 1;i &lt; ePos;i++) &#123;</span><br><span class="line">			if (str[i] &#x3D;&#x3D; &#39;.&#39;)continue;</span><br><span class="line">			printf(&quot;%c&quot;, str[i]);</span><br><span class="line">			&#x2F;&#x2F;i&#x3D;小数点右移位数+2，且移位后的位置不在字符串的最后一个位置</span><br><span class="line">			if (i &#x3D;&#x3D; exp + 2 &amp;&amp; ePos - 3 !&#x3D; exp)</span><br><span class="line">				printf(&quot;.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;添加剩下的0</span><br><span class="line">		for (int i &#x3D; 0;i &lt; exp - ePos + 3;i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT-A(20)</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1006 Sign In and Sign Out</title>
    <url>/2020/03/18/PAT-A-1006-Sign-In-and-Sign-Out/</url>
    <content><![CDATA[<p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer <em>M</em>, which is the total number of records, followed by <em>M</em> lines, each in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ID_number Sign_in_time Sign_out_time</span><br></pre></td></tr></table></figure>

<p>where times are given in the format <code>HH:MM:SS</code>, and <code>ID_number</code> is a string with no more than 15 characters.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>
<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">CS301111 15:30:28 17:00:10</span><br><span class="line">SC3021234 08:00:00 11:25:25</span><br><span class="line">CS301133 21:45:00 21:58:40</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SC3021234 CS301133</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string first_per;&#x2F;&#x2F;存储第一个人的id</span><br><span class="line">string last_per;&#x2F;&#x2F;存储第二个人的id</span><br><span class="line">string firsttime &#x3D; &quot;23:59:59&quot;;</span><br><span class="line">string lasttime &#x3D; &quot;00:00:00&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找到一天中谁开的门，谁锁的门</span><br><span class="line">void _1006() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;&#x2F;&#x2F;总人数</span><br><span class="line">	string id, intime, outtime;</span><br><span class="line">	&#x2F;&#x2F;&#x2F;&#x2F;char id[20],intime[20],outtime[20];</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		cin &gt;&gt; id &gt;&gt; intime &gt;&gt; outtime;</span><br><span class="line">		&#x2F;&#x2F;	scanf(&quot;%s%s%s&quot;, id, intime, outtime);</span><br><span class="line">		if (intime &lt; firsttime) &#123;</span><br><span class="line">			firsttime &#x3D; intime;</span><br><span class="line">			first_per &#x3D; id;</span><br><span class="line">		&#125;</span><br><span class="line">		if (outtime &gt; lasttime) &#123;</span><br><span class="line">			lasttime &#x3D; outtime;</span><br><span class="line">			last_per &#x3D; id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; first_per + &quot; &quot; + last_per &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>查找元素</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1086-Tree Traversals Again</title>
    <url>/2020/05/13/PAT-A-1086-Tree-Traversals-Again/</url>
    <content><![CDATA[<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img src="https://images.ptausercontent.com/30" alt="img"><br>Figure 1</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int preSeq[30], inOrder[30], preIdx &#x3D; 0, inIdx &#x3D; 0;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int data;</span><br><span class="line">	node* lc, * rc;</span><br><span class="line">	node(int _data) :data(_data), lc(0), rc(0) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* buildTree(int preL, int preR, int inL, int inR) &#123;</span><br><span class="line">	if (preL &gt; preR)</span><br><span class="line">		return 0;</span><br><span class="line">	node* root &#x3D; new node(preSeq[preL]);</span><br><span class="line">	int i;</span><br><span class="line">	for (i &#x3D; inL;i &lt;&#x3D; inR;i++) &#123;</span><br><span class="line">		if (preSeq[preL] &#x3D;&#x3D; inOrder[i])</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	int lnum &#x3D; i - inL;&#x2F;&#x2F;不包括自己，左子树的节点总和</span><br><span class="line">	root-&gt;lc &#x3D; buildTree(preL + 1, preL + lnum, inL, i - 1);</span><br><span class="line">	root-&gt;rc &#x3D; buildTree(preL + 1+ lnum, preR, i + 1, inR);</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int current &#x3D; 0;</span><br><span class="line">void postOrder(node* root) &#123;</span><br><span class="line">	if (root !&#x3D; 0) &#123;</span><br><span class="line">		postOrder(root-&gt;lc);</span><br><span class="line">		postOrder(root-&gt;rc);</span><br><span class="line">		if (current++ &#x3D;&#x3D; 0)</span><br><span class="line">			printf(&quot;%d&quot;, root-&gt;data);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot; %d&quot;, root-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	&#x2F;&#x2F;每次访问一个节点就入栈，相当于先序遍历</span><br><span class="line">	&#x2F;&#x2F;而pop是按照左右根的顺序，相当于中序遍历</span><br><span class="line">	stack&lt;int&gt; stk;</span><br><span class="line">	string temp;</span><br><span class="line">	int num;</span><br><span class="line">	&#x2F;&#x2F;先获得先序和中序序列</span><br><span class="line">	for (int i &#x3D; 0;i &lt; 2 * n;i++) &#123;</span><br><span class="line">		cin &gt;&gt; temp;</span><br><span class="line">		if (temp &#x3D;&#x3D; &quot;Push&quot;) &#123;</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			stk.push(num);</span><br><span class="line">			preSeq[preIdx++] &#x3D; num;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			inOrder[inIdx++] &#x3D; stk.top();</span><br><span class="line">			stk.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node* root &#x3D; buildTree(0, preIdx - 1, 0, inIdx - 1);</span><br><span class="line">	postOrder(root);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT-A(25)</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1078-Hashing</title>
    <url>/2020/04/02/PAT-A-1078-Hashing/</url>
    <content><![CDATA[<p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be <em>H</em>(<em>k<strong>e</strong>y</em>)=<em>k<strong>e</strong>y</em>%<em>T<strong>S</strong>i<strong>z</strong>e</em> where <em>T<strong>S</strong>i<strong>z</strong>e</em> is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.</p>
<p>Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains two positive numbers: <em>M<strong>S</strong>i<strong>z</strong>e</em> (≤104) and <em>N</em> (≤<em>M<strong>S</strong>i<strong>z</strong>e</em>) which are the user-defined table size and the number of input numbers, respectively. Then <em>N</em> distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-“ instead.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">10 6 4 15</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 4 -</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 11111;</span><br><span class="line">bool isPrime(int n) &#123;</span><br><span class="line">    if(n &lt;&#x3D; 1) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i &#x3D; 2; i * i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        if(n % i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">bool hashTable[maxn] &#x3D; &#123;0&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, tsize, a;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;tsize, &amp;n);</span><br><span class="line">    while(isPrime(tsize) &#x3D;&#x3D; false) &#123;</span><br><span class="line">        tsize++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">        int m &#x3D; a % tsize;</span><br><span class="line">        if(hashTable[m] &#x3D;&#x3D; false) &#123;</span><br><span class="line">            hashTable[m] &#x3D; true;</span><br><span class="line">            if(i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                printf(&quot;%d&quot;, m);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                printf(&quot; %d&quot;, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int step;</span><br><span class="line">            for(step &#x3D; 1; step &lt; tsize; step++) &#123;</span><br><span class="line">                m &#x3D; (a + step * step) % tsize;</span><br><span class="line">                if(hashTable[m] &#x3D;&#x3D; false) &#123;</span><br><span class="line">                    hashTable[m] &#x3D; true;</span><br><span class="line">                    if(i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        printf(&quot;%d&quot;, m);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        printf(&quot; %d&quot;, m);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(step &gt;&#x3D; tsize) &#123;</span><br><span class="line">                if(i &gt; 0) &#123;</span><br><span class="line">                    printf(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;-&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>PAT-A(25)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1001 害死人不偿命的(3n+1)猜想</title>
    <url>/2020/03/11/PAT-B-1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3/</url>
    <content><![CDATA[<p>卡拉兹(Callatz)猜想：</p>
<p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>=1？</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>n</em> 计算到 1 需要的步数。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,count&#x3D;0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);	</span><br><span class="line">	</span><br><span class="line">	while(n!&#x3D;1)&#123;		</span><br><span class="line">		if(!(n%2))&#123;</span><br><span class="line">			&#x2F;&#x2F;偶数</span><br><span class="line">			n&#x2F;&#x3D;2;</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">			&#x2F;&#x2F;奇数 </span><br><span class="line">			n&#x3D;(3*n+1)&#x2F;2;</span><br><span class="line">		&#125; </span><br><span class="line">		count++;</span><br><span class="line">	&#125; 		</span><br><span class="line">	printf(&quot;%d&quot;,count);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1103-Integer Factorization</title>
    <url>/2020/03/30/PAT-A-1103-Integer-Factorization/</url>
    <content><![CDATA[<p>The <em>K</em>−<em>P</em> factorization of a positive integer <em>N</em> is to write <em>N</em> as the sum of the <em>P</em>-th power of <em>K</em> positive integers. You are supposed to write a program to find the <em>K</em>−<em>P</em> factorization of <em>N</em> for any positive integers <em>N</em>, <em>K</em> and <em>P</em>.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case which gives in a line the three positive integers <em>N</em> (≤400), <em>K</em> (≤<em>N</em>) and <em>P</em> (1&lt;<em>P</em>≤7). The numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, if the solution exists, output in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N &#x3D; n[1]^P + ... n[K]^P</span><br></pre></td></tr></table></figure>

<p>where <code>n[i]</code> (<code>i</code> = 1, …, <code>K</code>) is the <code>i</code>-th factor. All the factors must be printed in non-increasing order.</p>
<p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122+42+22+22+12, or 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence { <em>a</em>1,<em>a</em>2,⋯,<em>a**K</em> } is said to be <strong>larger</strong> than { <em>b</em>1,<em>b</em>2,⋯,<em>b**K</em> } if there exists 1≤<em>L</em>≤<em>K</em> such that <em>a**i</em>=<em>b**i</em> for <em>i</em>&lt;<em>L</em> and <em>a**L</em>&gt;<em>b**L</em>.</p>
<p>If there is no solution, simple output <code>Impossible</code>.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">169 5 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">169 &#x3D; 6^2 + 6^2 + 6^2 + 6^2 + 5^2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">169 167 3</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;大数处理会出现段错误，不完全正确，待更新</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; res;</span><br><span class="line">int index,_factsum&#x3D;0;</span><br><span class="line">bool flag &#x3D; false;&#x2F;&#x2F;表示还没有找到结果</span><br><span class="line">&#x2F;&#x2F;计算幂次数</span><br><span class="line">int caculate(int num, int exp) &#123;</span><br><span class="line">	int fact &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; exp;i++)</span><br><span class="line">		fact *&#x3D; num;</span><br><span class="line">	return fact;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool compareFactors(vector&lt;int&gt;&amp; factors) &#123;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; factors.size();i++) &#123;</span><br><span class="line">		if (factors[i] &#x3D;&#x3D; res[i])</span><br><span class="line">			continue;</span><br><span class="line">		else if (factors[i] &gt; res[i])</span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int start, int n, int sum, int exp, vector&lt;int&gt;&amp; factors,int factsum) &#123;</span><br><span class="line">	if (sum &#x3D;&#x3D; 0 &amp;&amp; n&gt;0)</span><br><span class="line">		return;</span><br><span class="line">	if (sum &#x3D;&#x3D; 0 &amp;&amp; n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		if (flag) &#123;</span><br><span class="line">			if(factsum &lt; _factsum)</span><br><span class="line">				return;</span><br><span class="line">			&#x2F;&#x2F;比较数组的因子大小</span><br><span class="line">			if (factsum&#x3D;&#x3D;_factsum&amp;&amp;!compareFactors(factors))</span><br><span class="line">				return;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		flag &#x3D; true;</span><br><span class="line">		res &#x3D; factors;</span><br><span class="line">		_factsum &#x3D; factsum;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; start;i &gt; 0;i--) &#123;</span><br><span class="line">		&#x2F;&#x2F;过滤不满足条件的选项</span><br><span class="line">		int num &#x3D; caculate(i, exp);</span><br><span class="line">		if ((sum - num) &lt; 0)</span><br><span class="line">			continue;</span><br><span class="line">		&#x2F;&#x2F;做选择</span><br><span class="line">		factors.push_back(i);</span><br><span class="line">		DFS(i, n - 1, sum - num, exp, factors, factsum+i);</span><br><span class="line">		&#x2F;&#x2F;撤销选择</span><br><span class="line">		factors.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n, m, exp;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;exp);</span><br><span class="line">	index &#x3D; m;</span><br><span class="line">	vector&lt;int&gt; factors;</span><br><span class="line">	DFS(n,m, n, exp, factors,0);</span><br><span class="line">	if (res.size() &gt; 0) &#123;</span><br><span class="line">		printf(&quot;%d &#x3D; &quot;, n);</span><br><span class="line">		for (int i &#x3D; 0;i &lt; (int)res.size();i++) &#123;</span><br><span class="line">			printf(&quot;%d^%d&quot;, res[i], exp);</span><br><span class="line">			if (i !&#x3D; res.size() - 1)</span><br><span class="line">				printf(&quot; + &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;Impossible\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>PAT(30)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1002-写出这个数</title>
    <url>/2020/03/21/PAT-B-1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10100。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234567890987654321123456789</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yi san wu</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;输入处理 </span><br><span class="line">    char num[101];</span><br><span class="line">	</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int i;</span><br><span class="line">    if(scanf(&quot;%s&quot;,num)!&#x3D;EOF) &#123;</span><br><span class="line">        for(i&#x3D;0;num[i]!&#x3D;&#39;\0&#39;;i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;将数字字符转为数字有两种方法：</span><br><span class="line">            &#x2F;&#x2F;第一种：用数字字符出减去&#39;0&#39;即&#39;1&#39;-&#39;0&#39;(它俩是用ASCII码相减的即49-48&#x3D;1)</span><br><span class="line">            &#x2F;&#x2F;第二种：用数字字符出减去48（48是‘0’的ASCII码）即&#39;1&#39;-48&#x3D;1</span><br><span class="line">            sum +&#x3D; (num[i]-&#39;0&#39;); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    char out[101];</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;将计算的和赋给字符串</span><br><span class="line">	sprintf(out, &quot;%d&quot; , sum);</span><br><span class="line">	</span><br><span class="line">	for(i&#x3D;0;out[i]!&#x3D;&#39;\0&#39;;i++) &#123;</span><br><span class="line">	    switch(out[i])&#123;</span><br><span class="line">			case &#39;0&#39;:</span><br><span class="line">				printf(&quot;ling&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;1&#39;:</span><br><span class="line">				printf(&quot;yi&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;2&#39;:</span><br><span class="line">				printf(&quot;er&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;3&#39;:</span><br><span class="line">				printf(&quot;san&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;4&#39;:</span><br><span class="line">				printf(&quot;si&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;5&#39;:</span><br><span class="line">				printf(&quot;wu&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;6&#39;:</span><br><span class="line">				printf(&quot;liu&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;7&#39;:</span><br><span class="line">				printf(&quot;qi&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;8&#39;:</span><br><span class="line">				printf(&quot;ba&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case &#39;9&#39;:</span><br><span class="line">				printf(&quot;jiu&quot;);</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(out[i+1]!&#x3D;&#39;\0&#39;)&#123;</span><br><span class="line">			printf(&quot; &quot;); </span><br><span class="line">		&#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1006-换个格式输出整数</title>
    <url>/2020/03/19/PAT-B-1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>让我们用字母 <code>B</code> 来表示“百”、字母 <code>S</code> 表示“十”，用 <code>12...n</code> 来表示不为零的个位数字 <code>n</code>（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 <code>234</code> 应该被输出为 <code>BBSSS1234</code>，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，给出正整数 <em>n</em>（&lt;1000）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，用规定的格式输出 <em>n</em>。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">234</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BBSSS1234</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SS123</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int num;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line"></span><br><span class="line">    int n&#x3D;num%10;</span><br><span class="line">    num&#x2F;&#x3D;10;</span><br><span class="line">    int s&#x3D;num%10;</span><br><span class="line">    num&#x2F;&#x3D;10;</span><br><span class="line">    int b&#x3D;num%10;</span><br><span class="line">    </span><br><span class="line">    while(b--)</span><br><span class="line">        printf(&quot;B&quot;);</span><br><span class="line">    while(s--)</span><br><span class="line">        printf(&quot;S&quot;);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        printf(&quot;%d&quot;,i);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1004-成绩排名</title>
    <url>/2020/03/18/PAT-B-1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/</url>
    <content><![CDATA[<p>读入 <em>n</em>（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第 1 行：正整数 n</span><br><span class="line">第 2 行：第 1 个学生的姓名 学号 成绩</span><br><span class="line">第 3 行：第 2 个学生的姓名 学号 成绩</span><br><span class="line">  ... ... ...</span><br><span class="line">第 n+1 行：第 n 个学生的姓名 学号 成绩</span><br></pre></td></tr></table></figure>

<p>其中<code>姓名</code>和<code>学号</code>均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Joe Math990112 89</span><br><span class="line">Mike CS991301 100</span><br><span class="line">Mary EE990830 95</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mike CS991301</span><br><span class="line">Joe Math990112</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct student &#123;</span><br><span class="line">	char name[15];</span><br><span class="line">	char id[15];</span><br><span class="line">	int grade;</span><br><span class="line">&#125;temp, s_max,s_min;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	s_max.grade &#x3D; -1;</span><br><span class="line">	s_min.grade &#x3D; 101;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		scanf(&quot;%s%s%d&quot;, temp.name, temp.id, &amp;temp.grade);</span><br><span class="line">		if (temp.grade &gt; s_max.grade) </span><br><span class="line">			s_max &#x3D; temp;</span><br><span class="line">		if (temp.grade &lt; s_min.grade) </span><br><span class="line">			s_min &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%s %s\n&quot;, s_max.name, s_max.id);</span><br><span class="line">	printf(&quot;%s %s\n&quot;, s_min.name, s_min.id);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>查找元素</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-A-1088-Rational Arithmetic</title>
    <url>/2020/03/25/PAT-A-1088-Rational-Arithmetic/</url>
    <content><![CDATA[<p>or two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case, which gives in one line the two rational numbers in the format <code>a1/b1 a2/b2</code>. The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is <code>number1 operator number2 = result</code>. Notice that all the rational numbers must be in their simplest form <code>k a/b</code>, where <code>k</code> is the integer part, and <code>a/b</code> is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output <code>Inf</code> as the result. It is guaranteed that all the output integers are in the range of <strong>long int</strong>.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2&#x2F;3 -4&#x2F;2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2&#x2F;3 + (-2) &#x3D; (-1 1&#x2F;3)</span><br><span class="line">2&#x2F;3 - (-2) &#x3D; 2 2&#x2F;3</span><br><span class="line">2&#x2F;3 * (-2) &#x3D; (-1 1&#x2F;3)</span><br><span class="line">2&#x2F;3 &#x2F; (-2) &#x3D; (-1&#x2F;3)</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5&#x2F;3 0&#x2F;6</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2&#x2F;3 + 0 &#x3D; 1 2&#x2F;3</span><br><span class="line">1 2&#x2F;3 - 0 &#x3D; 1 2&#x2F;3</span><br><span class="line">1 2&#x2F;3 * 0 &#x3D; 0</span><br><span class="line">1 2&#x2F;3 &#x2F; 0 &#x3D; Inf</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return !b? a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Fraction&#123;</span><br><span class="line">    ll up,down;&#x2F;&#x2F;分子和分母</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;化简</span><br><span class="line">void reduction(Fraction&amp; f1)&#123;</span><br><span class="line">    &#x2F;&#x2F;正负的化简</span><br><span class="line">    if(f1.down&lt;0)&#123;</span><br><span class="line">        f1.up&#x3D;-f1.up;</span><br><span class="line">        f1.down&#x3D;-f1.down;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;为0的化简</span><br><span class="line">    if(f1.up&#x3D;&#x3D;0)</span><br><span class="line">        f1.down&#x3D;1;</span><br><span class="line">    else&#123;</span><br><span class="line">        &#x2F;&#x2F;约去公约数</span><br><span class="line">        ll d &#x3D; gcd(abs(f1.up),abs(f1.down));</span><br><span class="line">        f1.up&#x2F;&#x3D;d;</span><br><span class="line">        f1.down&#x2F;&#x3D;d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showFraction(Fraction&amp; f1)&#123;    </span><br><span class="line">    if (f1.up &lt; 0)</span><br><span class="line">		printf(&quot;(&quot;);</span><br><span class="line">	if (f1.down &#x3D;&#x3D; 1)</span><br><span class="line">		printf(&quot;%lld&quot;, f1.up);</span><br><span class="line">	else if (abs(f1.up) &gt; f1.down)&#x2F;&#x2F;假分式</span><br><span class="line">		printf(&quot;%lld %lld&#x2F;%lld&quot;, f1.up &#x2F; f1.down, abs(f1.up) % f1.down, f1.down);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;%lld&#x2F;%lld&quot;, f1.up, f1.down);</span><br><span class="line">	if (f1.up &lt; 0)</span><br><span class="line">		printf(&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;加</span><br><span class="line">void add(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; + &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.down+f1.down*f2.up;</span><br><span class="line">    res.down&#x3D;f1.down*f2.down;</span><br><span class="line">    reduction(res);</span><br><span class="line">    showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;减</span><br><span class="line">void difference(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; - &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.down-f1.down*f2.up;</span><br><span class="line">    res.down&#x3D;f1.down*f2.down;</span><br><span class="line">    reduction(res);</span><br><span class="line">    showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;乘</span><br><span class="line">void product(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; * &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.up;</span><br><span class="line">    res.down&#x3D;f1.down*f2.down;</span><br><span class="line">    reduction(res);</span><br><span class="line">    showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;除</span><br><span class="line">void quotient(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; &#x2F; &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.down;</span><br><span class="line">    res.down&#x3D;f1.down*f2.up;</span><br><span class="line">    reduction(res);</span><br><span class="line">    if(f2.up&#x3D;&#x3D;0)</span><br><span class="line">        printf(&quot;Inf&quot;);</span><br><span class="line">    else</span><br><span class="line">        showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Fraction f1,f2;</span><br><span class="line">	scanf(&quot;%lld&#x2F;%lld%lld&#x2F;%lld&quot;,&amp;f1.up,&amp;f1.down,&amp;f2.up,&amp;f2.down);</span><br><span class="line">    add(f1,f2);</span><br><span class="line">    difference(f1,f2);</span><br><span class="line">    product(f1,f2);</span><br><span class="line">    quotient(f1,f2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-A</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1007-素数对猜想</title>
    <url>/2020/03/26/PAT-B-1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/</url>
    <content><![CDATA[<p>让我们定义<em>d<strong>n<em>为：</em>d</strong>n</em>=<em>p**n</em>+1−<em>p<strong>n<em>，其中</em>p</strong>i<em>是第</em>i<em>个素数。显然有</em>d<em>1=1，且对于</em>n</em>&gt;1有<em>d*</em>n*是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p>
<p>现给定任意正整数<code>N</code>(&lt;105)，请计算不超过<code>N</code>的满足猜想的素数对的个数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出正整数<code>N</code>。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出不超过<code>N</code>的满足猜想的素数对的个数。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool isPrime(int n)&#123;</span><br><span class="line">    if(n&lt;&#x3D;1)return false;</span><br><span class="line">    int sqr&#x3D;(int)sqrt(1.0*n);</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;sqr;i++)</span><br><span class="line">        if(n%i&#x3D;&#x3D;0)return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,count&#x3D;0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;**关键思路：素数对一定是奇数对**</span><br><span class="line">    for(int i&#x3D;3;i+2&lt;&#x3D;n;i+&#x3D;2)</span><br><span class="line">        if(isPrime(i)&amp;&amp;isPrime(i+2))</span><br><span class="line">            count++;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1009-说反话</title>
    <url>/2020/03/21/PAT-B-1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/</url>
    <content><![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，输出倒序后的句子。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World Here I Come</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Come I Here World Hello</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	char str[90];</span><br><span class="line">	cin.getline(str, 90);</span><br><span class="line">	int len &#x3D; strlen(str);&#x2F;&#x2F;获取字符串的长度</span><br><span class="line"></span><br><span class="line">	char _str[90];</span><br><span class="line">	stack&lt;string&gt; stk;</span><br><span class="line">	string s;</span><br><span class="line">	int i,j &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;遍历字符串</span><br><span class="line">	for (i &#x3D; 0;i &lt; len;i++) &#123;</span><br><span class="line">		if (str[i] !&#x3D; &#39; &#39;)</span><br><span class="line">			_str[j++] &#x3D; str[i];</span><br><span class="line">		else &#123;</span><br><span class="line">			_str[j] &#x3D; &#39;\0&#39;;</span><br><span class="line">			s &#x3D; _str;</span><br><span class="line">			stk.push(s);</span><br><span class="line">			j &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i &#x3D;&#x3D; len - 1) &#123;</span><br><span class="line">			_str[j] &#x3D; &#39;\0&#39;;</span><br><span class="line">			s &#x3D; _str;</span><br><span class="line">			stk.push(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i &#x3D; stk.size();</span><br><span class="line">	for (j &#x3D; 0;j &lt; i;j++) &#123;</span><br><span class="line">		s &#x3D; stk.top();</span><br><span class="line">		stk.pop();</span><br><span class="line">		printf(&quot;%s&quot;, s.c_str());</span><br><span class="line">		if (j !&#x3D; i - 1)</span><br><span class="line">			printf(&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1008 数组元素循环右移问题</title>
    <url>/2020/03/11/PAT-B-1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一个数组<em>A</em>中存有<em>N</em>（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移<em>M</em>（≥0）个位置，即将<em>A</em>中的数据由（<em>A</em>0<em>A</em>1⋯<em>A*</em>N<em>−1）变换为（</em>A<strong>N<em>−</em>M<em>⋯</em>A</strong>N<em>−1</em>A<em>0</em>A<em>1⋯</em>A*<em>N</em>−<em>M</em>−1）（最后<em>M</em>个数循环移至最前面的<em>M</em>个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每个输入包含一个测试用例，第1行输入<em>N</em>（1≤<em>N</em>≤100）和<em>M</em>（≥0）；第2行输入<em>N</em>个整数，之间用空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出循环右移<em>M</em>位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 2</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6 1 2 3 4</span><br></pre></td></tr></table></figure>

<h3 id="数组平移问题分析"><a href="#数组平移问题分析" class="headerlink" title="数组平移问题分析"></a>数组平移问题分析</h3><ul>
<li><p>数组左移k位</p>
<blockquote>
<ol>
<li>将前k位反转，后k位反转</li>
<li>将整个数组反转</li>
</ol>
</blockquote>
</li>
<li><p>数组右移k位</p>
<blockquote>
<ol>
<li>将整个数组反转</li>
<li>将前k位反转，后k位反转</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;m可能比n大，因此对m先做一个优化，方便后面计算</span><br><span class="line">    m&#x3D;m%n;</span><br><span class="line">    int* arr &#x3D; new int[n];</span><br><span class="line">    int i,temp;</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">        arr[i]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;右移，先反转全部</span><br><span class="line">    reverse(arr,arr+n);</span><br><span class="line">    reverse(arr,arr+m);</span><br><span class="line">    reverse(arr+m,arr+n);</span><br><span class="line"></span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,arr[i]);</span><br><span class="line">        if(i!&#x3D;n-1)</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移动次数最少"><a href="#移动次数最少" class="headerlink" title="移动次数最少"></a>移动次数最少</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;为了避免有些数组在一轮移动之后就已经是最终数组而继续做无用的循环，如长度为8，右移3位。只需要轮迭代就已经完成全部元素的平移</span><br><span class="line">&#x2F;&#x2F;这里引出一个关键的知识点——最大公约数d</span><br><span class="line">&#x2F;&#x2F;整个循环的次数是从n-m号位开始枚举起始位直到到n-m+d-1位结束。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int n,int m)&#123;</span><br><span class="line">	&#x2F;&#x2F;当余数为0，返回n</span><br><span class="line">	if(m&#x3D;&#x3D;0)return n;</span><br><span class="line">	return gcd(m,n%m);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	int arr[110];</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">	</span><br><span class="line">	int temp,pos;</span><br><span class="line">	&#x2F;&#x2F;还是先修正m，因为m可能比n大</span><br><span class="line">    m&#x3D;m%n;</span><br><span class="line">    &#x2F;&#x2F;当有平移需求才平移，否则输出原数组</span><br><span class="line">   	if(m!&#x3D;0)&#123;</span><br><span class="line">   		int d&#x3D;gcd(n,m);</span><br><span class="line">   		for(int i&#x3D;n-m;i&lt;&#x3D;n-m+d-1;i++)&#123;</span><br><span class="line">   			temp&#x3D;arr[i];</span><br><span class="line">   			pos&#x3D;i;</span><br><span class="line">   			do&#123;</span><br><span class="line">   				&#x2F;&#x2F;计算当前位置前m位的索引</span><br><span class="line">   				int next &#x3D; (pos-m+n)%n;</span><br><span class="line">   				&#x2F;&#x2F;若计算的next为i，说明走到最后一步了，否则平移数组</span><br><span class="line">   				if(next!&#x3D;i)</span><br><span class="line">   					arr[pos]&#x3D;arr[next];</span><br><span class="line">   				else</span><br><span class="line">   					arr[pos]&#x3D;temp;</span><br><span class="line">   				pos&#x3D;next;</span><br><span class="line">   			&#125;while(pos!&#x3D;i)&#x2F;&#x2F;若pos&#x3D;i则说明已经迭代一轮了</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;最后输出结果数组</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,arr[i]);</span><br><span class="line">        if(i!&#x3D;n-1)</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1010 一元多项式求导</title>
    <url>/2020/03/16/PAT-B-1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<p>设计函数求一元多项式的导数。（注：<em>x*</em>n<em>（</em>n<em>为整数）的一阶导数为</em>n<strong>x</strong>n*−1。）</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 -5 2 6 1 -2 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12 3 -10 1 6 0</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a[1010] &#x3D; &#123;0&#125;;</span><br><span class="line">	int k,e,count&#x3D;0;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;k,&amp;e)!&#x3D;-1)</span><br><span class="line">        a[e]&#x3D;k;&#x2F;&#x2F;指数e位置存储系数k</span><br><span class="line"></span><br><span class="line">    a[0]&#x3D;0;&#x2F;&#x2F;常数项求导后为0</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;1000;i++)&#123;</span><br><span class="line">        a[i-1]&#x3D;a[i]*i;</span><br><span class="line">        a[i]&#x3D;0;&#x2F;&#x2F;求导后系数要清空，否则答案还会出错</span><br><span class="line">        if(a[i-1]!&#x3D;0)count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如果求导后没有项了，输出0 0</span><br><span class="line">    if(!count)</span><br><span class="line">        printf(&quot;0 0&quot;);</span><br><span class="line">    else&#123;</span><br><span class="line">        &#x2F;&#x2F;从高到底输出</span><br><span class="line">        for(int i&#x3D;1000;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            if(a[i]!&#x3D;0)&#123;</span><br><span class="line">                printf(&quot;%d %d&quot;,a[i],i);</span><br><span class="line">                count--;</span><br><span class="line">                if(count!&#x3D;0)</span><br><span class="line">                    printf(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1012 数字分类</title>
    <url>/2020/03/11/PAT-B-1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p>
<ul>
<li><em>A</em>1 = 能被 5 整除的数字中所有偶数的和；</li>
<li><em>A</em>2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 <em>n</em>1−<em>n</em>2+<em>n</em>3−<em>n</em>4⋯；</li>
<li><em>A</em>3 = 被 5 除后余 2 的数字的个数；</li>
<li><em>A</em>4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；</li>
<li><em>A</em>5 = 被 5 除后余 4 的数字中最大数字。</li>
</ul>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em>，随后给出 <em>N</em> 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对给定的 <em>N</em> 个正整数，按题目要求计算 <em>A</em>1~<em>A</em>5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>
<p>若其中某一类数字不存在，则在相应位置输出 <code>N</code>。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 1 2 3 4 5 6 7 8 9 10 20 16 18</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 11 2 9.7 9</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 1 2 4 5 6 7 9 16</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N 11 2 N 9</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意统计出现的个数</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int count,i,temp;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;count);</span><br><span class="line">    int A1&#x3D;0,A2&#x3D;0,A3&#x3D;0,A4&#x3D;0,A5&#x3D;0;</span><br><span class="line">    </span><br><span class="line">    int a1count&#x3D;0,a2count&#x3D;0,a4count&#x3D;0;</span><br><span class="line">    for(i&#x3D;0;i&lt;count;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">        if(temp%10&#x3D;&#x3D;0)&#123;</span><br><span class="line">            A1+&#x3D;temp;</span><br><span class="line">            a1count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(temp%5&#x3D;&#x3D;1)&#123;</span><br><span class="line">            if(a2count%2&#x3D;&#x3D;0)</span><br><span class="line">                A2+&#x3D;temp;</span><br><span class="line">            else</span><br><span class="line">                A2-&#x3D;temp;</span><br><span class="line">            a2count++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp%5&#x3D;&#x3D;2)</span><br><span class="line">            A3++;</span><br><span class="line"></span><br><span class="line">        if(temp%5&#x3D;&#x3D;3)&#123;</span><br><span class="line">            a4count++;</span><br><span class="line">            A4+&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(temp%5&#x3D;&#x3D;4)&#123;</span><br><span class="line">            if(temp&gt;A5)</span><br><span class="line">                A5&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if(!a1count)</span><br><span class="line">        printf(&quot;N &quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d &quot;,A1);</span><br><span class="line"></span><br><span class="line">    if(!a2count)</span><br><span class="line">        printf(&quot;N &quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d &quot;,A2);</span><br><span class="line"></span><br><span class="line">    if(!A3)</span><br><span class="line">        printf(&quot;N &quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d &quot;,A3);</span><br><span class="line"></span><br><span class="line">    if(!a4count)</span><br><span class="line">        printf(&quot;N &quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%.1f &quot;,(double)A4&#x2F;a4count);</span><br><span class="line"></span><br><span class="line">    if(!A5)</span><br><span class="line">        printf(&quot;N&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d&quot;,A5);    </span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1013-数素数</title>
    <url>/2020/03/26/PAT-B-1013-%E6%95%B0%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<p>令 <em>P**i</em> 表示第 <em>i</em> 个素数。现任给两个正整数 <em>M</em>≤<em>N</em>≤104，请输出 <em>P**M</em> 到 <em>P**N</em> 的所有素数。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 <em>M</em> 和 <em>N</em>，其间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>P**M</em> 到 <em>P**N</em> 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 27</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 13 17 19 23 29 31 37 41 43</span><br><span class="line">47 53 59 61 67 71 73 79 83 89</span><br><span class="line">97 101 103</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尽量大</span><br><span class="line">const int maxn&#x3D;1000001;</span><br><span class="line">int prime[maxn],pnum&#x3D;0;</span><br><span class="line">bool p[maxn]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void getPrime(int count)&#123;</span><br><span class="line">    &#x2F;&#x2F;记住素数表都是小于最大值</span><br><span class="line">    for(int i&#x3D;2;i&lt;maxn;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;为false则此数是素数</span><br><span class="line">        if(p[i]&#x3D;&#x3D;false)&#123;</span><br><span class="line">            prime[pnum++]&#x3D;i;</span><br><span class="line">            if(pnum&#x3D;&#x3D;count)return;</span><br><span class="line">            for(int j&#x3D;2*i;j&lt;maxn;j+&#x3D;i)&#123;</span><br><span class="line">                p[j]&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int m,n,count&#x3D;0;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    getPrime(n);</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;m-1;i&lt;n;i++ )&#123;</span><br><span class="line">        count++;</span><br><span class="line">        &#x2F;&#x2F;每行第一个只输出素数</span><br><span class="line">		if (count % 10 &#x3D;&#x3D; 1) </span><br><span class="line">			printf(&quot;%d&quot;, prime[i]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot; %d&quot;, prime[i]);</span><br><span class="line">		</span><br><span class="line">        &#x2F;&#x2F;没十个输出一个空格</span><br><span class="line">		if (count % 10 &#x3D;&#x3D; 0)</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1014-福尔摩斯的约会</title>
    <url>/2020/03/21/PAT-B-1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/</url>
    <content><![CDATA[<p>大侦探福尔摩斯接到一张奇怪的字条：<code>我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm</code>。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间<code>星期四 14:04</code>，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 <code>D</code>，代表星期四；第 2 对相同的字符是 <code>E</code> ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 <code>A</code> 到 <code>N</code> 表示）；后面两字符串第 1 对相同的英文字母 <code>s</code> 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出约会的时间，格式为 <code>DAY HH:MM</code>，其中 <code>DAY</code> 是某星期的 3 字符缩写，即 <code>MON</code> 表示星期一，<code>TUE</code> 表示星期二，<code>WED</code> 表示星期三，<code>THU</code> 表示星期四，<code>FRI</code> 表示星期五，<code>SAT</code> 表示星期六，<code>SUN</code> 表示星期日。题目输入保证每个测试存在唯一解。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3485djDkxh4hhGE </span><br><span class="line">2984akDfkkkkggEdsb </span><br><span class="line">s&amp;hgsfdk </span><br><span class="line">d&amp;Hyscvnm</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THU 14:04</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char week[7][5]&#x3D;&#123;&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char cp1_0[70],cp1_1[70],cp2_0[70],cp2_1[70];</span><br><span class="line">    scanf(&quot;%s&quot;,cp1_0);</span><br><span class="line">    scanf(&quot;%s&quot;,cp1_1);</span><br><span class="line">    scanf(&quot;%s&quot;,cp2_0);</span><br><span class="line">    scanf(&quot;%s&quot;,cp2_1);</span><br><span class="line">    int len1_0 &#x3D; strlen(cp1_0);</span><br><span class="line">    int len1_1 &#x3D; strlen(cp1_1);</span><br><span class="line">    int len2_0 &#x3D; strlen(cp2_0);</span><br><span class="line">    int len2_1 &#x3D; strlen(cp2_1);</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line">    for(i&#x3D;0;i&lt;len1_0&amp;&amp;i&lt;len1_1;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;第一堆相同的大写字母</span><br><span class="line">        if(cp1_0[i]&#x3D;&#x3D;cp1_1[i]&amp;&amp;cp1_0[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;cp1_0[i]&lt;&#x3D;&#39;G&#39;)&#123;</span><br><span class="line">            printf(&quot;%s &quot;,week[cp1_0[i]-&#39;A&#39;]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(i++;i&lt;len1_0&amp;&amp;i&lt;len1_1;i++)&#123;</span><br><span class="line">        if(cp1_0[i]&#x3D;&#x3D;cp1_1[i])&#123;</span><br><span class="line">            if(cp1_0[i]&gt;&#x3D;&#39;0&#39;&amp;&amp;cp1_0[i]&lt;&#x3D;&#39;9&#39;)&#123;</span><br><span class="line">                printf(&quot;%02d:&quot;,cp1_0[i]-&#39;0&#39;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(cp1_0[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;cp1_0[i]&lt;&#x3D;&#39;N&#39;)&#123;</span><br><span class="line">                printf(&quot;%02d:&quot;,cp1_0[i]-&#39;A&#39;+10);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;len2_0&amp;&amp;i&lt;len2_1;i++)&#123;</span><br><span class="line">        if(cp2_0[i]&#x3D;&#x3D;cp2_1[i])&#123;</span><br><span class="line">            if((cp2_0[i]&gt;&#x3D;&#39;A&#39;&amp;&amp;cp2_0[i]&lt;&#x3D;&#39;Z&#39;)||(cp2_0[i]&gt;&#x3D;&#39;a&#39;&amp;&amp;cp2_0[i]&lt;&#x3D;&#39;z&#39;))&#123;</span><br><span class="line">                printf(&quot;%02d&quot;,i);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1003-我要通过！</title>
    <url>/2020/03/22/PAT-B-1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81/</url>
    <content><![CDATA[<p>“<strong>答案正确</strong>”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“<strong>答案正确</strong>”大派送 —— 只要读入的字符串满足下列条件，系统就输出“<strong>答案正确</strong>”，否则输出“<strong>答案错误</strong>”。</p>
<p>得到“<strong>答案正确</strong>”的条件是：</p>
<ol>
<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>
<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串；</li>
<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 <code>A</code> 组成的字符串。</li>
</ol>
<p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 <em>n</em> (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个字符串的检测结果占一行，如果该字符串可以获得“<strong>答案正确</strong>”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">PAT</span><br><span class="line">PAAT</span><br><span class="line">AAPATAA</span><br><span class="line">AAPAATAAAA</span><br><span class="line">xPATx</span><br><span class="line">PT</span><br><span class="line">Whatever</span><br><span class="line">APAAATAA</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    char str[120];</span><br><span class="line">    &#x2F;&#x2F;记录字母p，t的位置</span><br><span class="line">    int loc_p&#x3D;-1,loc_t&#x3D;-1;</span><br><span class="line">    &#x2F;&#x2F;字母p，t和其他除a外的字母</span><br><span class="line">    &#x2F;&#x2F;x,y,z分别为p左侧，pt之间，t右侧的a的数量</span><br><span class="line">    int x,y,z;</span><br><span class="line">    int len&#x3D;0;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">        len &#x3D; strlen(str);</span><br><span class="line">        int num_p&#x3D;0, num_t&#x3D;0, num_other&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;对字符串进行迭代分析字母的个数及位置</span><br><span class="line">        for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39;P&#39;)&#123;</span><br><span class="line">                loc_p&#x3D;i;</span><br><span class="line">                num_p++;</span><br><span class="line">            &#125;else if(str[i]&#x3D;&#x3D;&#39;T&#39;)&#123;</span><br><span class="line">                loc_t&#x3D;i;</span><br><span class="line">                num_t++;</span><br><span class="line">            &#125;else if(str[i]!&#x3D;&#39;A&#39;)</span><br><span class="line">                num_other++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(num_p!&#x3D;1||num_t!&#x3D;1||num_other&gt;0||loc_t-loc_p&lt;&#x3D;1)&#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        x&#x3D;loc_p,y&#x3D;loc_t-loc_p-1,z&#x3D;len-loc_t-1;</span><br><span class="line">        &#x2F;&#x2F;本题的关键是要找到xyz之间的关系，关系式如下</span><br><span class="line">        if(z-(y-1)*x&#x3D;&#x3D;x)</span><br><span class="line">            printf(&quot;YES\n&quot;);</span><br><span class="line">        else    </span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1011 A+B 和 C</title>
    <url>/2020/03/11/PAT-B-1011-A-B-%E5%92%8C-C/</url>
    <content><![CDATA[<p>给定区间 [−2^31,2^31] 内的 3 个整数 <em>A</em>、<em>B</em> 和 <em>C</em>，请判断 <em>A</em>+<em>B</em> 是否大于 <em>C</em>。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第 1 行给出正整数 <em>T</em> (≤10)，是测试用例的个数。随后给出 <em>T</em> 组测试用例，每组占一行，顺序给出 <em>A</em>、<em>B</em> 和 <em>C</em>。整数间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 <em>A</em>+<em>B</em>&gt;<em>C</em>，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">2147483647 0 2147483646</span><br><span class="line">0 -2147483648 -2147483647</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case #1: false</span><br><span class="line">Case #2: true</span><br><span class="line">Case #3: true</span><br><span class="line">Case #4: false</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意数字的范围，int的最大值会超过这个范围，，另外两个int相加也可能会超过这个范围</span><br><span class="line">    &#x2F;&#x2F;用long long类型来存储</span><br><span class="line"></span><br><span class="line">    long long a,b,c;</span><br><span class="line">    int i&#x3D;1;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        if((a+b)&gt;c)</span><br><span class="line">            printf(&quot;Case #%d: true\n&quot;,i++);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Case #%d: false\n&quot;,i++);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1017-A除以B</title>
    <url>/2020/05/13/PAT-B-1017-A%E9%99%A4%E4%BB%A5B/</url>
    <content><![CDATA[<p>本题要求计算 <em>A</em>/<em>B</em>，其中 <em>A</em> 是不超过 1000 位的正整数，<em>B</em> 是 1 位正整数。你需要输出商数 <em>Q</em> 和余数 <em>R</em>，使得 <em>A</em>=<em>B</em>×<em>Q</em>+<em>R</em> 成立。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 <em>A</em> 和 <em>B</em>，中间以 1 空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中依次输出 <em>Q</em> 和 <em>R</em>，中间以 1 空格分隔。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123456789050987654321 7</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17636684150141093474 3</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;&#x2F;&#x2F;memset的头文件</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;大数结构体</span><br><span class="line">struct bign&#123;</span><br><span class="line">  int arr[1000];</span><br><span class="line">  int len;</span><br><span class="line">  bign()&#123;</span><br><span class="line">      memset(arr,0,sizeof(arr));</span><br><span class="line">      len&#x3D;1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;将字符串的大数转为int数组</span><br><span class="line">void init(const string&amp; num,bign&amp; n)&#123;</span><br><span class="line">    int len &#x3D; num.size();</span><br><span class="line">    n.len&#x3D;len;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        n.arr[i]&#x3D;num[i]-&#39;0&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;被除数，除数，余数</span><br><span class="line">bign divide(const bign&amp; n, int k, int&amp; r) &#123;</span><br><span class="line">	int temp &#x3D; 0, idx &#x3D; 0;</span><br><span class="line">	bign _n;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; n.len;i++) &#123;</span><br><span class="line">		if ((temp*10+n.arr[i] )&#x2F; k !&#x3D; 0) &#123;</span><br><span class="line">			_n.arr[idx++] &#x3D; (temp * 10 + n.arr[i]) &#x2F; k;</span><br><span class="line">			temp &#x3D; (temp * 10 + n.arr[i]) % k;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			temp &#x3D; n.arr[i];</span><br><span class="line">			if (idx &#x3D;&#x3D; 0)</span><br><span class="line">				continue;</span><br><span class="line">			_n.arr[idx++] &#x3D; 0;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		if (i &#x3D;&#x3D; n.len-1)</span><br><span class="line">			_n.len &#x3D; idx;</span><br><span class="line">	&#125;</span><br><span class="line">	r &#x3D; temp;</span><br><span class="line">	return _n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string num;</span><br><span class="line">    int k,r;&#x2F;&#x2F;被除数k和余数r</span><br><span class="line">    bign n,_n;</span><br><span class="line">    cin&gt;&gt;num&gt;&gt;k;</span><br><span class="line">    init(num,n);</span><br><span class="line">    _n &#x3D; divide(n,k,r);</span><br><span class="line">    </span><br><span class="line">    for(int i&#x3D;0;i&lt;_n.len;i++)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,_n.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot; %d&quot;,r);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
        <tag>大整数运算</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1016 部分A+B</title>
    <url>/2020/03/11/PAT-B-1016-%E9%83%A8%E5%88%86A-B/</url>
    <content><![CDATA[<p>正整数 <em>A</em> 的“<em>D*<em>A</em>（为 1 位整数）部分”定义为由 *A</em> 中所有 <em>D**A</em> 组成的新整数 <em>P*<em>A</em>。例如：给定 *A</em>=3862767，<em>D**A</em>=6，则 <em>A</em> 的“6 部分”<em>P**A</em> 是 66，因为 <em>A</em> 中有 2 个 6。</p>
<p>现给定 <em>A</em>、<em>D<strong>A<em>、</em>B<em>、</em>D</strong>B<em>，请编写程序计算 <em>P</em></em>A</em>+<em>P*</em>B*。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 <em>A</em>、<em>D<strong>A<em>、</em>B<em>、</em>D</strong>B<em>，中间以空格分隔，其中 0&lt;</em>A</em>,<em>B</em>&lt;1010。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出 <em>P**A</em>+<em>P**B</em> 的值。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3862767 6 13530293 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">399</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3862767 1 13530293 8</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    long long a,Da,b,Db;</span><br><span class="line">    scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;Da,&amp;b,&amp;Db);</span><br><span class="line">    &#x2F;&#x2F;注意Pa,Pb的初始化赋值为0</span><br><span class="line">    int Pa&#x3D;0,Pb&#x3D;0;</span><br><span class="line"></span><br><span class="line">    while(a!&#x3D;0)&#123;</span><br><span class="line">        if(a%10&#x3D;&#x3D;Da)</span><br><span class="line">            Pa&#x3D;Pa*10+Da;</span><br><span class="line">        a&#x3D;a&#x2F;10;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(b!&#x3D;0)&#123;</span><br><span class="line">        if(b%10&#x3D;&#x3D;Db)</span><br><span class="line">            Pb&#x3D;Pb*10+Db;</span><br><span class="line">        b&#x3D;b&#x2F;10;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,Pa+Pb);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1018 锤子剪刀布</title>
    <url>/2020/03/16/PAT-B-1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/</url>
    <content><![CDATA[<p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p>
<p><img src="/2020/03/16/PAT-B-1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/1.jpg" alt></p>
<p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第 1 行给出正整数 <em>N</em>（≤105），即双方交锋的次数。随后 <em>N</em> 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。<code>C</code> 代表“锤子”、<code>J</code> 代表“剪刀”、<code>B</code> 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">C J</span><br><span class="line">J B</span><br><span class="line">C B</span><br><span class="line">B B</span><br><span class="line">B C</span><br><span class="line">C C</span><br><span class="line">C B</span><br><span class="line">J B</span><br><span class="line">B C</span><br><span class="line">J J</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3 2</span><br><span class="line">2 3 5</span><br><span class="line">B B</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据字母获取相应的索引</span><br><span class="line">int change(char c)&#123;</span><br><span class="line">    switch(c)&#123;</span><br><span class="line">        case &#39;B&#39;:</span><br><span class="line">            return 0;</span><br><span class="line">            break;</span><br><span class="line">        case &#39;C&#39;:</span><br><span class="line">            return 1;</span><br><span class="line">            break;</span><br><span class="line">        case &#39;J&#39;:</span><br><span class="line">            return 2;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.分别统计甲和乙的胜、平、负次数</span><br><span class="line">&#x2F;&#x2F;2.分别统计甲和乙获胜次数最多的手势</span><br><span class="line">int main()&#123;</span><br><span class="line">    char mp[3] &#x3D; &#123;&#39;B&#39;,&#39;C&#39;,&#39;J&#39;&#125;;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    char A,B;</span><br><span class="line">    int k1,k2;</span><br><span class="line">    &#x2F;&#x2F;记录胜、平、负次数</span><br><span class="line">    int count_A[3]&#x3D;&#123;0&#125;,count_B[3]&#x3D;&#123;0&#125;;</span><br><span class="line">    &#x2F;&#x2F;记录BCJ获胜次数</span><br><span class="line">    int hand_A[3]&#x3D;&#123;0&#125;,hand_B[3]&#x3D;&#123;0&#125;;</span><br><span class="line">    </span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        getchar();&#x2F;&#x2F;用于吸收输入数字后和输入出拳后的那个空格，scanf会将回车&#39;\n&#39;作字符读取</span><br><span class="line">        scanf(&quot;%c %c&quot;, &amp;A, &amp;B);</span><br><span class="line">        k1&#x3D;change(A);</span><br><span class="line">        k2&#x3D;change(B);</span><br><span class="line">        if((k1+1)%3&#x3D;&#x3D;k2)&#123;&#x2F;&#x2F;甲赢了</span><br><span class="line">            count_A[0]++;</span><br><span class="line">            count_B[2]++;</span><br><span class="line">            hand_A[k1]++;</span><br><span class="line">        &#125;else if((k2+1)%3&#x3D;&#x3D;k1)&#123;&#x2F;&#x2F;乙赢了</span><br><span class="line">            count_A[2]++;</span><br><span class="line">            count_B[0]++;</span><br><span class="line">            hand_B[k2]++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            count_A[1]++;</span><br><span class="line">            count_B[1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d %d %d\n&quot;,count_A[0],count_A[1],count_A[2]);</span><br><span class="line">    printf(&quot;%d %d %d\n&quot;,count_B[0],count_B[1],count_B[2]);</span><br><span class="line"></span><br><span class="line">    int res1&#x3D;0,res2&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;3;i++)&#123;</span><br><span class="line">        if(hand_A[i]&gt;hand_A[res1])res1&#x3D;i;</span><br><span class="line">        if(hand_B[i]&gt;hand_B[res2])res2&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%c %c\n&quot;,mp[res1],mp[res2]);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1019-数字黑洞</title>
    <url>/2020/03/22/PAT-B-1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/</url>
    <content><![CDATA[<p>给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 <code>6174</code>，这个神奇的数字也叫 Kaprekar 常数。</p>
<p>例如，我们从<code>6767</code>开始，将得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7766 - 6677 &#x3D; 1089</span><br><span class="line">9810 - 0189 &#x3D; 9621</span><br><span class="line">9621 - 1269 &#x3D; 8352</span><br><span class="line">8532 - 2358 &#x3D; 6174</span><br><span class="line">7641 - 1467 &#x3D; 6174</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p>现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入给出一个 (0,104) 区间内的正整数 <em>N</em>。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果 <em>N</em> 的 4 位数字全相等，则在一行内输出 <code>N - N = 0000</code>；否则将计算的每一步在一行内输出，直到 <code>6174</code> 作为差出现，输出格式见样例。注意每个数字按 <code>4</code> 位数格式输出。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6767</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7766 - 6677 &#x3D; 1089</span><br><span class="line">9810 - 0189 &#x3D; 9621</span><br><span class="line">9621 - 1269 &#x3D; 8352</span><br><span class="line">8532 - 2358 &#x3D; 6174</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2222</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2222 - 2222 &#x3D; 0000</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sort默认是递增，因此只需要写一个递减</span><br><span class="line">bool cmp_desc(int a,int b)&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;数组作为参数传递时：在函数中对数组元素的修改就等同于对原数组元素的修改</span><br><span class="line">&#x2F;&#x2F;数组可作为参数但不能作为返回值</span><br><span class="line">&#x2F;&#x2F;将数组转为数字法1</span><br><span class="line">int to_num_1(int num[])&#123;</span><br><span class="line">    int res&#x3D;0,i&#x3D;4,product&#x3D;1;</span><br><span class="line">    for(i&#x3D;3;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">        res+&#x3D;num[i]*product;</span><br><span class="line">        product*&#x3D;10;</span><br><span class="line">    &#125; </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将数组转为数字法2</span><br><span class="line">int to_num_2(int num[])&#123;</span><br><span class="line">    int res&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;4;i++)</span><br><span class="line">        res&#x3D;res*10+num[i];</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将数字转为数组</span><br><span class="line">void to_arr(int num,int res[])&#123;</span><br><span class="line">    for(int i&#x3D;3;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">        res[i]&#x3D;num%10;</span><br><span class="line">        num&#x2F;&#x3D;10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,MIN,MAX;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int num[4];</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        to_arr(n,num);</span><br><span class="line">        sort(num,num+4);&#x2F;&#x2F;递增排序</span><br><span class="line">        MIN &#x3D; to_num_1(num);</span><br><span class="line">        sort(num,num+4,cmp_desc);&#x2F;&#x2F;递减排序</span><br><span class="line">        MAX &#x3D; to_num_1(num);</span><br><span class="line">        n&#x3D;MAX-MIN;</span><br><span class="line">        printf(&quot;%04d - %04d &#x3D; %04d\n&quot;,MAX,MIN,n);</span><br><span class="line">        &#x2F;&#x2F;循环出口</span><br><span class="line">        if(n&#x3D;&#x3D;0||n&#x3D;&#x3D;6174)break;</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1021 个位数统计</title>
    <url>/2020/03/12/PAT-B-1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>给定一个 <em>k</em> 位整数 <em>N</em>=<em>d<strong>k<em>−110</em>k<em>−1+⋯+</em>d<em>1101+</em>d<em>0 (0≤</em>d</strong>i*≤9, *i</em>=0,⋯,<em>k</em>−1, <em>d*<em>k</em>−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 *N</em>=100311，则有 2 个 0，3 个 1，和 1 个 3。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 <em>N</em>。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对 <em>N</em> 中每一种不同的个位数字，以 <code>D:M</code> 的格式在一行中输出该位数字 <code>D</code> 及其在 <em>N</em> 中出现的次数 <code>M</code>。要求按 <code>D</code> 的升序输出。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100311</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:2</span><br><span class="line">1:3</span><br><span class="line">3:1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;特别要注意是不超过1000位的正整数，这个数无论是int或者是long long类型都表示不了，因此只能用字符串来表示</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char num[1001];</span><br><span class="line">    scanf(&quot;%s&quot;,num);</span><br><span class="line"></span><br><span class="line">    int length &#x3D; strlen(num);</span><br><span class="line">    int res[10]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;length;i++)</span><br><span class="line">        res[num[i]-&#39;0&#39;]++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">        if(res[i])</span><br><span class="line">            printf(&quot;%d:%d\n&quot;,i,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1023-组个最小数</title>
    <url>/2020/03/28/PAT-B-1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/</url>
    <content><![CDATA[<p>给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。</p>
<p>现给定数字，请编写程序输出能够组成的最小的数。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出能够组成的最小的数。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2 0 0 0 3 0 0 1 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10015558</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;关键是找到除0的最小数，然后剩下的数在做正常的迭代输出就可以</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int length &#x3D; 0, nums[10], res[50];</span><br><span class="line">	for (int i &#x3D; 0;i &lt; 10;i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;nums[i]);</span><br><span class="line">		length +&#x3D; nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;找到除了0外最小的数做首位</span><br><span class="line">	int min&#x3D;-1;</span><br><span class="line">	for (int i &#x3D; 1;i &lt; 10;i++) &#123;</span><br><span class="line">		if (nums[i] !&#x3D; 0) &#123;</span><br><span class="line">			min &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res[0] &#x3D; min;</span><br><span class="line">    nums[min]--;</span><br><span class="line">	int index &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; 10;i++)</span><br><span class="line">		for (int j &#x3D; 0;j &lt; nums[i];j++)</span><br><span class="line">			res[index++] &#x3D; i;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0;i &lt; length;i++)</span><br><span class="line">		printf(&quot;%d&quot;, res[i]);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1022-D进制的A-B</title>
    <url>/2020/03/19/PAT-B-1022-D%E8%BF%9B%E5%88%B6%E7%9A%84A-B/</url>
    <content><![CDATA[<p>输入两个非负 10 进制整数 <em>A</em> 和 <em>B</em> (≤230−1)，输出 <em>A</em>+<em>B</em> 的 <em>D</em> (1&lt;<em>D</em>≤10)进制数。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 3 个整数 <em>A</em>、<em>B</em> 和 <em>D</em>。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出 <em>A</em>+<em>B</em> 的 <em>D</em> 进制数。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 456 8</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1103</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int a,b,d;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;d);</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; a+b;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意一个int型为4个字节32位，最高位为符号位本题不需要考虑</span><br><span class="line">    int res[31] &#x3D; &#123;0&#125;,i&#x3D;0;</span><br><span class="line">    do&#123;</span><br><span class="line">        res[i++]&#x3D;sum%d;</span><br><span class="line">        sum&#x2F;&#x3D;d;</span><br><span class="line">    &#125;while(sum!&#x3D;0);</span><br><span class="line"></span><br><span class="line">    for(int j&#x3D;i-1;j&gt;&#x3D;0;j--)</span><br><span class="line">        printf(&quot;%d&quot;,res[j]);</span><br><span class="line">        </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1024-科学计数法</title>
    <url>/2020/03/28/PAT-B-1024-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/</url>
    <content><![CDATA[<p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9]<code>.</code>[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。</p>
<p>现以科学计数法的格式给出实数 <em>A</em>，请编写程序按普通数字表示法输出 <em>A</em>，并保证所有有效位都被保留。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 <em>A</em>。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个测试用例，在一行中按普通数字表示法输出 <em>A</em>，并保证所有有效位都被保留，包括末尾的 0。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+1.23400E-03</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.00123400</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1.2E+10</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-12000000000</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	char str[10000];</span><br><span class="line">	scanf(&quot;%s&quot;, str);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;E的位置</span><br><span class="line">	int ePos &#x3D; 0;</span><br><span class="line">	while (str[ePos] !&#x3D; &#39;E&#39;)</span><br><span class="line">		ePos++;</span><br><span class="line"></span><br><span class="line">	int len &#x3D; strlen(str);</span><br><span class="line">	if (str[0] &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">		printf(&quot;-&quot;);</span><br><span class="line"></span><br><span class="line">	int exp &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; ePos + 2;i &lt; len;i++)</span><br><span class="line">		exp &#x3D; exp * 10 + (str[i] - &#39;0&#39;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;特判指数为0</span><br><span class="line">	if (exp &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		for (int i &#x3D; 1;i &lt; ePos;i++)</span><br><span class="line">			printf(&quot;%c&quot;, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (str[ePos + 1] &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">		printf(&quot;0.&quot;);</span><br><span class="line">		&#x2F;&#x2F;添加的0的个数为exp-1</span><br><span class="line">		for (int i &#x3D; 0;i &lt; exp - 1;i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line">		printf(&quot;%c&quot;,str[1]);</span><br><span class="line">		for (int i &#x3D; 3;i &lt; ePos;i++)</span><br><span class="line">			printf(&quot;%c&quot;, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int i &#x3D; 1;i &lt; ePos;i++) &#123;</span><br><span class="line">			if (str[i] &#x3D;&#x3D; &#39;.&#39;)continue;</span><br><span class="line">			printf(&quot;%c&quot;, str[i]);</span><br><span class="line">			&#x2F;&#x2F;i&#x3D;小数点右移位数+2，且移位后的位置不在字符串的最后一个位置</span><br><span class="line">			if (i &#x3D;&#x3D; exp + 2 &amp;&amp; ePos - 3 !&#x3D; exp)</span><br><span class="line">				printf(&quot;.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;添加剩下的0</span><br><span class="line">		for (int i &#x3D; 0;i &lt; exp - ePos + 3;i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1027-打印沙漏</title>
    <url>/2020/03/19/PAT-B-1027-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/</url>
    <content><![CDATA[<p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19 *</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先把数学公式列出来计算一遍</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	char c;</span><br><span class="line">	scanf(&quot;%d %c&quot;, &amp;n, &amp;c);</span><br><span class="line"></span><br><span class="line">	int bottom &#x3D; (int)sqrt(2.0 * (n + 1)) - 1;</span><br><span class="line">	if (bottom % 2 &#x3D;&#x3D; 0)bottom--;&#x2F;&#x2F;偶数时减1，令其为奇数</span><br><span class="line">	int count &#x3D; (bottom + 1) * (bottom + 1) &#x2F; 2 - 1;&#x2F;&#x2F;计算出*的个数</span><br><span class="line"></span><br><span class="line">	int i, j;</span><br><span class="line">	&#x2F;&#x2F;打印上三角</span><br><span class="line">	for (i &#x3D; 0;i &lt; bottom &#x2F; 2 + 1;i++) &#123;</span><br><span class="line">		for (j &#x3D; 0;j &lt; bottom - i;j++) &#123;</span><br><span class="line">			if (j &lt; i)</span><br><span class="line">				printf(&quot; &quot;);</span><br><span class="line">			else</span><br><span class="line">				printf(&quot;%c&quot;, c);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;打印下三角</span><br><span class="line">	for (i &#x3D; 3;i &lt;&#x3D;bottom;i+&#x3D;2) &#123;</span><br><span class="line">		for (j &#x3D; 0;j &lt; (bottom - i)&#x2F;2;j++) </span><br><span class="line">			printf(&quot; &quot;);</span><br><span class="line">		for(j&#x3D; 0;j &lt; i;j++)</span><br><span class="line">			printf(&quot;%c&quot;, c);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, n - count);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>图形输出</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1026 程序运行时间</title>
    <url>/2020/03/11/PAT-B-1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 <em>f</em> 的运行时间，我们只要在调用 <em>f</em> 之前先调用 clock()，获得一个时钟打点数 C1；在 <em>f</em> 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 <em>f</em> 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p>
<p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,107]。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出被测函数运行的时间。运行时间必须按照 <code>hh:mm:ss</code>（即2位的 <code>时:分:秒</code>）格式输出；不足 1 秒的时间四舍五入到秒。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 4577973</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12:42:59</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    long long  C1,C2;</span><br><span class="line">    const int CLK_TCK&#x3D;100;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;C1,&amp;C2);</span><br><span class="line">    long long second;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;由于使用(C2-C1)&#x2F;CLK_TCK只会丢失精度，并不会四舍五入，所以选择这种方式来四舍五入</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;计算四舍五入</span><br><span class="line">    if((C2-C1)%100&lt;50)&#123;</span><br><span class="line">        second &#x3D; (C2-C1)&#x2F;CLK_TCK;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        second &#x3D; (C2-C1)&#x2F;CLK_TCK+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;小时，分钟，秒的计算方式</span><br><span class="line">    printf(&quot;%02lld:%02lld:%02lld&quot;,second&#x2F;3600,second%3600&#x2F;60,second%60);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1029-旧键盘</title>
    <url>/2020/04/04/PAT-B-1029-%E6%97%A7%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 <code>_</code>（代表空格）组成。题目保证 2 个字符串均非空。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7_This_is_a_test</span><br><span class="line">_hs_s_a_es</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7TI</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;所有可能出现的键，默认全都是好的</span><br><span class="line">&#x2F;&#x2F;[65-90] _95 [97-122] </span><br><span class="line">bool keys[37]&#x3D;&#123;false&#125;;</span><br><span class="line">int getIdx(char c)&#123;</span><br><span class="line">    if(c&gt;47&amp;&amp;c&lt;58)</span><br><span class="line">        return c-&#39;0&#39;;</span><br><span class="line">    else if(c&#x3D;&#x3D;95)</span><br><span class="line">        return 10;</span><br><span class="line">    else&#123;</span><br><span class="line">        &#x2F;&#x2F;字母</span><br><span class="line">        if(c&gt;90)</span><br><span class="line">            return c-&#39;a&#39;+11;</span><br><span class="line">        return c-&#39;A&#39;+11;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	char str[81],prt[81];</span><br><span class="line">	scanf(&quot;%s%s&quot;,str,prt);</span><br><span class="line"></span><br><span class="line">    int len &#x3D;strlen(str),j&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(str[i]&#x3D;&#x3D;prt[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;i位置的键失效，在key数组中记录，若第一次出现，则输出</span><br><span class="line">            int idx &#x3D; getIdx(str[i]);</span><br><span class="line">            if(!keys[idx])&#123;</span><br><span class="line">                keys[idx]&#x3D;true;</span><br><span class="line">                char c &#x3D; str[i];</span><br><span class="line">                if(c&gt;&#x3D;97)</span><br><span class="line">                    c-&#x3D;32;</span><br><span class="line">                printf(&quot;%c&quot;,c);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1028-人口普查</title>
    <url>/2020/03/18/PAT-B-1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/</url>
    <content><![CDATA[<p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</p>
<p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出正整数 <em>N</em>，取值在(0,105]；随后 <em>N</em> 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">John 2001&#x2F;05&#x2F;12</span><br><span class="line">Tom 1814&#x2F;09&#x2F;06</span><br><span class="line">Ann 2121&#x2F;01&#x2F;30</span><br><span class="line">James 1814&#x2F;09&#x2F;05</span><br><span class="line">Steve 1967&#x2F;11&#x2F;20</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 Tom John</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;遇到日期第一时间想到用int接，用字符串不好处理</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct person&#123;</span><br><span class="line">    char name[15];</span><br><span class="line">    int yy,mm,dd;&#x2F;&#x2F;年月日</span><br><span class="line">&#125;temp,youngest,oldest,_left,_right;&#x2F;&#x2F;left right存放合法日期的左右边界</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;p2跟p1比</span><br><span class="line">bool younger(person&amp; p1, person&amp; p2) &#123;</span><br><span class="line">	if (p1.yy !&#x3D; p2.yy)</span><br><span class="line">		return p2.yy &gt;&#x3D; p1.yy;</span><br><span class="line">	else if (p1.mm !&#x3D; p2.mm)</span><br><span class="line">		return p2.mm &gt;&#x3D; p1.mm;</span><br><span class="line">	else</span><br><span class="line">		return p2.dd &gt;&#x3D; p1.dd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool older(person&amp; p1, person&amp; p2) &#123;</span><br><span class="line">	if (p1.yy !&#x3D; p2.yy)</span><br><span class="line">		return p2.yy &lt;&#x3D; p1.yy;</span><br><span class="line">	else if (p1.mm !&#x3D; p2.mm)</span><br><span class="line">		return p2.mm &lt;&#x3D; p1.mm;</span><br><span class="line">	else</span><br><span class="line">		return p2.dd &lt;&#x3D; p1.dd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F;设置左右边界</span><br><span class="line">    _left.yy &#x3D; 1814;</span><br><span class="line">    _left.mm&#x3D;_right.mm&#x3D;9;</span><br><span class="line">    _left.dd&#x3D;_right.dd&#x3D;6;</span><br><span class="line">    _right.yy &#x3D; 2014;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化youngest,oldest</span><br><span class="line">    &#x2F;&#x2F;越老的人越早出生，貌似没什么问题</span><br><span class="line">    youngest.yy&#x3D;1814;</span><br><span class="line">    youngest.mm&#x3D;oldest.mm&#x3D;9;</span><br><span class="line">    youngest.dd&#x3D;oldest.dd&#x3D;6;</span><br><span class="line">    oldest.yy&#x3D;2014;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	int n,count&#x3D;0;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%s %d&#x2F;%d&#x2F;%d&quot;,temp.name,&amp;temp.yy,&amp;temp.mm,&amp;temp.dd);</span><br><span class="line">        &#x2F;&#x2F;确定范围合理</span><br><span class="line">        if(younger(_left,temp)&amp;&amp;older(_right,temp))&#123;</span><br><span class="line">            if(younger(youngest,temp))youngest&#x3D;temp;</span><br><span class="line">            if(older(oldest,temp))oldest&#x3D;temp;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(count&#x3D;&#x3D;0)</span><br><span class="line">        printf(&quot;0\n&quot;);&#x2F;&#x2F;所有人都不合法，只输出0</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%d %s %s&quot;,count,oldest.name,youngest.name);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>查找元素</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1031-查验身份证</title>
    <url>/2020/03/19/PAT-B-1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/</url>
    <content><![CDATA[<p>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：</p>
<p>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值<code>Z</code>；最后按照以下关系对应<code>Z</code>值与校验码<code>M</code>的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Z：0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line">M：1 0 X 9 8 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>

<p>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数<em>N</em>（≤100）是输入的身份证号码的个数。随后<em>N</em>行，每行给出1个18位身份证号码。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出<code>All passed</code>。</p>
<h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">320124198808240056</span><br><span class="line">12010X198901011234</span><br><span class="line">110108196711301866</span><br><span class="line">37070419881216001X</span><br></pre></td></tr></table></figure>

<h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12010X198901011234</span><br><span class="line">110108196711301866</span><br><span class="line">37070419881216001X</span><br></pre></td></tr></table></figure>

<h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">320124198808240056</span><br><span class="line">110108196711301862</span><br></pre></td></tr></table></figure>

<h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">All passed</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int weight[17]&#x3D;&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;</span><br><span class="line">char M[11]&#x3D;&#123;&#39;1&#39;,&#39;0&#39;,&#39;X&#39;,&#39;9&#39;,&#39;8&#39;,&#39;7&#39;,&#39;6&#39;,&#39;5&#39;,&#39;4&#39;,&#39;3&#39;,&#39;2&#39;&#125;;</span><br><span class="line">bool allPass &#x3D;true;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    char cid[19];</span><br><span class="line">    int sum;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        sum&#x3D;0;</span><br><span class="line">        scanf(&quot;%s&quot;,cid);</span><br><span class="line">        &#x2F;&#x2F;校验并加权求和数字位</span><br><span class="line">        for(int i&#x3D;0;i&lt;17;i++)&#123;</span><br><span class="line">            if(cid[i]&#x3D;&#x3D;&#39;X&#39;)&#123;</span><br><span class="line">                allPass&#x3D;false;</span><br><span class="line">                printf(&quot;%s\n&quot;,cid);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else</span><br><span class="line">                &#x2F;&#x2F;加权求和</span><br><span class="line">                sum+&#x3D;(cid[i]-&#39;0&#39;)*weight[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(M[sum%11]!&#x3D;cid[17])&#123;</span><br><span class="line">            allPass&#x3D;false;</span><br><span class="line">            printf(&quot;%s\n&quot;,cid);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    if(allPass)</span><br><span class="line">        printf(&quot;All passed&quot;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1032 挖掘机技术哪家强</title>
    <url>/2020/03/18/PAT-B-1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/</url>
    <content><![CDATA[<p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行给出不超过 105 的正整数 <em>N</em>，即参赛人数。随后 <em>N</em> 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 65</span><br><span class="line">2 80</span><br><span class="line">1 100</span><br><span class="line">2 70</span><br><span class="line">3 40</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 150</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 100000;</span><br><span class="line">int school[maxn] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,max&#x3D;-1;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);	</span><br><span class="line">	m&#x3D;n;</span><br><span class="line">	&#x2F;&#x2F;编号和成绩 </span><br><span class="line">	int num,score;</span><br><span class="line">	</span><br><span class="line">	while(n--)&#123;	</span><br><span class="line">		scanf(&quot;%d %d&quot;,&amp;num,&amp;score);</span><br><span class="line">		school[num] +&#x3D; score;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int index &#x3D;0;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;找出最大值</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">		if(school[i]&gt;max)&#123;</span><br><span class="line">			max &#x3D; school[i];</span><br><span class="line">			index &#x3D; i;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	printf(&quot;%d %d\n&quot;,index,max);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>查找元素</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1034-有理数四则运算</title>
    <url>/2020/03/25/PAT-B-1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>本题要求编写程序，计算 2 个有理数的和、差、积、商。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中按照 <code>a1/b1 a2/b2</code> 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>分别在 4 行中按照 <code>有理数1 运算符 有理数2 = 结果</code> 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 <code>k a/b</code>，其中 <code>k</code> 是整数部分，<code>a/b</code> 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 <code>Inf</code>。题目保证正确的输出中没有超过整型范围的整数。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2&#x2F;3 -4&#x2F;2</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2&#x2F;3 + (-2) &#x3D; (-1 1&#x2F;3)</span><br><span class="line">2&#x2F;3 - (-2) &#x3D; 2 2&#x2F;3</span><br><span class="line">2&#x2F;3 * (-2) &#x3D; (-1 1&#x2F;3)</span><br><span class="line">2&#x2F;3 &#x2F; (-2) &#x3D; (-1&#x2F;3)</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5&#x2F;3 0&#x2F;6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2&#x2F;3 + 0 &#x3D; 1 2&#x2F;3</span><br><span class="line">1 2&#x2F;3 - 0 &#x3D; 1 2&#x2F;3</span><br><span class="line">1 2&#x2F;3 * 0 &#x3D; 0</span><br><span class="line">1 2&#x2F;3 &#x2F; 0 &#x3D; Inf</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">ll gcd(ll a,ll b)&#123;</span><br><span class="line">    return !b? a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Fraction&#123;</span><br><span class="line">    ll up,down;&#x2F;&#x2F;分子和分母</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;化简</span><br><span class="line">void reduction(Fraction&amp; f1)&#123;</span><br><span class="line">    &#x2F;&#x2F;正负的化简</span><br><span class="line">    if(f1.down&lt;0)&#123;</span><br><span class="line">        f1.up&#x3D;-f1.up;</span><br><span class="line">        f1.down&#x3D;-f1.down;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;为0的化简</span><br><span class="line">    if(f1.up&#x3D;&#x3D;0)</span><br><span class="line">        f1.down&#x3D;1;</span><br><span class="line">    else&#123;</span><br><span class="line">        &#x2F;&#x2F;约去公约数</span><br><span class="line">        ll d &#x3D; gcd(abs(f1.up),abs(f1.down));</span><br><span class="line">        f1.up&#x2F;&#x3D;d;</span><br><span class="line">        f1.down&#x2F;&#x3D;d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showFraction(Fraction&amp; f1)&#123;    </span><br><span class="line">    if (f1.up &lt; 0)</span><br><span class="line">		printf(&quot;(&quot;);</span><br><span class="line">	if (f1.down &#x3D;&#x3D; 1)</span><br><span class="line">		printf(&quot;%lld&quot;, f1.up);</span><br><span class="line">	else if (abs(f1.up) &gt; f1.down)&#x2F;&#x2F;假分式</span><br><span class="line">		printf(&quot;%lld %lld&#x2F;%lld&quot;, f1.up &#x2F; f1.down, abs(f1.up) % f1.down, f1.down);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;%lld&#x2F;%lld&quot;, f1.up, f1.down);</span><br><span class="line">	if (f1.up &lt; 0)</span><br><span class="line">		printf(&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;加</span><br><span class="line">void add(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; + &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.down+f1.down*f2.up;</span><br><span class="line">    res.down&#x3D;f1.down*f2.down;</span><br><span class="line">    reduction(res);</span><br><span class="line">    showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;减</span><br><span class="line">void difference(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; - &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.down-f1.down*f2.up;</span><br><span class="line">    res.down&#x3D;f1.down*f2.down;</span><br><span class="line">    reduction(res);</span><br><span class="line">    showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;乘</span><br><span class="line">void product(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; * &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.up;</span><br><span class="line">    res.down&#x3D;f1.down*f2.down;</span><br><span class="line">    reduction(res);</span><br><span class="line">    showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;除</span><br><span class="line">void quotient(Fraction&amp; f1,Fraction&amp; f2)&#123;</span><br><span class="line">    reduction(f1);</span><br><span class="line">    reduction(f2);</span><br><span class="line">    Fraction res;</span><br><span class="line">    showFraction(f1);</span><br><span class="line">    printf(&quot; &#x2F; &quot;);</span><br><span class="line">    showFraction(f2);</span><br><span class="line">    printf(&quot; &#x3D; &quot;);</span><br><span class="line">    res.up&#x3D;f1.up*f2.down;</span><br><span class="line">    res.down&#x3D;f1.down*f2.up;</span><br><span class="line">    reduction(res);</span><br><span class="line">    if(f2.up&#x3D;&#x3D;0)</span><br><span class="line">        printf(&quot;Inf&quot;);</span><br><span class="line">    else</span><br><span class="line">        showFraction(res);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	Fraction f1,f2;</span><br><span class="line">	scanf(&quot;%lld&#x2F;%lld%lld&#x2F;%lld&quot;,&amp;f1.up,&amp;f1.down,&amp;f2.up,&amp;f2.down);</span><br><span class="line">    add(f1,f2);</span><br><span class="line">    difference(f1,f2);</span><br><span class="line">    product(f1,f2);</span><br><span class="line">    quotient(f1,f2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1036-跟奥巴马一起编程</title>
    <url>/2020/03/19/PAT-B-1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出正方形边长 <em>N</em>（3≤<em>N</em>≤20）和组成正方形边的某种字符 C，间隔一个空格。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 a</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaaaaaaaaa</span><br><span class="line">a        a</span><br><span class="line">a        a</span><br><span class="line">a        a</span><br><span class="line">aaaaaaaaaa</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意行距是正常的，没有额外添加回车</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,m;</span><br><span class="line">    char c;</span><br><span class="line">	scanf(&quot;%d %c&quot;,&amp;n,&amp;c);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;为避免浮点数的介入，四舍五入自己判定</span><br><span class="line">    if(n%2&#x3D;&#x3D;0)</span><br><span class="line">        &#x2F;&#x2F;偶数</span><br><span class="line">        m&#x3D;n&#x2F;2;</span><br><span class="line">    else</span><br><span class="line">        m&#x3D;n&#x2F;2+1;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">            if(i&#x3D;&#x3D;0||i&#x3D;&#x3D;m-1)&#123;</span><br><span class="line">                printf(&quot;%c&quot;,c);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j&#x3D;&#x3D;0||j&#x3D;&#x3D;n-1)</span><br><span class="line">                printf(&quot;%c&quot;,c);</span><br><span class="line">            else</span><br><span class="line">                printf(&quot; &quot;);           </span><br><span class="line">        &#125;</span><br><span class="line">        if(i!&#x3D;m-1)</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>图形输出</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1038-统计同成绩学生</title>
    <url>/2020/03/27/PAT-B-1038-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/</url>
    <content><![CDATA[<p>本题要求读入 <em>N</em> 名学生的成绩，将获得某一给定分数的学生人数输出。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行给出不超过 105 的正整数 <em>N</em>，即学生总人数。随后一行给出 <em>N</em> 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 <em>K</em>（不超过 <em>N</em> 的正整数），随后是 <em>K</em> 个分数，中间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">60 75 90 55 75 99 82 90 75 50</span><br><span class="line">3 75 90 88</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 0</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;笨方法，时间复杂度为O(n^2)会超时</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	vector&lt;int&gt; score;</span><br><span class="line">	int n,temp;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">        score.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(score.begin(),score.end());</span><br><span class="line">    int m,count;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        count&#x3D;0;</span><br><span class="line">        int t;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;score.size();i++)&#123;</span><br><span class="line">            if(score[i]&#x3D;&#x3D;t)</span><br><span class="line">                count++;</span><br><span class="line">            if(count&gt;0&amp;&amp;score[i]!&#x3D;t)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d&quot;,count);</span><br><span class="line">        if(m!&#x3D;0)</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;开辟数组来存储时间复杂度O(m)</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int score[101]&#x3D;&#123;0&#125;;</span><br><span class="line">	int n,temp;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">        score[temp]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line">        int t;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">        printf(&quot;%d&quot;,score[t]);</span><br><span class="line">        if(m!&#x3D;0)</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1037-在霍格沃茨找零钱</title>
    <url>/2020/03/19/PAT-B-1037-%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1/</url>
    <content><![CDATA[<p>如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 <em>P</em> 和他实付的钱 <em>A</em>，你的任务是写一个程序来计算他应该被找的零钱。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 1 行中分别给出 <em>P</em> 和 <em>A</em>，格式为 <code>Galleon.Sickle.Knut</code>，其间用 1 个空格分隔。这里 <code>Galleon</code> 是 [0, 107] 区间内的整数，<code>Sickle</code> 是 [0, 17) 区间内的整数，<code>Knut</code> 是 [0, 29) 区间内的整数。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.16.27 14.1.28</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.2.1</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14.1.28 10.16.27</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-3.2.1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	&#x2F;&#x2F;1：17  1：29</span><br><span class="line">	int galleon,sickle,knut,_galleon,_sickle,_knut;</span><br><span class="line">	scanf(&quot;%d.%d.%d %d.%d.%d.&quot;,&amp;galleon,&amp;sickle,&amp;knut,&amp;_galleon,&amp;_sickle,&amp;_knut);</span><br><span class="line"></span><br><span class="line">    int g,s,h;</span><br><span class="line">    &#x2F;&#x2F;先判断哪个大</span><br><span class="line">    bool isPositive &#x3D; true;&#x2F;&#x2F;默认为正</span><br><span class="line"></span><br><span class="line">    sickle+&#x3D;17*galleon;</span><br><span class="line">    knut+&#x3D;29*sickle;</span><br><span class="line">    _sickle+&#x3D;17*_galleon;</span><br><span class="line">    _knut+&#x3D;29*_sickle;</span><br><span class="line"></span><br><span class="line">    if(_knut&lt;knut)&#123;</span><br><span class="line">        isPositive&#x3D;false;</span><br><span class="line">        h&#x3D;knut-_knut;</span><br><span class="line">    &#125;else</span><br><span class="line">		h &#x3D; _knut - knut;</span><br><span class="line">    s&#x3D;h&#x2F;29;</span><br><span class="line">    h&#x3D;h%29;</span><br><span class="line">    g&#x3D;s&#x2F;17;</span><br><span class="line">    s&#x3D;s%17;</span><br><span class="line">    </span><br><span class="line">    if(isPositive)</span><br><span class="line">        printf(&quot;%d.%d.%d&quot;,g,s,h);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;-%d.%d.%d&quot;,g,s,h);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1039-到底买不买</title>
    <url>/2020/04/04/PAT-B-1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0/</url>
    <content><![CDATA[<p>小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。</p>
<p>为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。</p>
<p><img src="https://images.ptausercontent.com/b7e2ffa6-8819-436d-ad79-a41263abe914.jpg" alt="figbuy.jpg"></p>
<p>图 1</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>如果可以买，则在一行中输出 <code>Yes</code> 以及有多少多余的珠子；如果不可以买，则在一行中输出 <code>No</code> 以及缺了多少珠子。其间以 1 个空格分隔。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ppRYYGrrYBR2258</span><br><span class="line">YrR8RrY</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes 8</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ppRYYGrrYB225</span><br><span class="line">YrR8RrY</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No 2</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;[0-9][a-z][A-Z]</span><br><span class="line">int counts[62]&#x3D;&#123;0&#125;;</span><br><span class="line">&#x2F;&#x2F;将字符转为counts数组中的索引</span><br><span class="line">&#x2F;&#x2F;48-57、65-90、97-122</span><br><span class="line">int getIndex(char c)&#123;</span><br><span class="line">    if(c&gt;47&amp;&amp;c&lt;58)</span><br><span class="line">        return c-&#39;0&#39;;</span><br><span class="line">    else if(c&gt;64&amp;&amp;c&lt;91)</span><br><span class="line">        return c-&#39;A&#39;+10;</span><br><span class="line">    else</span><br><span class="line">        return c-&#39;a&#39;+36;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	char str[1001],want[1001];	</span><br><span class="line">	scanf(&quot;%s&quot;,str);</span><br><span class="line">    scanf(&quot;%s&quot;,want);</span><br><span class="line"></span><br><span class="line">    int len &#x3D; strlen(want);</span><br><span class="line">    &#x2F;&#x2F;统计目标手串的数量</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        int idx&#x3D;getIndex(want[i]);</span><br><span class="line">        counts[idx]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int _len &#x3D; strlen(str);</span><br><span class="line">    for(int i&#x3D;0;i&lt;_len;i++)&#123;</span><br><span class="line">        int idx&#x3D;getIndex(str[i]);</span><br><span class="line">        if(counts[idx]!&#x3D;0)</span><br><span class="line">            counts[idx]--;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;62;i++)&#123;</span><br><span class="line">        if(counts[i]!&#x3D;0)</span><br><span class="line">            res+&#x3D;counts[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;case1：数量不够，则counts数组的和即为缺少的数量</span><br><span class="line">    &#x2F;&#x2F;case2：数量充足，则输出剩余的数量——总株数-want数</span><br><span class="line">    if(res&#x3D;&#x3D;0)</span><br><span class="line">        printf(&quot;Yes %d\n&quot;,_len-len);</span><br><span class="line">    else   </span><br><span class="line">        printf(&quot;No %d\n&quot;,res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1041-考试座位号</title>
    <url>/2020/03/18/PAT-B-1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/</url>
    <content><![CDATA[<p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 <em>N</em>（≤1000），随后 <em>N</em> 行，每行给出一个考生的信息：<code>准考证号 试机座位号 考试座位号</code>。其中<code>准考证号</code>由 16 位数字组成，座位从 1 到 <em>N</em> 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p>
<p>考生信息之后，给出一个正整数 <em>M</em>（≤<em>N</em>），随后一行中给出 <em>M</em> 个待查询的试机座位号码，以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3310120150912233 2 4</span><br><span class="line">3310120150912119 4 1</span><br><span class="line">3310120150912126 1 3</span><br><span class="line">3310120150912002 3 2</span><br><span class="line">2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3310120150912002 2</span><br><span class="line">3310120150912119 1</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line">LL ids[1001]&#x3D;&#123;0&#125;;</span><br><span class="line">int kss[1001]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,m;</span><br><span class="line">    </span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    LL id;</span><br><span class="line">    int sj,ks; </span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%lld%d%d&quot;,&amp;id,&amp;sj,&amp;ks);</span><br><span class="line">        ids[sj]&#x3D;id;</span><br><span class="line">        kss[sj]&#x3D;ks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    vector&lt;int&gt; sjs(m);</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;sjs[i]);</span><br><span class="line">        </span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">        printf(&quot;%lld %d\n&quot;,ids[sjs[i]],kss[sjs[i]]);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>查找元素</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1042-字符统计</title>
    <url>/2020/04/04/PAT-B-1042-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>请编写程序，找出一段给定文字中出现最频繁的那个英文字母。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is a simple TEST.  There ARE numbers and other symbols 1&amp;2&amp;3...........</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e 7</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;字母统计表</span><br><span class="line">int counts[26]&#x3D;&#123;0&#125;;</span><br><span class="line">int getIdx(char c)&#123;</span><br><span class="line">    if(c&gt;64&amp;&amp;c&lt;91)</span><br><span class="line">        return c-&#39;A&#39;;</span><br><span class="line">    else</span><br><span class="line">        return c-&#39;a&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断是否为字母</span><br><span class="line">bool isAlpha(char c) &#123;</span><br><span class="line">	return (c &gt;&#x3D; 65 &amp;&amp; c &lt;&#x3D; 90) || (c &gt;&#x3D; 97 &amp;&amp; c &lt;&#x3D; 122);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	char str[1001];</span><br><span class="line">    cin.getline(str,1001);</span><br><span class="line">	int len &#x3D; strlen(str);</span><br><span class="line">    &#x2F;&#x2F;开始统计</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(isAlpha(str[i]))</span><br><span class="line">            counts[getIdx(str[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int minIdx&#x3D;0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;26;i++)&#123;</span><br><span class="line">        if(counts[i]&gt;counts[minIdx])</span><br><span class="line">            minIdx&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%c %d\n&quot;,&#39;a&#39;+minIdx,counts[minIdx]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1043-输出PATest</title>
    <url>/2020/04/12/PAT-B-1043-%E8%BE%93%E5%87%BAPATest/</url>
    <content><![CDATA[<p>给定一个长度不超过 104 的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 <code>PATestPATest....</code> 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个长度不超过 104 的、仅由英文字母构成的非空字符串。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按题目要求输出排序后的字符串。题目保证输出非空。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redlesPayBestPATTopTeePHPereatitAPPT</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATestPATestPTetPTePePee</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	char str[10001];</span><br><span class="line">	scanf(&quot;%s&quot;,str);</span><br><span class="line">    int len &#x3D; strlen(str);</span><br><span class="line">    int count[6]&#x3D;&#123;0&#125;;</span><br><span class="line">    char c[6]&#x3D;&#123;&#39;P&#39;,&#39;A&#39;,&#39;T&#39;,&#39;e&#39;,&#39;s&#39;,&#39;t&#39;&#125;;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(str[i]&#x3D;&#x3D;&#39;P&#39;)</span><br><span class="line">            count[0]++;</span><br><span class="line">        else if(str[i]&#x3D;&#x3D;&#39;A&#39;)</span><br><span class="line">            count[1]++;</span><br><span class="line">        else if(str[i]&#x3D;&#x3D;&#39;T&#39;)</span><br><span class="line">            count[2]++;</span><br><span class="line">        else if(str[i]&#x3D;&#x3D;&#39;e&#39;)</span><br><span class="line">            count[3]++;</span><br><span class="line">        else if(str[i]&#x3D;&#x3D;&#39;s&#39;)</span><br><span class="line">            count[4]++;</span><br><span class="line">        else if(str[i]&#x3D;&#x3D;&#39;t&#39;)</span><br><span class="line">            count[5]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int max&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;6;i++)&#123;</span><br><span class="line">        if(count[i]&gt;max)</span><br><span class="line">            max&#x3D;count[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 0;j &lt; max;j++) &#123;</span><br><span class="line">		for (int i &#x3D; 0;i &lt; 6;i++) &#123;</span><br><span class="line">			if (count[i] !&#x3D; 0) &#123;</span><br><span class="line">				printf(&quot;%c&quot;, c[i]);</span><br><span class="line">				count[i]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1046 划拳</title>
    <url>/2020/03/11/PAT-B-1046-%E5%88%92%E6%8B%B3/</url>
    <content><![CDATA[<p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p>
<p>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行先给出一个正整数 <em>N</em>（≤100），随后 <em>N</em> 行，每行给出一轮划拳的记录，格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">甲喊 甲划 乙喊 乙划</span><br></pre></td></tr></table></figure>

<p>其中<code>喊</code>是喊出的数字，<code>划</code>是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">8 10 9 12</span><br><span class="line">5 10 5 10</span><br><span class="line">3 8 5 12</span><br><span class="line">12 18 1 13</span><br><span class="line">4 16 12 15</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int ah,aH,bh,bH;</span><br><span class="line">    int an&#x3D;0,bn&#x3D;0;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;ah,&amp;aH,&amp;bh,&amp;bH);</span><br><span class="line">        if(aH&#x3D;&#x3D;(ah+bh)&amp;&amp;bH&#x3D;&#x3D;aH)</span><br><span class="line">            continue;</span><br><span class="line">        if(aH&#x3D;&#x3D;(ah+bh))</span><br><span class="line">            bn++;</span><br><span class="line">        if(bH&#x3D;&#x3D;(ah+bh))</span><br><span class="line">            an++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d %d&quot;,an,bn);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1048-数字加密</title>
    <url>/2020/03/28/PAT-B-1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<p>本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出加密后的结果。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234567 368782971</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3695Q8118</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char nums[13]&#x3D;&#123;&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;J&#39;,&#39;Q&#39;,&#39;K&#39;&#125;;</span><br><span class="line">&#x2F;&#x2F;注意不管是哪个字符串长，两个都要全部计算完</span><br><span class="line">int main() &#123;</span><br><span class="line">	char A[100], B[100];</span><br><span class="line">	scanf(&quot;%s%s&quot;, A, B);</span><br><span class="line">    int lenA &#x3D; strlen(A), lenB &#x3D; strlen(B);</span><br><span class="line">	reverse(A, A+lenA), reverse(B, B+lenB);</span><br><span class="line">    stack&lt;char&gt; stk;</span><br><span class="line">	&#x2F;&#x2F;对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；</span><br><span class="line">	&#x2F;&#x2F;对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10</span><br><span class="line">    int len&#x3D;lenA&gt;lenB? lenA:lenB;</span><br><span class="line">	int index &#x3D; 1;</span><br><span class="line">    for(int i &#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        int numA&#x3D;i&lt;lenA?A[i]-&#39;0&#39;:0;</span><br><span class="line">        int numB&#x3D;i&lt;lenB?B[i]-&#39;0&#39;:0;</span><br><span class="line"></span><br><span class="line">        if(i%2&#x3D;&#x3D;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;奇数</span><br><span class="line">            stk.push(nums[(numA+numB)%13]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;偶数</span><br><span class="line">            if((numB-numA)&lt;0)&#123;</span><br><span class="line">                stk.push(nums[numB-numA+10]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stk.push(nums[numB-numA]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	while (!stk.empty()) &#123;</span><br><span class="line">		printf(&quot;%c&quot;, stk.top());</span><br><span class="line">		stk.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1049-数列的片段和</title>
    <url>/2020/03/25/PAT-B-1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。</p>
<p>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个不超过 105 的正整数 <em>N</em>，表示数列中数的个数，第二行给出 <em>N</em> 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0.1 0.2 0.3 0.4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5.00</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;出现次数与i个数的关系 t&#x3D;i*(n+1-i)</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    double num,sum&#x3D;0.0;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lf&quot;,&amp;num);</span><br><span class="line">        &#x2F;&#x2F;关键就在于找到第几个数与其出现次数的关系</span><br><span class="line">        sum+&#x3D;num*i*(n+1-i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2lf&quot;,sum);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>简单数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1051-复数乘法</title>
    <url>/2020/04/12/PAT-B-1051-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<p>复数可以写成 (<em>A</em>+<em>B**i</em>) 的常规形式，其中 <em>A</em> 是实部，<em>B</em> 是虚部，<em>i</em> 是虚数单位，满足 <em>i</em>2=−1；也可以写成极坐标下的指数形式 (<em>R</em>×<em>e</em>(<em>P**i</em>))，其中 <em>R</em> 是复数模，<em>P</em> 是辐角，<em>i</em> 是虚数单位，其等价于三角形式 <em>R</em>(cos(<em>P</em>)+<em>i</em>sin(<em>P</em>))。</p>
<p>现给定两个复数的 <em>R</em> 和 <em>P</em>，要求输出两数乘积的常规形式。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中依次给出两个复数的 <em>R</em>1, <em>P</em>1, <em>R</em>2, <em>P</em>2，数字间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中按照 <code>A+Bi</code> 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 <code>B</code> 是负数，则应该写成 <code>A-|B|i</code> 的形式。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.3 3.5 5.2 0.4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-8.68-8.23i</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>读入R1、P1、R2、P2。</li>
<li>A=(R1<em>R2)cos(P1+P2)，B=(R1</em>R2)sin(P1+P2)。</li>
<li>如果A的绝对值小于0.01，A=0。</li>
<li>如果B的绝对值小于0.01，B=0。</li>
<li>如果B小于零，输出A-|B|i，否则B输出A+Bi。输出时，每个数字保留两位。</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	double R1,P1,R2,P2;</span><br><span class="line">	scanf(&quot;%lf%lf%lf%lf&quot;,&amp;R1,&amp;P1,&amp;R2,&amp;P2);</span><br><span class="line">    &#x2F;&#x2F;对两个复数的三角函数形式做积</span><br><span class="line">    R1*&#x3D;R2;</span><br><span class="line">    P1+&#x3D;P2;</span><br><span class="line"></span><br><span class="line">    double r,v;</span><br><span class="line">    r &#x3D; fabs(R1 * cos(P1))&lt;0.01?0.0:R1 * cos(P1);</span><br><span class="line">	v &#x3D; fabs(R1 * sin(P1))&lt;0.01?0.0:R1 * sin(P1);</span><br><span class="line">    if(v&lt;0)</span><br><span class="line">	    printf(&quot;%.2lf%.2lfi&quot;, r, v);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;%.2lf+%.2lfi&quot;, r, v);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1053-住房空置率</title>
    <url>/2020/05/13/PAT-B-1053-%E4%BD%8F%E6%88%BF%E7%A9%BA%E7%BD%AE%E7%8E%87/</url>
    <content><![CDATA[<p>在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下：</p>
<ul>
<li>在观察期内，若存在超过一半的日子用电量低于某给定的阈值 <em>e</em>，则该住房为“可能空置”；</li>
<li>若观察期超过某给定阈值 <em>D</em> 天，且满足上一个条件，则该住房为“空置”。</li>
</ul>
<p>现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数 <em>N</em>（≤1000），为居民区住房总套数；正实数 <em>e</em>，即低电量阈值；正整数 <em>D</em>，即观察期阈值。随后 <em>N</em> 行，每行按以下格式给出一套住房的用电量数据：</p>
<p><em>K</em> <em>E</em>1 <em>E</em>2 … <em>E**K</em></p>
<p>其中 <em>K</em> 为观察的天数，<em>E**i</em> 为第 <em>i</em> 天的用电量。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后 1 位。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 0.5 10</span><br><span class="line">6 0.3 0.4 0.5 0.2 0.8 0.6</span><br><span class="line">10 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5</span><br><span class="line">5 0.4 0.3 0.5 0.1 0.7</span><br><span class="line">11 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1</span><br><span class="line">11 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40.0% 20.0%</span><br></pre></td></tr></table></figure>

<p>（样例解释：第2、3户为“可能空置”，第4户为“空置”，其他户不是空置。）</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int N, D;</span><br><span class="line">	double e, mayemp &#x3D; 0, emp &#x3D; 0,temp;</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%d %lf %d&quot;, &amp;N, &amp;e, &amp;D);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int K, cnt_less &#x3D; 0;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;K);</span><br><span class="line">		for (int j &#x3D; 0; j &lt; K; j++)&#123;</span><br><span class="line">			scanf(&quot;%lf&quot;, &amp;temp);</span><br><span class="line">			if (temp &lt; e)</span><br><span class="line">                cnt_less++;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cnt_less &gt; K&#x2F;2 &amp;&amp; K &lt;&#x3D; D)</span><br><span class="line">            mayemp++;</span><br><span class="line">		else if (cnt_less &gt; K&#x2F;2 &amp;&amp; K&gt;D)</span><br><span class="line">            emp++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%.1f%% %.1f%%&quot;, mayemp &#x2F; N * 100, emp &#x2F; N * 100);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1052-卖个萌</title>
    <url>/2020/04/08/PAT-B-1052-%E5%8D%96%E4%B8%AA%E8%90%8C/</url>
    <content><![CDATA[<p>萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[左手]([左眼][口][右眼])[右手]</span><br></pre></td></tr></table></figure>

<p>现给出可选用的符号集合，请你按用户的要求输出表情。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 <code>[]</code>内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。</p>
<p>之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 <code>Are you kidding me? @\/@</code>。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[╮][╭][o][~\][&#x2F;~]  [&lt;][&gt;]</span><br><span class="line"> [╯][╰][^][-][&#x3D;][&gt;][&lt;][@][⊙]</span><br><span class="line">[Д][▽][_][ε][^]  ...</span><br><span class="line">4</span><br><span class="line">1 1 2 2 2</span><br><span class="line">6 8 1 5 5</span><br><span class="line">3 3 4 3 3</span><br><span class="line">2 10 3 9 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">╮(╯▽╰)╭</span><br><span class="line">&lt;(@Д&#x3D;)&#x2F;~</span><br><span class="line">o(^ε^)o</span><br><span class="line">Are you kidding me? @\&#x2F;@</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char hand[12][6];</span><br><span class="line">char eye[12][6];</span><br><span class="line">char mouth[12][6];</span><br><span class="line">int hlen&#x3D;1,elen&#x3D;1,mlen&#x3D;1;&#x2F;&#x2F;都是从第一位开始存储</span><br><span class="line"></span><br><span class="line">bool _check(int* ip)&#123;</span><br><span class="line">    &#x2F;&#x2F;验证手,测试用例的输入可能小于1或大于10</span><br><span class="line">    if(ip[0]&gt;&#x3D;hlen||ip[4]&gt;&#x3D;hlen||ip[0]&lt;1||ip[4]&lt;1)</span><br><span class="line">        return false;</span><br><span class="line">    if(ip[1]&gt;&#x3D;elen||ip[3]&gt;&#x3D;elen||ip[1]&lt;1||ip[3]&lt;1)</span><br><span class="line">        return false;</span><br><span class="line">    if(ip[2]&gt;&#x3D;mlen||ip[2]&lt;1)</span><br><span class="line">        return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char temp;</span><br><span class="line">    &#x2F;&#x2F;输入手眼口</span><br><span class="line">    while((temp &#x3D; getchar())!&#x3D;&#39;\n&#39;)&#123;</span><br><span class="line">        if(temp&#x3D;&#x3D;&#39;[&#39;)</span><br><span class="line">            scanf(&quot;%[^]]&quot;, hand[hlen++]);</span><br><span class="line">    &#125;</span><br><span class="line">    while((temp &#x3D; getchar())!&#x3D;&#39;\n&#39;)&#123;</span><br><span class="line">        if(temp&#x3D;&#x3D;&#39;[&#39;)</span><br><span class="line">            scanf(&quot;%[^]]&quot;, eye[elen++]);</span><br><span class="line">    &#125;</span><br><span class="line">    while((temp &#x3D; getchar())!&#x3D;&#39;\n&#39;)&#123;</span><br><span class="line">        if(temp&#x3D;&#x3D;&#39;[&#39;)</span><br><span class="line">            scanf(&quot;%[^]]&quot;, mouth[mlen++]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int num,ip[5];</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">    while(num--)&#123;</span><br><span class="line">        &#x2F;&#x2F;手(眼口眼)手</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;,ip,ip+1,ip+2,ip+3,ip+4);</span><br><span class="line">        &#x2F;&#x2F;先判断各个索引位置是否都存在</span><br><span class="line">        if(_check(ip))</span><br><span class="line">            printf(&quot;%s(%s%s%s)%s\n&quot;,hand[ip[0]],eye[ip[1]],mouth[ip[2]],eye[ip[3]],hand[ip[4]]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Are you kidding me? @\\&#x2F;@\n&quot;);&#x2F;&#x2F;\\为转义</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1054-求平均值</title>
    <url>/2020/05/12/PAT-B-1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<p>本题的基本要求非常简单：给定 <em>N</em> 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数 <em>N</em>（≤100）。随后一行给出 <em>N</em> 个实数，数字间以一个空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个非法输入，在一行中输出 <code>ERROR: X is not a legal number</code>，其中 <code>X</code> 是输入。最后在一行中输出结果：<code>The average of K numbers is Y</code>，其中 <code>K</code> 是合法输入的个数，<code>Y</code> 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 <code>Undefined</code> 替换 <code>Y</code>。如果 <code>K</code> 为 1，则输出 <code>The average of 1 number is Y</code>。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">5 -3.2 aaa 9999 2.3.4 7.123 2.35</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: aaa is not a legal number</span><br><span class="line">ERROR: 9999 is not a legal number</span><br><span class="line">ERROR: 2.3.4 is not a legal number</span><br><span class="line">ERROR: 7.123 is not a legal number</span><br><span class="line">The average of 3 numbers is 1.38</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aaa -9999</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: aaa is not a legal number</span><br><span class="line">ERROR: -9999 is not a legal number</span><br><span class="line">The average of 0 numbers is Undefined</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool check_legal(string s) &#123;</span><br><span class="line">    int pnum &#x3D; 0, ppos;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        if ((s[i] &lt; &#39;0&#39; || s[i] &gt; &#39;9&#39;) &amp;&amp; (s[i] !&#x3D; &#39;.&#39; &amp;&amp; s[i] !&#x3D; &#39;-&#39;))</span><br><span class="line">            return false;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39;-&#39; &amp;&amp; i !&#x3D; 0) return false;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; &#39;.&#39;) &#123;</span><br><span class="line">            pnum++;</span><br><span class="line">            if (pnum &gt; 1) return false;</span><br><span class="line">            ppos &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pnum &gt; 0 &amp;&amp; ppos &lt; s.size() - 3) return false;</span><br><span class="line">    if (stod(s) &gt; 1000.0 || stod(s) &lt; -1000.0)</span><br><span class="line">        return false;</span><br><span class="line">    else</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, cnt &#x3D; 0;</span><br><span class="line">    double sum &#x3D; 0.0;</span><br><span class="line">    string s;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        if (!check_legal(s))</span><br><span class="line">            cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; s &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl;</span><br><span class="line">        else &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum +&#x3D; stod(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &#x3D;&#x3D; 0)</span><br><span class="line">        printf(&quot;The average of 0 numbers is Undefined&quot;);</span><br><span class="line">    else if (cnt &#x3D;&#x3D; 1)</span><br><span class="line">        printf(&quot;The average of %d number is %.2lf&quot;, cnt, sum);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;The average of %d numbers is %.2lf&quot;, cnt, sum &#x2F; cnt);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1056-组合数的和</title>
    <url>/2020/03/27/PAT-B-1056-%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<p>给定 N 个非 0 的个位数字，用其中任意 2 个数字都可以组合成 1 个 2 位的数字。要求所有可能组合出来的 2 位数字的和。例如给定 2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中先给出 N（1 &lt; N &lt; 10），随后给出 N 个不同的非 0 个位数字。数字间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出所有可能组合出来的2位数字的和。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 8 5</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">330</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int _sum&#x3D;0;</span><br><span class="line">&#x2F;&#x2F;递归法获得组合</span><br><span class="line">void DFS(int index,vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used,int num,int product)&#123;</span><br><span class="line">    if(index&#x3D;&#x3D;2)&#123;</span><br><span class="line">        _sum+&#x3D;num;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0;i &lt; (int)nums.size();i++) &#123;</span><br><span class="line">		if (!used[i]) &#123;</span><br><span class="line">			used[i] &#x3D; true;</span><br><span class="line">			DFS(index + 1, nums, used, num  + nums[i] * product, product &#x2F; 10);</span><br><span class="line">			used[i] &#x3D; false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    vector&lt;int&gt; v(n);</span><br><span class="line">    vector&lt;bool&gt; used(n,false);</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;v[i]);</span><br><span class="line">    DFS(0,v,used,0,10);</span><br><span class="line">    printf(&quot;%d\n&quot;,_sum);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1057-数零壹</title>
    <url>/2020/04/04/PAT-B-1057-%E6%95%B0%E9%9B%B6%E5%A3%B9/</url>
    <content><![CDATA[<p>给定一串长度不超过 105 的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 <code>PAT (Basic)</code>，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出长度不超过 105、以回车结束的字符串。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PAT (Basic)</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;判断是否为字母</span><br><span class="line">bool isAlpha(char c)&#123;</span><br><span class="line">    return (c&gt;&#x3D;65&amp;&amp;c&lt;&#x3D;90)||(c&gt;&#x3D;97&amp;&amp;c&lt;&#x3D;122);</span><br><span class="line">&#125;</span><br><span class="line">int getIdx(char c)&#123;</span><br><span class="line">    if(c&lt;&#x3D;90)</span><br><span class="line">        return c-&#39;A&#39;+1;</span><br><span class="line">    else</span><br><span class="line">        return c-&#39;a&#39;+1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    char str[100100];</span><br><span class="line">    &#x2F;&#x2F;注意输入的字符串可能存在空格</span><br><span class="line">    cin.getline(str,100100);</span><br><span class="line">	&#x2F;&#x2F;scanf(&quot;%s&quot;,str);</span><br><span class="line">    int len &#x3D; strlen(str),num&#x3D;0;</span><br><span class="line">    for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">        if(isAlpha(str[i]))&#123;</span><br><span class="line">            num+&#x3D;getIdx(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将10进制转为2进制</span><br><span class="line">    int countZ&#x3D;0,countO&#x3D;0,rest;</span><br><span class="line">    &#x2F;&#x2F;如果用do while循环则会出现第三个测试点不过。</span><br><span class="line">    &#x2F;&#x2F;表示若输入内容没有字母，则输出0 0 而非1 0</span><br><span class="line">    while(num!&#x3D;0)&#123;</span><br><span class="line">        rest &#x3D; num%2;</span><br><span class="line">        if(rest)</span><br><span class="line">            countO++;</span><br><span class="line">        else    </span><br><span class="line">            countZ++;</span><br><span class="line">        num&#x2F;&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;,countZ,countO);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1059-c语言竞赛</title>
    <url>/2020/05/13/PAT-B-1059-c%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B/</url>
    <content><![CDATA[<p>C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽：</p>
<ul>
<li>0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。</li>
<li>1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！</li>
<li>2、其他人将得到巧克力。</li>
</ul>
<p>给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 <em>N</em>（≤104），是参赛者人数。随后 <em>N</em> 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 <em>K</em> 以及 <em>K</em> 个需要查询的 ID。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个要查询的 ID，在一行中输出 <code>ID: 奖品</code>，其中奖品或者是 <code>Mystery Award</code>（神秘大奖）、或者是 <code>Minion</code>（小黄人）、或者是 <code>Chocolate</code>（巧克力）。如果所查 ID 根本不在排名里，打印 <code>Are you kidding?</code>（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 <code>ID: Checked</code>（不能多吃多占）。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1111</span><br><span class="line">6666</span><br><span class="line">8888</span><br><span class="line">1234</span><br><span class="line">5555</span><br><span class="line">0001</span><br><span class="line">6</span><br><span class="line">8888</span><br><span class="line">0001</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">8888</span><br><span class="line">2222</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8888: Minion</span><br><span class="line">0001: Chocolate</span><br><span class="line">1111: Mystery Award</span><br><span class="line">2222: Are you kidding?</span><br><span class="line">8888: Checked</span><br><span class="line">2222: Are you kidding?</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;素数的判定</span><br><span class="line">bool isPrime(int n) &#123;</span><br><span class="line">	if (n &lt;&#x3D; 1)</span><br><span class="line">		return false;</span><br><span class="line">	for (int i &#x3D; 2;i * i &lt;&#x3D; n;i++) &#123;</span><br><span class="line">		if (n % i &#x3D;&#x3D; 0)return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k, rank &#x3D; 1;</span><br><span class="line">	string temp,cpId;&#x2F;&#x2F;单独记录冠军的id</span><br><span class="line">	map&lt;string, int&gt; m;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		if (i &#x3D;&#x3D; 0)</span><br><span class="line">			cpId &#x3D; temp;</span><br><span class="line">		m.insert(make_pair(temp,i));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	set&lt;string&gt; checked;&#x2F;&#x2F;放置查询过的id</span><br><span class="line">	set&lt;string&gt;::iterator it;</span><br><span class="line">	map&lt;string, int&gt;::iterator mit;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		cin &gt;&gt; temp;</span><br><span class="line">		mit &#x3D; m.find(temp);</span><br><span class="line">		if (mit !&#x3D; m.end()) &#123;</span><br><span class="line">			it &#x3D; checked.find(temp);</span><br><span class="line">			if (it !&#x3D; checked.end()) &#123;</span><br><span class="line">				&#x2F;&#x2F;已经领过奖了</span><br><span class="line">				printf(&quot;%s: Checked\n&quot;, temp.c_str());</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				checked.insert(temp);</span><br><span class="line">				if (temp &#x3D;&#x3D; cpId) &#123;</span><br><span class="line">					printf(&quot;%s: Mystery Award\n&quot;, temp.c_str());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					if (isPrime(mit-&gt;second+1)) &#123;</span><br><span class="line">						printf(&quot;%s: Minion\n&quot;, temp.c_str());</span><br><span class="line"></span><br><span class="line">					&#125;else &#123;</span><br><span class="line">						printf(&quot;%s: Chocolate\n&quot;, temp.c_str());</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;else &#123;</span><br><span class="line"></span><br><span class="line">			printf(&quot;%s: Are you kidding?\n&quot;, temp.c_str());</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1058-选择题</title>
    <url>/2020/05/11/PAT-B-1058-%E9%80%89%E6%8B%A9%E9%A2%98/</url>
    <content><![CDATA[<p>批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个正整数 N（≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 </span><br><span class="line">3 4 2 a c</span><br><span class="line">2 5 1 b</span><br><span class="line">5 3 2 b c</span><br><span class="line">1 5 4 a b d e</span><br><span class="line">(2 a c) (2 b d) (2 a c) (3 a b e)</span><br><span class="line">(2 a c) (1 b) (2 a b) (4 a b d e)</span><br><span class="line">(2 b d) (1 e) (2 b c) (4 a b c d)</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><ul>
<li>注：STL容器对象的==操作符重载了，相同类型的对象可以比较。若容器内的元素都相同，则俩容器对象相等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  	int n, m;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	vector&lt;int&gt; score(m, 0);&#x2F;&#x2F;记录每道题分值</span><br><span class="line">	vector&lt;int&gt; ans_cnt(m, 0);&#x2F;&#x2F;记录正确选项个数</span><br><span class="line">	vector&lt;set&lt;char&gt; &gt; ans(m);&#x2F;&#x2F;记录每道题的答案</span><br><span class="line"></span><br><span class="line">	int opt_cnt;&#x2F;&#x2F;选项个数，答案个数</span><br><span class="line">	char c;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; m;i++) &#123;</span><br><span class="line">		&#x2F;&#x2F;满分值\选项个数\正确选项个数\所有正确选项</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;score[i], &amp;opt_cnt, &amp;ans_cnt[i]);</span><br><span class="line">		for (int j &#x3D; 0;j &lt; ans_cnt[i];j++) &#123;</span><br><span class="line">			scanf(&quot; %c&quot;, &amp;c);</span><br><span class="line">			ans[i].insert(c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;stl中重写了容器的&#x3D;&#x3D;操作符，当容器内的元素相同，则两个容器对象相同</span><br><span class="line">	int count, _score;</span><br><span class="line">	set&lt;char&gt; _ans;</span><br><span class="line">	vector&lt;int&gt; w_cnt(m, 0);&#x2F;&#x2F;每道题错误次数统计</span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		scanf(&quot;\n&quot;);</span><br><span class="line">		_score &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0;j &lt; m;j++) &#123;</span><br><span class="line">			&#x2F;&#x2F;非第一选项的成绩，先吸收一个空格</span><br><span class="line">			if (j !&#x3D; 0)</span><br><span class="line">				scanf(&quot; &quot;);</span><br><span class="line">			scanf(&quot;(%d&quot;, &amp;count);</span><br><span class="line">			for (int k &#x3D; 0;k &lt; count;k++) &#123;</span><br><span class="line">				scanf(&quot; %c&quot;, &amp;c);</span><br><span class="line">				_ans.insert(c);</span><br><span class="line">			&#125;</span><br><span class="line">			scanf(&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;判断答案是否正确</span><br><span class="line">			if (_ans &#x3D;&#x3D; ans[j]) &#123;</span><br><span class="line">				_score +&#x3D; score[j];</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				&#x2F;&#x2F;答案错误</span><br><span class="line">				w_cnt[j]++;</span><br><span class="line">			&#125;</span><br><span class="line">			_ans.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, _score);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;找到并输出最大错误次数</span><br><span class="line">	int maxtime &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0;i &lt; m;i++) &#123;</span><br><span class="line">		if (w_cnt[i] &gt; maxtime)</span><br><span class="line">			maxtime &#x3D; w_cnt[i];</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    if(maxtime&#x3D;&#x3D;0)&#123;</span><br><span class="line">        printf(&quot;Too simple&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;%d&quot;, maxtime);</span><br><span class="line">        for (int i &#x3D; 0;i &lt; m;i++) &#123;</span><br><span class="line">          if (maxtime&#x3D;&#x3D;w_cnt[i])</span><br><span class="line">            printf(&quot; %d&quot;,i+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1061-判断题</title>
    <url>/2020/03/27/PAT-B-1061-%E5%88%A4%E6%96%AD%E9%A2%98/</url>
    <content><![CDATA[<p>判断题的评判很简单，本题就要求你写个简单的程序帮助老师判题并统计学生们判断题的得分。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个不超过 100 的正整数 N 和 M，分别是学生人数和判断题数量。第二行给出 M 个不超过 5 的正整数，是每道题的满分值。第三行给出每道题对应的正确答案，0 代表“非”，1 代表“是”。随后 N 行，每行给出一个学生的解答。数字间均以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>按照输入的顺序输出每个学生的得分，每个分数占一行。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">2 1 3 3 4 5</span><br><span class="line">0 0 1 0 1 1</span><br><span class="line">0 1 1 0 0 1</span><br><span class="line">1 0 1 0 1 0</span><br><span class="line">1 1 0 0 1 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m,temp;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    vector&lt;int&gt; score(m);</span><br><span class="line">    vector&lt;int&gt; ans(m);</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;score[i]); </span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;ans[i]); </span><br><span class="line">    int _sum;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        _sum&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;temp); </span><br><span class="line">            if(temp&#x3D;&#x3D;ans[i])</span><br><span class="line">                _sum+&#x3D;score[i];</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,_sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1063-计算谱半径</title>
    <url>/2020/04/09/PAT-B-1063-%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84/</url>
    <content><![CDATA[<p>在数学中，矩阵的“谱半径”是指其特征值的模集合的上确界。换言之，对于给定的 <em>n</em> 个复数空间的特征值 { <em>a</em>1+<em>b</em>1<em>i</em>,⋯,<em>a**n</em>+<em>b<strong>n</strong>i</em> }，它们的模为实部与虚部的平方和的开方，而“谱半径”就是最大模。</p>
<p>现在给定一些复数空间的特征值，请你计算并输出这些特征值的谱半径。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数 N（≤ 10 000）是输入的特征值的个数。随后 N 行，每行给出 1 个特征值的实部和虚部，其间以空格分隔。注意：题目保证实部和虚部均为绝对值不超过 1000 的整数。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出谱半径，四舍五入保留小数点后 2 位。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">-1 0</span><br><span class="line">3 3</span><br><span class="line">0 -3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.24</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,r,v;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    double res&#x3D;0;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;r,&amp;v);</span><br><span class="line">        double temp &#x3D; sqrt(1.0*(r*r+v*v));</span><br><span class="line">        if(temp&gt;res)</span><br><span class="line">            res&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%.2lf&quot;,res);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1064-朋友数</title>
    <url>/2020/04/09/PAT-B-1064-%E6%9C%8B%E5%8F%8B%E6%95%B0/</url>
    <content><![CDATA[<p>如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如 123 和 51 就是朋友数，因为 1+2+3 = 5+1 = 6，而 6 就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出正整数 N。随后一行给出 N 个正整数，数字间以空格分隔。题目保证所有数字小于 104。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">123 899 51 998 27 33 36 12</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 6 9 26</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int record[90000] &#x3D; &#123; 0 &#125;;</span><br><span class="line">int getFriendN(int num) &#123;</span><br><span class="line">	int res &#x3D; 0;</span><br><span class="line">	do &#123;</span><br><span class="line">		int temp &#x3D; num % 10;</span><br><span class="line">		res +&#x3D; temp;</span><br><span class="line">		num &#x2F;&#x3D; 10;</span><br><span class="line">	&#125; while (num !&#x3D; 0);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n, num, count &#x3D; 0;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0;i &lt; n;i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">		int index &#x3D; getFriendN(num);</span><br><span class="line">		&#x2F;&#x2F;单独也算朋友数</span><br><span class="line">		if (record[index] &#x3D;&#x3D; 0) </span><br><span class="line">			count++;</span><br><span class="line">		record[index]++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, count);</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0;i &lt; 90000;i++) &#123;</span><br><span class="line">		if (count &#x3D;&#x3D; 0)</span><br><span class="line">			break;</span><br><span class="line">		if (record[i]!&#x3D;0) &#123;</span><br><span class="line">			printf(&quot;%d&quot;, i);</span><br><span class="line">			count--;</span><br><span class="line">			if (count !&#x3D; 0)</span><br><span class="line">				printf(&quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1066-图像过滤</title>
    <url>/2020/03/27/PAT-B-1066-%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<p>图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一幅图像的分辨率，即两个正整数 <em>M</em> 和 <em>N</em>（0&lt;<em>M</em>,<em>N</em>≤500），另外是待过滤的灰度值区间端点 <em>A</em> 和 <em>B</em>（0≤<em>A</em>&lt;<em>B</em>≤255）、以及指定的替换灰度值。随后 <em>M</em> 行，每行给出 <em>N</em> 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出按要求过滤后的图像。即输出 <em>M</em> 行，每行 <em>N</em> 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 <code>000</code>），其间以一个空格分隔。行首尾不得有多余空格。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 100 150 0</span><br><span class="line">3 189 254 101 119</span><br><span class="line">150 233 151 99 100</span><br><span class="line">88 123 149 0 255</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">003 189 254 000 000</span><br><span class="line">000 233 151 099 000</span><br><span class="line">088 000 000 000 255</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,m,begin,end,rep;</span><br><span class="line">	scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;m,&amp;begin,&amp;end,&amp;rep);</span><br><span class="line">    vector&lt;int&gt; v(m);</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;v[i]);</span><br><span class="line">            &#x2F;&#x2F;将满足在区间内的元素替换掉</span><br><span class="line">            if(v[i]&gt;&#x3D;begin&amp;&amp;v[i]&lt;&#x3D;end)</span><br><span class="line">                v[i]&#x3D;rep;</span><br><span class="line">            printf(&quot;%03d&quot;,v[i]);</span><br><span class="line">            if(i!&#x3D;m-1)</span><br><span class="line">                printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1067-试密码</title>
    <url>/2020/05/12/PAT-B-1067-%E8%AF%95%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 <code>Welcome in</code>，并结束程序；如果是错误的，则在一行中按格式输出 <code>Wrong password: 用户输入的错误密码</code>；当错误尝试达到 N 次时，再输出一行 <code>Account locked</code>，并结束程序。</p>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Correct%pw 3</span><br><span class="line">correct%pw</span><br><span class="line">Correct@PW</span><br><span class="line">whatisthepassword!</span><br><span class="line">Correct%pw</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wrong password: correct%pw</span><br><span class="line">Wrong password: Correct@PW</span><br><span class="line">Wrong password: whatisthepassword!</span><br><span class="line">Account locked</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cool@gplt 3</span><br><span class="line">coolman@gplt</span><br><span class="line">coollady@gplt</span><br><span class="line">cool@gplt</span><br><span class="line">try again</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wrong password: coolman@gplt</span><br><span class="line">Wrong password: coollady@gplt</span><br><span class="line">Welcome in</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string correct, s;</span><br><span class="line">    int t, cnt &#x3D; 0;</span><br><span class="line">    cin &gt;&gt; correct &gt;&gt; t;</span><br><span class="line">    getchar(); &#x2F;&#x2F;吃回车</span><br><span class="line">    do&#123;</span><br><span class="line">        &#x2F;&#x2F;正确密码不带空格不代表用户不会输入</span><br><span class="line">        getline(cin, s);</span><br><span class="line">        if(s&#x3D;&#x3D;&quot;#&quot;)</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        if(correct&#x3D;&#x3D;s)&#123;</span><br><span class="line">            printf(&quot;Welcome in&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;Wrong password: %s\n&quot;,s.c_str());</span><br><span class="line">            </span><br><span class="line">            if (++cnt &#x3D;&#x3D; t) &#123;</span><br><span class="line">                printf(&quot;Account locked&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;while(s !&#x3D; &quot;#&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1071-小赌怡情</title>
    <url>/2020/03/27/PAT-B-1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85/</url>
    <content><![CDATA[<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n1 b t n2</span><br></pre></td></tr></table></figure>

<p>其中 <code>n1</code> 和 <code>n2</code> 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。<code>b</code> 为 0 表示玩家赌<code>小</code>，为 1 表示玩家赌<code>大</code>。<code>t</code> 表示玩家下注的筹码数，保证在整型范围内。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每一次游戏，根据下列情况对应输出（其中 <code>t</code> 是玩家下注量，<code>x</code> 是玩家当前持有的筹码量）：</p>
<ul>
<li>玩家赢，输出 <code>Win t!  Total = x.</code>；</li>
<li>玩家输，输出 <code>Lose t.  Total = x.</code>；</li>
<li>玩家下注超过持有的筹码量，输出 <code>Not enough tokens.  Total = x.</code>；</li>
<li>玩家输光后，输出 <code>Game Over.</code> 并结束程序。</li>
</ul>
<h3 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例 1："></a>输入样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 4</span><br><span class="line">8 0 100 2</span><br><span class="line">3 1 50 1</span><br><span class="line">5 1 200 6</span><br><span class="line">7 0 200 8</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例 1："></a>输出样例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win 100!  Total &#x3D; 200.</span><br><span class="line">Lose 50.  Total &#x3D; 150.</span><br><span class="line">Not enough tokens.  Total &#x3D; 150.</span><br><span class="line">Not enough tokens.  Total &#x3D; 150.</span><br></pre></td></tr></table></figure>

<h3 id="输入样例-2："><a href="#输入样例-2：" class="headerlink" title="输入样例 2："></a>输入样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100 4</span><br><span class="line">8 0 100 2</span><br><span class="line">3 1 200 1</span><br><span class="line">5 1 200 6</span><br><span class="line">7 0 200 8</span><br></pre></td></tr></table></figure>

<h3 id="输出样例-2："><a href="#输出样例-2：" class="headerlink" title="输出样例 2："></a>输出样例 2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Win 100!  Total &#x3D; 200.</span><br><span class="line">Lose 200.  Total &#x3D; 0.</span><br><span class="line">Game Over.</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int base,n;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;base,&amp;n);</span><br><span class="line">    int n1,b,t,n2;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    while(n--&amp;&amp;base&gt;0)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;n1,&amp;b,&amp;t,&amp;n2);</span><br><span class="line">        &#x2F;&#x2F;赌注超过base</span><br><span class="line">        if(t&gt;base)&#123;</span><br><span class="line">            printf(&quot;Not enough tokens.  Total &#x3D; %d.\n&quot;,base);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;  </span><br><span class="line">        &#x2F;&#x2F;赌赢</span><br><span class="line">        if(n2&gt;n1&amp;&amp;b&#x3D;&#x3D;1||n2&lt;n1&amp;&amp;b&#x3D;&#x3D;0)&#123;</span><br><span class="line">            base+&#x3D;t;</span><br><span class="line">            printf(&quot;Win %d!  Total &#x3D; %d.\n&quot;,t,base);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;下注的筹码数不能超过自己帐户上拥有的筹码数</span><br><span class="line">            base-&#x3D;t;</span><br><span class="line">            printf(&quot;Lose %d.  Total &#x3D; %d.\n&quot;,t,base);</span><br><span class="line">        &#125;  </span><br><span class="line">        if(base&#x3D;&#x3D;0)&#123;</span><br><span class="line">            printf(&quot;Game Over.\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1072-开学寄语</title>
    <url>/2020/05/13/PAT-B-1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/</url>
    <content><![CDATA[<p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<p><img src="/2020/05/13/PAT-B-1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/1.JPG" alt></p>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名缩写: 物品编号1 物品编号2 ……</span><br></pre></td></tr></table></figure>

<p>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">2333 6666</span><br><span class="line">CYLL 3 1234 2345 3456</span><br><span class="line">U 4 9966 6666 8888 6666</span><br><span class="line">GG 2 2333 7777</span><br><span class="line">JJ 3 0012 6666 2333</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">U: 6666 6666</span><br><span class="line">GG: 2333</span><br><span class="line">JJ: 6666 2333</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;&#x2F;&#x2F;学生人数和需要被查缴的物品种类数</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    int i,j;</span><br><span class="line">    string temp;</span><br><span class="line">    set&lt;string&gt; fib;&#x2F;&#x2F;存储违禁的编号</span><br><span class="line">    for(i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;temp;</span><br><span class="line">        fib.insert(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();&#x2F;&#x2F;吸收回车</span><br><span class="line">    string name;</span><br><span class="line">    int cnt,flag;</span><br><span class="line">    set&lt;string&gt;::iterator it;</span><br><span class="line">    vector&lt;string&gt; out;</span><br><span class="line">    int stuCnt&#x3D;0,stuffCnt&#x3D;0;</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">        flag&#x3D;0;</span><br><span class="line">        out.clear();</span><br><span class="line">        cin&gt;&gt;name&gt;&gt;cnt;</span><br><span class="line">        for(j&#x3D;0;j&lt;cnt;j++)&#123;</span><br><span class="line">            cin&gt;&gt;temp;</span><br><span class="line">            it &#x3D; fib.find(temp);</span><br><span class="line">            if(it!&#x3D;fib.end())&#123;</span><br><span class="line">                &#x2F;&#x2F;找到了</span><br><span class="line">                flag&#x3D;1;</span><br><span class="line">                out.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getchar();&#x2F;&#x2F;吸收回车</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            stuCnt++;</span><br><span class="line">            stuffCnt+&#x3D;out.size();</span><br><span class="line">            printf(&quot;%s:&quot;,name.c_str());</span><br><span class="line">            for(int k&#x3D;0;k&lt;out.size();k++)&#123;</span><br><span class="line">                printf(&quot; %s&quot;,out[k].c_str());</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d %d&quot;,stuCnt,stuffCnt);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(20)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1076-Wifi密码</title>
    <url>/2020/03/26/PAT-B-1076-Wifi%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
<p><img src="https://images.ptausercontent.com/7e56be3f-caba-45f1-b9cb-38a96d44de76.jpg" alt="wifi.jpg"></p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 <code>编号-答案</code> 的格式给出一道题的 4 个选项，<code>T</code> 表示正确选项，<code>F</code> 表示错误选项。选项间用空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出 wifi 密码。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">A-T B-F C-F D-F</span><br><span class="line">C-T B-F A-F D-F</span><br><span class="line">A-F D-F C-F B-T</span><br><span class="line">B-T A-F C-F D-F</span><br><span class="line">B-F D-T A-F C-F</span><br><span class="line">A-T C-F B-F D-F</span><br><span class="line">D-T B-F C-F A-F</span><br><span class="line">C-T A-F B-F D-F</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13224143</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    string str;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        getline(cin,str);</span><br><span class="line">        int index &#x3D; str.find(&#39;T&#39;);</span><br><span class="line">        char c &#x3D; str[index-2];</span><br><span class="line">        printf(&quot;%d&quot;,c-&#39;A&#39;+1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1081-检查密码</title>
    <url>/2020/03/26/PAT-B-1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 <code>.</code>，还必须既有字母也有数字。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个用户的密码，在一行中输出系统反馈信息，分以下5种：</p>
<ul>
<li>如果密码合法，输出<code>Your password is wan mei.</code>；</li>
<li>如果密码太短，不论合法与否，都输出<code>Your password is tai duan le.</code>；</li>
<li>如果密码长度合法，但存在不合法字符，则输出<code>Your password is tai luan le.</code>；</li>
<li>如果密码长度合法，但只有字母没有数字，则输出<code>Your password needs shu zi.</code>；</li>
<li>如果密码长度合法，但只有数字没有字母，则输出<code>Your password needs zi mu.</code>。</li>
</ul>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">123s</span><br><span class="line">zheshi.wodepw</span><br><span class="line">1234.5678</span><br><span class="line">WanMei23333</span><br><span class="line">pass*word.6</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your password is tai duan le.</span><br><span class="line">Your password needs shu zi.</span><br><span class="line">Your password needs zi mu.</span><br><span class="line">Your password is wan mei.</span><br><span class="line">Your password is tai luan le.</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注意本题当初在做的时候有个小坑没有注意，就是密码是可以带空格的，所以要用getline来接收输入</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isAlpha(char c) &#123;</span><br><span class="line">	return (c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) || (c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isNum(char c) &#123;</span><br><span class="line">	return c - &#39;0&#39; &gt;&#x3D; 0 &amp;&amp; c - &#39;0&#39; &lt;&#x3D; 9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	char str[81];</span><br><span class="line">	bool num_flag, alp_flag, complex_flag;&#x2F;&#x2F;数字和字母的检测位</span><br><span class="line">    getchar();</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		num_flag &#x3D; alp_flag &#x3D; complex_flag &#x3D; false;</span><br><span class="line">        cin.getline(str,81);</span><br><span class="line">		&#x2F;&#x2F;scanf(&quot;%s&quot;, str);</span><br><span class="line">		&#x2F;&#x2F;不少于6个字符组成</span><br><span class="line">		&#x2F;&#x2F;只能有英文字母、数字和小数点</span><br><span class="line">		&#x2F;&#x2F;还必须既有字母也有数字</span><br><span class="line">		int len &#x3D; strlen(str);</span><br><span class="line">		if (len &lt; 6) &#123;</span><br><span class="line">			printf(&quot;Your password is tai duan le.\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0;i &lt; len; i++) &#123;</span><br><span class="line">			if (isAlpha(str[i]))</span><br><span class="line">				alp_flag &#x3D; true;</span><br><span class="line">			else if (isNum(str[i]))</span><br><span class="line">				num_flag &#x3D; true;</span><br><span class="line">			else if (str[i] !&#x3D; &#39;.&#39;) </span><br><span class="line">				complex_flag &#x3D; true;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		if (!alp_flag) &#123;</span><br><span class="line">			printf(&quot;Your password needs zi mu.\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!num_flag) &#123;</span><br><span class="line">			printf(&quot;Your password needs shu zi.\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (complex_flag) &#123;</span><br><span class="line">			printf(&quot;Your password is tai luan le.\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Your password is wan mei.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT-B-1086-就不告诉你</title>
    <url>/2020/03/26/PAT-B-1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0/</url>
    <content><![CDATA[<p>做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。</p>
<p><img src="https://images.ptausercontent.com/0c3a4497-27c3-45ea-9c8e-5a1ab2df48af.jpg" alt="53.jpg"></p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中倒着输出 A 和 B 的乘积。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">53</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n,m;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    int res &#x3D; n*m;</span><br><span class="line">    bool flag&#x3D;false;&#x2F;&#x2F;最高位确认位</span><br><span class="line">    do&#123;</span><br><span class="line">        int num &#x3D; res%10;</span><br><span class="line">        if(!flag&amp;&amp;num!&#x3D;0)</span><br><span class="line">            flag&#x3D;true;</span><br><span class="line">        if(flag)</span><br><span class="line">            printf(&quot;%d&quot;,num);</span><br><span class="line">        res&#x2F;&#x3D;10; </span><br><span class="line">    &#125;while(res!&#x3D;0);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-B-1091-N-自守数</title>
    <url>/2020/03/26/PAT-B-1091-N-%E8%87%AA%E5%AE%88%E6%95%B0/</url>
    <content><![CDATA[<p>如果某个数 <em>K</em> 的平方乘以 <em>N</em> 以后，结果的末尾几位数等于 <em>K</em>，那么就称这个数为“<em>N</em>-自守数”。例如 3×922=25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。</p>
<p>本题就请你编写程序判断一个给定的数字是否关于某个 <em>N</em> 是 <em>N</em>-自守数。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>M</em>（≤20），随后一行给出 <em>M</em> 个待检测的、不超过 1000 的正整数。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个需要检测的数字，如果它是 <em>N</em>-自守数就在一行中输出最小的 <em>N</em> 和 <em>N*<em>K</em>2 的值，以一个空格隔开；否则输出 <code>No</code>。注意题目保证 *N</em>&lt;10。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">92 5 233</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 25392</span><br><span class="line">1 25</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool judge(int i,int num)&#123;</span><br><span class="line">    int res &#x3D; i*num*num;</span><br><span class="line">    int product&#x3D;1,temp &#x3D;num;</span><br><span class="line">    do&#123;</span><br><span class="line">        temp&#x2F;&#x3D;10;</span><br><span class="line">        product*&#x3D;10;</span><br><span class="line">    &#125;while(temp!&#x3D;0);</span><br><span class="line"></span><br><span class="line">    if((res-num)%product&#x3D;&#x3D;0)</span><br><span class="line">        return true;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    bool flag;</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        flag &#x3D; false;</span><br><span class="line">        int num;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;判断num是否为某位几位</span><br><span class="line">            if(judge(i,num))&#123;</span><br><span class="line">                flag&#x3D;true;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i,i*num*num);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)</span><br><span class="line">            printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PAT-B</category>
      </categories>
      <tags>
        <tag>PAT-B(15)</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis概述</title>
    <url>/2020/03/16/Redis%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Servlet线程安全问题</title>
    <url>/2020/03/16/Servlet%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;Servlet是线程不安全的。Servlet体系是建立在java多线程的基础之上的,它的生命周期是由Tomcat来维护的。当客户端第一次请求Servlet的时候，tomcat会根据web.xml配置文件实例化servlet；当又有一个客户端访问该servlet的时候，不会再实例化该servlet，也就是多个线程在使用这个实例。</p>
<h3 id="Servlet线程池"><a href="#Servlet线程池" class="headerlink" title="Servlet线程池"></a>Servlet线程池</h3><p>&emsp;&emsp;serlvet采用多线程来处理多个请求同时访问，Tomcat容器维护了一个线程池来服务请求。线程池实际上是等待执行代码的一组线程叫做工作组线程<code>(Worker Thread)</code>，Tomcat容器使用一个 调度线程来管理工作组线程<code>(Dispatcher Thead)</code>。</p>
<img src="/2020/03/16/Servlet%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/1.jpg" style="zoom:80%;">

<p>&emsp;&emsp;当容器收到一个Servlet请求，Dispatcher线程从线程池中选出一个工作组线程，将请求传递给该线程，然后由该线程来执行Servlet的service方法。当这个线程正在执行的时候，容器收到另一个请求，调度者线程将从线程池中选出另外一个工作组线程来服务则个新的请求。容器并不关心这个请求是否访问的是同一个Servlet还是另一个Servlet。当容器收到对同一个Servlet的多个请求的时候，那这个servlet的service方法将在多线程中并发的执行。</p>
<h3 id="多线程和单线程Servlet区别"><a href="#多线程和单线程Servlet区别" class="headerlink" title="多线程和单线程Servlet区别"></a>多线程和单线程Servlet区别</h3><ul>
<li>多线程下每个线程对局部变量都会有自己的一份copy，这样对局部变量的修改只会影响到自己的copy而不会对别的线程产生影响，线程安全的。</li>
<li>对于实例变量来说，由于servlet在Tomcat中是以单例模式存在的，所有的线程共享实例变量。多个线程 对共享资源的访问就造成了线程不安全问题。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;Servlet的线程安全问题只有在大量的并发访问时才会显现出来，并且很难发现，因此在编写Servlet程序时要特别注意。线程安全问题主要是由实例变量——全局变量造成的,因此在Servlet中应避免使用实例变量。如果应用程序设计无法避免使用实例变量，那么使用同步来保护要使用的实例变量，但为保证系统的最佳性能，应该 同步可用性最小的代码路径。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Redis高并发分布式锁</title>
    <url>/2020/02/14/Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h3 id="0、简述"><a href="#0、简述" class="headerlink" title="0、简述"></a>0、简述</h3><h4 id="分布式锁的作用"><a href="#分布式锁的作用" class="headerlink" title="分布式锁的作用"></a>分布式锁的作用</h4><blockquote>
<p>解决高并发环境下数据一致性（<strong>Consistency</strong>）问题，将并发执行的代码串行化执行。</p>
</blockquote>
<h4 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h4><blockquote>
<p>&emsp;&emsp;由于并发操作破坏了事务的隔离性（<strong>Isolation</strong>）—即某个事务的数据可能会收到其他事务操作的影响，也会引发修改丢失、读脏数据、不可重复读等的一系列问题。给事务加锁（LOCK）是解决并发操作破坏隔离性的解决方案。</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><blockquote>
<p>&emsp;&emsp;Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hy.perloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster——<a href="https://redis.io/" target="_blank" rel="noopener">摘自官网的介绍</a></p>
<p>&emsp;&emsp;Redis是一个开源(BSD许可)的内存数据结构存储，用作数据库、缓存和消息代理。它支持诸如字符串、散列、列表、集、带范围查询的排序集、位图、hy.perloglogs（博主注：HyperLogLog算法经常在数据库中被用来统计某一字段的Distinct Value）、带半径查询和流的地理空间索引等数据结构。Redis具有内置的复制、Lua脚本、LRU清除、事务和不同级别的磁盘持久性，并通过Redis哨兵和带有Redis集群的自动分区提供高可用性，Redis是单线程模型，具有把并行转化为串行的天然优势，当然也需要付出速度减慢的代价。</p>
</blockquote>
<h3 id="1、分布式问题"><a href="#1、分布式问题" class="headerlink" title="1、分布式问题"></a>1、分布式问题</h3><p>在对代码进行加锁后也不要忘记最后要将锁释放，这是最基本的锁的使用规则</p>
<h4 id="业务代码异常"><a href="#业务代码异常" class="headerlink" title="业务代码异常"></a>业务代码异常</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//问题：当执行业务代码时抛异常，锁未正常释放</span></span><br><span class="line">&gt;<span class="comment">//java异常的处理，在finally代码块中将锁释放</span></span><br><span class="line">&gt;<span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">//业务代码</span></span><br><span class="line">&gt;&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">   <span class="comment">//异常处理</span></span><br><span class="line">&gt;&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="comment">//释放锁</span></span><br><span class="line">   lock.unlock();</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="服务器宕机"><a href="#服务器宕机" class="headerlink" title="服务器宕机"></a>服务器宕机</h4><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&#x2F;&#x2F;问题：执行业务代码服务器宕机，锁未释放</span><br><span class="line">&gt;&#x2F;&#x2F;给锁设置超时时间，注意保证【设置锁和超时时间】操作的一致性</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="超时时间设置不合理"><a href="#超时时间设置不合理" class="headerlink" title="超时时间设置不合理"></a>超时时间设置不合理</h4><ul>
<li><p>第一个线程把第二个线程的锁给释放了</p>
<blockquote>
<p>保证每个线程只释放自己的锁，给每个线程后加唯一标识UUID</p>
</blockquote>
</li>
<li><p>设置合理的超时时间</p>
<blockquote>
<p>开启分线程检查当前线程存储与redis中的锁是否还存在，为主线程的过期时间提供续航</p>
</blockquote>
</li>
</ul>
<h4 id="主从集群架构"><a href="#主从集群架构" class="headerlink" title="主从集群架构"></a>主从集群架构</h4><blockquote>
<p>主节点已上锁，但未来得及与从节点同步主节点宕机</p>
<p>解决方案：待续。。。</p>
</blockquote>
<h3 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h3>]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>Redis高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ map对象的序列化和反序列化</title>
    <url>/2020/02/09/c-map%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>String、StringBuffer、StringBuilder</title>
    <url>/2020/05/28/String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>String是一个final修饰类，所有的属性也是final。所以具有不可变性，对字符串的操作，比如拼接、剪切都会产生新的String对象。</li>
<li>StringBuffer本质是一个线程安全的可以修改字符串序列。因为保证线程安全（sync），所以会带来额外的性能消耗。</li>
<li>StringBuilder本质上和StringBuffer没有区别，但是StringBuilder去掉了线程安全部分，提高了操作效率。是绝大部分情况下字符串拼接的首选。</li>
</ul>
<p>注：如果确定拼接字符串会发生多次，并且长度可预计，那么可在开始的时候指定长度的大小，避免数组的扩容造成的开销。</p>
]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
  </entry>
  <entry>
    <title>Trie字典树</title>
    <url>/2020/02/28/Trie%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<p>&emsp;&emsp;Trie树，俗称字典树，最早是应用于通讯录中人名的查找而设计的查找树。字典树的查找效率高，通过利用公共前缀来减少查询时间。Trie树的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num_chars = <span class="number">28</span>;<span class="comment">//represent </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	Record* data;<span class="comment">//数据域</span></span><br><span class="line">	node* branch[num_chars];<span class="comment">//一个节点下还有不同字母的分支</span></span><br><span class="line">	node();<span class="comment">//构造方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注：Trie树中只有当到达字符串末尾时（Trie树中存在这个字符串），data数据域才会有值。表示当前字符串存入当前Trie树，否则其他节点data指针为空。</em></p>
<h3 id="Trie树的查找"><a href="#Trie树的查找" class="headerlink" title="Trie树的查找"></a>Trie树的查找</h3><p>按照目标字符串，一个字符一个字符的向下查找，直到节点为null或字符串全部遍历完</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool search(const key&amp; t)&#123;</span><br><span class="line">	int position&#x3D;0;</span><br><span class="line">	char next_char;</span><br><span class="line">	node *loc &#x3D; root;</span><br><span class="line">	while(loc!&#x3D;null&amp;&amp;(next_char&#x3D;t.key_letter(position))!&#x3D;&#39;&#39;)&#123;</span><br><span class="line">		location &#x3D; location-&gt;branch[alphabtic_order(next_char)];&#x2F;&#x2F;根据字母获取分支</span><br><span class="line">		position++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(position!&#x3D;null&amp;&amp;position-&gt;data!&#x3D;null)</span><br><span class="line">		return 1;</span><br><span class="line">	else</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trie树的插入"><a href="#Trie树的插入" class="headerlink" title="Trie树的插入"></a>Trie树的插入</h3><p>向下查询到某个合适的位置，将data指针设置成新键的记录信息。若中途遇空，则必须将节点都插入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool insert(const Record&amp; new_data)&#123;</span><br><span class="line">	if(root&#x3D;&#x3D;null)</span><br><span class="line">		root &#x3D; new node;</span><br><span class="line">	int p&#x3D;0,next_position;</span><br><span class="line">	char next_char;</span><br><span class="line">	node *loca &#x3D; root;</span><br><span class="line">	while(loca!&#x3D;null&amp;&amp;(next_char&#x3D;new_data.key_letter(p))!&#x3D;&#39;&#39;)&#123;</span><br><span class="line">		next_position &#x3D; alphabetic_order(next_char);</span><br><span class="line">		if(loca-&gt;branch[next_position]&#x3D;&#x3D;null)</span><br><span class="line">			loca-&gt;branch[next_position]&#x3D;new node();</span><br><span class="line">		loca&#x3D;loca-&gt;branch[next_position];</span><br><span class="line">		p++;</span><br><span class="line">	&#125;&#x2F;&#x2F;至此，已遍历完待插入字符串的所有字符。此时location的位置在最后一个字母的节点</span><br><span class="line">	if(loca-&gt;data!&#x3D;null)</span><br><span class="line">		return;&#x2F;&#x2F;已经存在</span><br><span class="line">	else</span><br><span class="line">		loca-&gt;data&#x3D;new Record(new_data);</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trie树的删除"><a href="#Trie树的删除" class="headerlink" title="Trie树的删除"></a>Trie树的删除</h3><p>&emsp;&emsp;沿着路径找到相应data成员设置为null。若这个节点所有成员为null（分支和data）则删除这个节点。思路：利用递归或栈。</p>
]]></content>
      <categories>
        <category>查找树</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>exception和error的区别</title>
    <url>/2020/05/28/exception%E5%92%8Cerror%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="exception和error的区别"><a href="#exception和error的区别" class="headerlink" title="exception和error的区别"></a>exception和error的区别</h3><p>exception和error都继承自Throwable，在Java中只有Throwable类型的实例才可以被抛出和捕获。</p>
<p>error指正常情况下不太可能出现的情况，绝大部分的error或导致程序崩溃，处于非正常的不可恢复的状态。</p>
<blockquote>
<p>如OutOfMemoryError、StackOverflowError。</p>
<p>是程序中不应该试图捕获的严重错误</p>
</blockquote>
<p>exception是程序正常运行中可以预料的意外情况，可以捕获并处理。</p>
<h3 id="运行时异常和一般异常的区别"><a href="#运行时异常和一般异常的区别" class="headerlink" title="运行时异常和一般异常的区别"></a>运行时异常和一般异常的区别</h3><p>受检查异常：在编译时被强制检查的异常。在方法的声明中声明的异常。</p>
<blockquote>
<p>如classNotFoundException、IOException</p>
</blockquote>
<p>不受检查的异常：不受检查的异常通常是在编码中可以避免的逻辑错误，根据需求来判断如何处理，不需要再编译期强制要求。</p>
<h3 id="几种常见的运行时异常"><a href="#几种常见的运行时异常" class="headerlink" title="几种常见的运行时异常"></a>几种常见的运行时异常</h3><p>运行时异常RuntimeException是所有不受检查异常的基类</p>
<p>NullPointException、ClassCastException、NumberFormatException、IndexOutOfBoundsException</p>
]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
  </entry>
  <entry>
    <title>http协议</title>
    <url>/2020/02/21/http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<blockquote>
<p>HTTP/1.0和HTTP/1.1的区别：1.0获取到一个web资源就断开连接，而1.1可以获取多个web资源。</p>
</blockquote>
<h3 id="一个完整的HTTP请求包含内容：（一个请求行、若干个请求头、实体内容-也称为请求体-）"><a href="#一个完整的HTTP请求包含内容：（一个请求行、若干个请求头、实体内容-也称为请求体-）" class="headerlink" title="一个完整的HTTP请求包含内容：（一个请求行、若干个请求头、实体内容{也称为请求体}）"></a>一个完整的HTTP请求包含内容：（一个请求行、若干个请求头、实体内容{也称为请求体}）</h3><blockquote>
<p>请求行（描述客户端的请求方式、请求的资源名称、使用的http协议的版本号）：</p>
</blockquote>
<blockquote>
<p>请求方式：post、get、head、options、delete、trace、put</p>
</blockquote>
<blockquote>
<blockquote>
<p>get请求方式：可以在请求的URL地址后面以？的形式带上提交给服务器的数据，多个数据之间以&amp;进行<br>分隔；</p>
<blockquote>
<p>特点：在URL后携带的请求参数是有限制的，数据容量通常不能超过1k。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>注意：默认的请求方式是get请求。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>post请求方式：可以在请求体中向服务器发送数据</p>
<blockquote>
<p>特点：传输的数据无限制。</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="请求头（用于描述客户端请求哪台主机，以及客户端的一些环境信息）："><a href="#请求头（用于描述客户端请求哪台主机，以及客户端的一些环境信息）：" class="headerlink" title="请求头（用于描述客户端请求哪台主机，以及客户端的一些环境信息）："></a>请求头（用于描述客户端请求哪台主机，以及客户端的一些环境信息）：</h2><blockquote>
<p>accept:用于告诉服务器，客户机支持的数据类型</p>
</blockquote>
<blockquote>
<p>accept-charset:用于告诉服务器，客户机支持采用的编码</p>
</blockquote>
<blockquote>
<p>accept-encoding:用于告诉服务器，客户机支持的数据压缩格式</p>
</blockquote>
<blockquote>
<p>accept-language:客户机的语言环境（和国际化相关）</p>
</blockquote>
<blockquote>
<p>host:客户机通过这个头告诉服务器，想访问的主机名</p>
</blockquote>
<blockquote>
<p>if-modified-since:客户机通过这个头告诉服务器,资源的缓存时间</p>
</blockquote>
<blockquote>
<p>referer:客户机通过这个头告诉服务器,他是从哪个资源来访问服务器的（可以用来做防盗链接）</p>
</blockquote>
<blockquote>
<p>user-agent:客户机通过这个头告诉服务器，客户机的软件环境（操作系统、内核、浏览器等等）</p>
</blockquote>
<blockquote>
<p>cookie:客户机通过这个头可以向服务器带数据</p>
</blockquote>
<blockquote>
<p>connection:请求完链接之后是断开连接还是保持连接</p>
</blockquote>
<blockquote>
<p>date:当前的时间值</p>
</blockquote>
<h2 id="HTTP响应："><a href="#HTTP响应：" class="headerlink" title="HTTP响应："></a>HTTP响应：</h2><blockquote>
<p>一个HTTP响应代表服务器向客户端回送的数据，它包括：<br>一个状态行、若干个消息头、实体内容</p>
</blockquote>
<blockquote>
<p>状态行（用来描述服务器对请求的处理结果）<br>内容包括：http协议及其版本、状态码<br>常用的状态码：</p>
</blockquote>
<blockquote>
<p>100-199（表示成功接收，等待用户的下一次请求，完成处理过程）</p>
</blockquote>
<blockquote>
<p>200（请求处理完成）</p>
</blockquote>
<blockquote>
<p>302（请求重定向） 307/304（拿缓存）</p>
</blockquote>
<blockquote>
<p>404（客户端请求有误，服务器没有该资源）</p>
</blockquote>
<blockquote>
<p>403（没有访问权限，服务器拒绝提供资源）</p>
</blockquote>
<blockquote>
<p>500（服务器端出现错误，程序出现问题）</p>
</blockquote>
<h2 id="响应头："><a href="#响应头：" class="headerlink" title="响应头："></a>响应头：</h2><blockquote>
<p>location：这个头配合302状态码使用，用于告诉客户找谁</p>
</blockquote>
<blockquote>
<p>server：服务器通过这个头，告诉浏览器服务器的类型</p>
</blockquote>
<blockquote>
<p>content-encoding：“gzip”服务器通过这个头，告诉浏览器数据的压缩格式</p>
</blockquote>
<blockquote>
<p>content-length：服务器通过这个头，告诉浏览器回送数据的长度</p>
</blockquote>
<blockquote>
<p>content-language：回送的语言环境</p>
</blockquote>
<blockquote>
<p>content-type：服务器通过这个头，告诉浏览器回送数据的类型（不同的头可在tomcat/conf/web.xml中查询）</p>
</blockquote>
<blockquote>
<p>last-modified：服务器通过这个头，告诉浏览器当前资源的缓存时间</p>
</blockquote>
<blockquote>
<p>refresh：服务器通过这个头，告诉浏览器隔多长时间刷新一次，可指定刷新的页面</p>
</blockquote>
<blockquote>
<p>content-disposition：服务器通过这个头，告诉浏览器以下载的方式打开数据</p>
</blockquote>
<blockquote>
<p>transfer-encoding：服务器通过这个头，告诉浏览器数据的传输格式</p>
</blockquote>
<blockquote>
<p>etag：缓存相关的头（判断前后的etag是否相等，决定是否要用缓存页面）</p>
</blockquote>
<blockquote>
<p>expires：服务器通过这个头，告诉浏览器把回送的数据资源的缓存时间；-1或0 则不缓存</p>
</blockquote>
<blockquote>
<p>cache-control/program:服务器通过这两个头，告诉浏览器不要缓存数据（no-cache）；注意：实时性要求高的一般不缓存</p>
</blockquote>
<blockquote>
<p>connection:响应完链接之后是断开连接还是保持连接</p>
</blockquote>
<blockquote>
<p>date:当前的时间值</p>
</blockquote>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>huffman文件压缩算法实践</title>
    <url>/2020/02/24/huffman%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;收到疫情的影响，今年包括考研的时间线都往后顺延，因此也多了好多准备的时间。为了较好的掌握c++的语法，以及考虑到Huffman算法的易实现性，我便产生了写huffman压缩的想法。待到真正上手写代码的时候，发现其设计的细节特别多，一度也让我有了放弃的念头！好在都被我一一解决，哈哈！还是挺高兴的。</p>
<p>&emsp;&emsp;这个小项目其实说难也不难，但前提是得要熟悉三方面的知识。第一就是最基本的Huffman编码；第二是对数据的移位操作——对二进制数的理解；第三还得熟悉c++（注：或者其他语言）对文件字节流的操作。总的来说思路还是比较清晰的。</p>
<h3 id="Huffman算法"><a href="#Huffman算法" class="headerlink" title="Huffman算法"></a>Huffman算法</h3><p>&emsp;&emsp;Huffman编码法被称为最优编码法，所获得的编码为无重复前缀码，其编码的依据是根据被编码的字符在整个原文中出现的频率，频率越高，代表该字符的编码长度越短，因此通过编码可以减少文件的大小。</p>
<h4 id="Huffman树的生成过程"><a href="#Huffman树的生成过程" class="headerlink" title="Huffman树的生成过程"></a>Huffman树的生成过程</h4><ol>
<li>首先统计出各个字符出现的频率作为权值，然后每个字符对应创建一个节点，节点保存字符值、权值、编码。</li>
<li>取出所有节点中权值最小的两个节点（利用堆或者优先队列），将其权值相加后作为新节点的权值，并将新节点作为这两个节点的双亲节点。将该节点重新放入所有节点中。</li>
<li>重复 2 步骤，直到剩下一个节点，则所有节点构成一个Huffman树，该节点为树根 </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">HuffmanTree</span>(<span class="title">T</span>* <span class="title">info</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//声明huffman树的优先队列（底层是用堆实现的）</span></span><br><span class="line">	priority_queue&lt;Node*, <span class="built_in">vector</span>&lt;Node*&gt;,great&lt;Node*&gt;&gt; treeNodePQ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//invalid表示字符的统计次数为0，因此不包括在Huffman树中</span></span><br><span class="line">		<span class="keyword">if</span> (info[i]._chCount != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Node* tmp = <span class="keyword">new</span> Node(info[i]);</span><br><span class="line">			treeNodePQ.push(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* Left;</span><br><span class="line">	Node* Right;</span><br><span class="line">	<span class="keyword">while</span> (treeNodePQ.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//获取堆顶两个最小的node</span></span><br><span class="line">		Left = treeNodePQ.top();</span><br><span class="line">		treeNodePQ.pop();</span><br><span class="line"></span><br><span class="line">		Right = treeNodePQ.top();</span><br><span class="line">		treeNodePQ.pop();</span><br><span class="line"></span><br><span class="line">		Node* Parent = <span class="keyword">new</span> Node(Left-&gt;_weight + Right-&gt;_weight);</span><br><span class="line">		Parent-&gt;_left = Left;</span><br><span class="line">		Parent-&gt;_right = Right;</span><br><span class="line">		Left-&gt;_parent = Parent;</span><br><span class="line">		Right-&gt;_parent = Parent;</span><br><span class="line"></span><br><span class="line">		treeNodePQ.push(Parent);</span><br><span class="line">	&#125;</span><br><span class="line">	root = treeNodePQ.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编码过程（Huffman树的遍历）"><a href="#编码过程（Huffman树的遍历）" class="headerlink" title="编码过程（Huffman树的遍历）"></a>编码过程（Huffman树的遍历）</h4><p>&emsp;&emsp;编码的生成我是利用递归遍历的方法实现的，当然你也可以用BFS。Huffman的规则是通往左子树的路径为0，右子树的路径为1。下面是代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;前序遍历huffman树，并生成编码,将节点信息存入到对象中</span><br><span class="line">void FileHandler::buildCode(HuffmanTreeNode&lt;CharInfo&gt;* root, string code) &#123;</span><br><span class="line">	if (root &#x3D;&#x3D; NULL)return;</span><br><span class="line">	&#x2F;&#x2F;叶子节点</span><br><span class="line">	if (root-&gt;_left &#x3D;&#x3D; NULL &amp;&amp; root-&gt;_right &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		root-&gt;_weight._strCode &#x3D; code;</span><br><span class="line">		&#x2F;&#x2F;将每个字符和对应的编码存入codemap</span><br><span class="line">		codemap.insert(make_pair(root-&gt;_weight._character, root-&gt;_weight._strCode));</span><br><span class="line">	&#125;</span><br><span class="line">	buildCode(root-&gt;_left, code + &#39;0&#39;);</span><br><span class="line">	buildCode(root-&gt;_right, code + &#39;1&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解码过程："><a href="#解码过程：" class="headerlink" title="解码过程："></a>解码过程：</h4><p>&emsp;&emsp;从树根开始，根据Huffman编码0向左，1向右终点便是字符所在节点。但是这种解码方式有个前提就是需要根据文件头信息（编码的时候自己写入），重建Huffman树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解析数据</span><br><span class="line">void FileHandler::uncompressData(ifstream&amp; fin, ofstream&amp; fout) &#123;</span><br><span class="line">	unsigned char in_char;</span><br><span class="line">	long long writen_len &#x3D; 0;&#x2F;&#x2F;记录读取的文件长度</span><br><span class="line">	HuffmanTree&lt;CharInfo&gt; tree(info);</span><br><span class="line">	HuffmanTreeNode&lt;CharInfo&gt;* temp &#x3D; tree.GetRoot();</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		fin.read((char*)&amp;in_char, 1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 8; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (in_char &amp; 128)&#x2F;&#x2F;128 &#x3D;binary&#x3D;&gt;1000 0000 ,与运算获取in_char最高位的取值</span><br><span class="line">				temp &#x3D; temp-&gt;_right;</span><br><span class="line">			else</span><br><span class="line">				temp &#x3D; temp-&gt;_left;</span><br><span class="line"></span><br><span class="line">			if (temp-&gt;_left &#x3D;&#x3D; 0 &amp;&amp; temp-&gt;_right &#x3D;&#x3D; 0)</span><br><span class="line">			&#123;</span><br><span class="line">				fout.write((char*)&amp;temp-&gt;_weight._character, 1);</span><br><span class="line">				++writen_len;</span><br><span class="line">				if (writen_len &#x3D;&#x3D; totalNum) break;</span><br><span class="line">				temp &#x3D; tree.GetRoot();</span><br><span class="line">			&#125;</span><br><span class="line">			in_char &lt;&lt;&#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">		if (writen_len &#x3D;&#x3D; totalNum) break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件后缀和编码信息"><a href="#文件后缀和编码信息" class="headerlink" title="文件后缀和编码信息"></a>文件后缀和编码信息</h3><p>&emsp;&emsp;为了将压缩后的数据解码，我们需要将一些文件的信息，比如文件的大小、文件的后缀名以及编码信息写入压缩文件。我的文件头信息结构如下表：</p>
<table>
<thead>
<tr>
<th>总字节数</th>
<th>文件后缀字节数</th>
<th>后缀名</th>
<th>编码个数</th>
<th>字符</th>
<th>出现频次</th>
</tr>
</thead>
<tbody><tr>
<td>long long</td>
<td>short</td>
<td>后缀长度</td>
<td>short</td>
<td>unsigned char</td>
<td>long long</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;总字节数用于后面判断文件结束，但可能因为文件过大，字节数超过long long所能存储的最大数。目前我觉得可以用unsigned long long来存储，或者利用单位换算，降低其数量级（但可能会涉及到精度问题）。由于后缀名具有不确定性，读取时并不确定所占的字节数，所以用2个字节存入后缀名所占字节数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;写入文件后缀和编码信息</span><br><span class="line">void FileHandler::writeFileHeaderInfo(ofstream&amp; fout, string&amp; path) &#123;</span><br><span class="line">	&#x2F;&#x2F;总字节数</span><br><span class="line">	fout.write((char*)&amp;totalNum, 8);</span><br><span class="line">	&#x2F;&#x2F;写入文件后缀</span><br><span class="line">	string suffix &#x3D; getSuffix(path);</span><br><span class="line">	&#x2F;&#x2F;文件后缀的字节数</span><br><span class="line">	short suffixLen &#x3D; suffix.length();</span><br><span class="line">	fout.write((char*)&amp;suffixLen, sizeof(short));</span><br><span class="line">	&#x2F;&#x2F;文件后缀</span><br><span class="line">	fout.write(suffix.c_str(), suffixLen);</span><br><span class="line">	_encodeNum +&#x3D; suffixLen;</span><br><span class="line">	&#x2F;&#x2F;写入编码个数</span><br><span class="line">	short count &#x3D; codemap.size();</span><br><span class="line">	fout.write((char*)&amp;count, sizeof(short));</span><br><span class="line">	_encodeNum +&#x3D; 12;</span><br><span class="line">	&#x2F;&#x2F;写入字符和对应频次</span><br><span class="line">	map&lt;char, string&gt;::iterator it;</span><br><span class="line">	long long _count &#x3D; 0;</span><br><span class="line">	unsigned char code;</span><br><span class="line">	for (it &#x3D; codemap.begin();it !&#x3D; codemap.end();it++) &#123;</span><br><span class="line">		&#x2F;&#x2F;写入字符</span><br><span class="line">		code &#x3D; it-&gt;first;</span><br><span class="line">		fout.put(code);</span><br><span class="line">		&#x2F;&#x2F;出现频次，long long 8byte -256个编码的话总共占2kbyte</span><br><span class="line">		_count &#x3D; info[code]._chCount;</span><br><span class="line">		fout.write((char*)&amp;_count, 8);</span><br><span class="line">		_encodeNum +&#x3D; 9;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件数据压缩"><a href="#文件数据压缩" class="headerlink" title="文件数据压缩"></a>文件数据压缩</h3><p>&emsp;&emsp;文件压缩的细节点很多，比如关于c++的ifstream这个东西当时就搞的我很头疼。原来我是用fin.get(in_char);来读取的，但后来绝的每次读取一个字节效率实在太低。因此换用缓冲流来接收。还有关于不够八位的补零处理。虽然我补了零但我觉得直接写入应该也没什么问题，因为我是根据处理的字节总数来判断是否读取结束的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;写入压缩数据</span><br><span class="line">void FileHandler::buildFile(ofstream&amp; fout, string&amp; path) &#123;</span><br><span class="line">	printf(&quot;开始写入文件信息\n&quot;);</span><br><span class="line">	&#x2F;&#x2F;写入文件huffman信息</span><br><span class="line">	writeFileHeaderInfo(fout, path);</span><br><span class="line">	printf(&quot;开始收集并写入编码\n&quot;);</span><br><span class="line"></span><br><span class="line">	ifstream fin(path, ios::binary);</span><br><span class="line">	if (!fin.is_open()) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;Error！File is not exist&quot; &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;length编码的总长</span><br><span class="line">	int length&#x3D;0;</span><br><span class="line">	int i, j, gcount &#x3D; 0;&#x2F;&#x2F;每次读取的字节数</span><br><span class="line">	unsigned char buff[256];&#x2F;&#x2F;字节流缓冲区</span><br><span class="line">	unsigned char out_c, tmp_c;</span><br><span class="line">	string code, out_string;&#x2F;&#x2F;转换后的编码;编码后的数据</span><br><span class="line">	map&lt;char, string&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;将数据转换为二进制字符串</span><br><span class="line">		while (length &lt; 1024 &amp;&amp; (!fin.eof())) &#123;</span><br><span class="line">			fin.read((char*)buff, 256);</span><br><span class="line">			gcount &#x3D; fin.gcount();</span><br><span class="line"></span><br><span class="line">			if (gcount &gt; 0) &#123;</span><br><span class="line">				for (i &#x3D; 0;i &lt; gcount;i++) &#123;</span><br><span class="line">					it &#x3D; codemap.find(buff[i]);</span><br><span class="line">					if (it !&#x3D; codemap.end()) &#123;</span><br><span class="line">						code +&#x3D; it-&gt;second;</span><br><span class="line">						length &#x3D; code.length();</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						printf(&quot;Can&#39;t find the huffman code of character %X\n&quot;, buff[i]);</span><br><span class="line">						printf(&quot;error!存在字符无对应编码！\n&quot;);</span><br><span class="line">						exit(1);&#x2F;&#x2F;推出程序</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (length &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			out_string.clear();</span><br><span class="line">			if (length &gt; 8) &#123;</span><br><span class="line">				&#x2F;&#x2F;将huffman的01编码以二进制流写入到输出文件</span><br><span class="line">				for (i &#x3D; 0; i + 7 &lt; length; i +&#x3D; 8)</span><br><span class="line">				&#123;</span><br><span class="line">					out_c &#x3D; 0;</span><br><span class="line">					for (j &#x3D; 0; j &lt; 8; j++)</span><br><span class="line">					&#123;</span><br><span class="line">						if (&#39;0&#39; &#x3D;&#x3D; code[i + j])</span><br><span class="line">							tmp_c &#x3D; 0;</span><br><span class="line">						else</span><br><span class="line">							tmp_c &#x3D; 1;</span><br><span class="line">						out_c +&#x3D; tmp_c &lt;&lt; (7 - j);</span><br><span class="line">					&#125;</span><br><span class="line">					out_string +&#x3D; out_c;</span><br><span class="line">				&#125;</span><br><span class="line">				fout.write(out_string.c_str(), out_string.length());</span><br><span class="line">				_encodeNum +&#x3D; out_string.length();</span><br><span class="line">				code &#x3D; code.substr(i, length - i);&#x2F;&#x2F;i位开始，长度为length-i</span><br><span class="line">				length &#x3D; code.length();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (fin.eof() &amp;&amp; length &lt; 8) &#123;</span><br><span class="line">				&#x2F;&#x2F;小于等于8</span><br><span class="line">				char n &#x3D; 8 - length;&#x2F;&#x2F;补0个数</span><br><span class="line">				char* zero &#x3D; new char[n + 1];</span><br><span class="line">				zero[n] &#x3D; &#39;\0&#39;;</span><br><span class="line">				fill(zero, zero + n, &#39;0&#39;);</span><br><span class="line">				string s(zero);</span><br><span class="line">				code.append(zero);</span><br><span class="line">				out_c &#x3D; 0;</span><br><span class="line">				for (j &#x3D; 0; j &lt; 8; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					if (&#39;0&#39; &#x3D;&#x3D; code[j])</span><br><span class="line">						tmp_c &#x3D; 0;</span><br><span class="line">					else</span><br><span class="line">						tmp_c &#x3D; 1;</span><br><span class="line">					out_c +&#x3D; tmp_c &lt;&lt; (7 - j);</span><br><span class="line">				&#125;</span><br><span class="line">				fout.put(out_c);</span><br><span class="line">				_encodeNum +&#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while (!fin.eof());</span><br><span class="line">	printf(&quot;文件共%lld个字节\n&quot;, totalNum);</span><br><span class="line">	printf(&quot;压缩后为%lld个字节\n&quot;, _encodeNum);</span><br><span class="line">	float rate &#x3D; _encodeNum*1.0&#x2F;totalNum*100;</span><br><span class="line">	printf(&quot;压缩率为%.2f\%%&quot;, rate);</span><br><span class="line">	fin.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="压缩率"><a href="#压缩率" class="headerlink" title="压缩率"></a>压缩率</h3><p>&emsp;&emsp;关于压缩率，我测试了<code>txt</code>文件，<code>jpg</code>文件，和<code>MP3</code>文件除了<code>txt</code>偶尔达到50%，其他均高达90%+，毕竟图片文件和<code>mp3</code>文件都是压缩后的产物，压缩率不高也很正常。</p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>关于二进制的介绍和c++文件操作相关，详见</p>
<p><a href="https://wicherqaq.github.io/2020/02/16/%E6%8F%AD%E5%BC%80%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/">揭开二进制与位移运算的神秘面纱</a></p>
<p><a href="https://wicherqaq.github.io/2020/02/09/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cfstream/">文件操作fstream</a></p>
<p><a href="https://github.com/wicherQAQ/HUFFMAN" target="_blank" rel="noopener">Github源码链接</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>huffman压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql不同版本的区别</title>
    <url>/2020/02/21/mysql%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="官网下载地址"><a href="#官网下载地址" class="headerlink" title="官网下载地址"></a><a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">官网下载地址</a></h2><h2 id="一、Mysql-各个版本区别："><a href="#一、Mysql-各个版本区别：" class="headerlink" title="一、Mysql 各个版本区别："></a>一、Mysql 各个版本区别：</h2><ol>
<li>MySQL Community Server 社区版本，开源免费，但不提供官方技术支持。</li>
<li>MySQL Enterprise Edition 企业版本，需付费，可以试用30天。</li>
<li>MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server, 2台以上 mysql集群服务器。</li>
<li>MySQL Cluster CGE 高级集群版，需付费。</li>
<li>MySQL Workbench（GUI TOOL）一款专为MySQL设计的ER/数据库建模工具。它是著名的数据库设计工具DBDesigner4的继任者。MySQL Workbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL Workbench SE）。</li>
</ol>
<blockquote>
<p>ps:MySQL Community Server 是开源免费的，这也是我们通常用的MySQL的版本。根据不同的操作系统平台细分为多个版本。</p>
</blockquote>
<h2 id="二、以下载-tar-gz-版本为例的下载过程"><a href="#二、以下载-tar-gz-版本为例的下载过程" class="headerlink" title="二、以下载 tar.gz 版本为例的下载过程"></a>二、以下载 tar.gz 版本为例的下载过程</h2><p>我们选择GenerallyAvailable(GA) Release 去下载。GA指软件的通用版本，一般指正式发布的版本。</p>
<p>选择 Downloads–&gt;Community–&gt;Mysql Community Downloads</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 事务的实现原理</title>
    <url>/2020/04/20/mysql-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>&emsp;&emsp;相信大家都用过事务以及了解他的特点，如原子性(Atomicity),一致性(Consistency),隔离型(Isolation)以及持久性(Durability)等。今天想跟大家一起研究下事务内部到底是怎么实现的，在讲解前我想先抛出个问题：<br><strong>事务想要做到什么效果？</strong></p>
<p>&emsp;&emsp;按我理解，无非是要做到<strong>可靠性</strong>以及<strong>并发处理</strong></p>
<ul>
<li><p>可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致，想要做到这个，我需要知道我修改之前和修改之后的状态，所以就有了undo log和redo log。</p>
</li>
<li><p>并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的<strong>读写进行隔离</strong>，至于隔离到啥程度得看业务系统的场景了，实现这个就得用MySQL 的隔离级别。</p>
</li>
</ul>
<p>&emsp;&emsp;下面我首先讲实现事务功能的三个技术，分别是日志文件(redo和undo)，锁技术以及MVCC，然后再讲事务的实现原理，包括原子性是怎么实现的，隔离型是怎么实现的等等。最后在做一个总结，希望大家能够耐心看完</p>
<h3 id="redo与-undo介绍"><a href="#redo与-undo介绍" class="headerlink" title="redo与 undo介绍"></a>redo与 undo介绍</h3><h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p><strong>什么是redo log ?</strong></p>
<p>redo log叫做<strong>重做</strong>日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当<strong>事务提交之后</strong>会把所有修改信息都会存到该日志中。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ff3e4c3b8b46?w=2368&h=788&f=png&s=226339" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fdae04c7dc6f?w=4016&h=1892&f=png&s=1010471" alt="img"></p>
<p><strong>redo log 有什么作用？</strong></p>
<p>mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做<strong>缓冲池和磁盘之间的同步</strong>。</p>
<p>那么问题来了，如果还没来的同步的时候宕机或断电了怎么办？还没来得及执行上面图中红色的操作。这样会导致丢部分已提交事务的修改信息！</p>
<p>所以引入了redo log来记录<strong>已成功提交事务</strong>的修改信息，并且会把redo log持久化到磁盘，系统重启之后再顺序读取redo log恢复最新数据。</p>
<p><strong>总结：</strong><br>redo log是用来恢复数据的 用于保障，<strong>已提交事务的持久化特性</strong></p>
<h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2.undo log"></a>2.undo log</h4><p><strong>什么是 undo log ？</strong></p>
<p>undo log 叫做回滚日志，用于记录数据<strong>被修改前</strong>的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>
<p>还用上面那两张表</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe552145e2c1?w=4652&h=1848&f=png&s=867671" alt="img"></p>
<p>每次写入数据或者修改数据之前都会把<strong>修改前的信息</strong>记录到 undo log。</p>
<p><strong>undo log 有什么作用？</strong></p>
<p>undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p>
<p>总结：<br>undo log是用来回滚数据的用于保障<strong>未提交事务的原子性</strong></p>
<h3 id="mysql锁技术以及MVCC基础"><a href="#mysql锁技术以及MVCC基础" class="headerlink" title="mysql锁技术以及MVCC基础"></a>mysql锁技术以及MVCC基础</h3><h4 id="1-mysql锁技术"><a href="#1-mysql锁技术" class="headerlink" title="1. mysql锁技术"></a>1. mysql锁技术</h4><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。<br><strong>读写锁</strong><br>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：</p>
<p>共享锁(shared lock),又叫做”读锁”<br>读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</p>
<p>排他锁(exclusive lock),又叫做”写锁”<br>写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a27696def80b5f?w=416&h=183&f=png&s=16219" alt="img"></p>
<p>总结：<br>通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行<br>事务的隔离性就是根据读写锁来实现的！！！这个后面再说。</p>
<h4 id="2-MVCC基础"><a href="#2-MVCC基础" class="headerlink" title="2. MVCC基础"></a>2. MVCC基础</h4><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。</p>
<blockquote>
<p>InnoDB的 MVCC ，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，<br>一个保存了行的创建时间，一个保存了行的过期时间，<br>当然存储的并不是实际的时间值，而是系统版本号。</p>
</blockquote>
<p>以上片段摘自《高性能Mysql》这本书对MVCC的定义。他的主要实现思想是通过<strong>数据多版本</strong>来做到<strong>读写分离</strong>。从而实现不加锁读进而做到读写并行。</p>
<p><strong>MVCC在mysql中的实现依赖的是undo log与read view</strong></p>
<ul>
<li>undo log :undo log 中记录某行数据的多个版本的数据。</li>
<li>read view :用来判断当前版本数据的可见性</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f5e3c3950ca1?w=3612&h=1512&f=png&s=816439" alt="img"></p>
<h3 id="四、事务的实现"><a href="#四、事务的实现" class="headerlink" title="四、事务的实现"></a>四、事务的实现</h3><p>前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。</p>
<ul>
<li>事务的原子性是通过 undo log 来实现的</li>
<li>事务的持久性性是通过 redo log 来实现的</li>
<li>事务的隔离性是通过 (读写锁+MVCC)来实现的</li>
<li>而事务的终极大 boss <strong>一致性</strong>是通过原子性，持久性，隔离性来实现的！！！</li>
</ul>
<p><strong>原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！</strong></p>
<p>总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。</p>
<h4 id="1-原子性的实现"><a href="#1-原子性的实现" class="headerlink" title="1.原子性的实现"></a>1.原子性的实现</h4><p>什么是原子性：</p>
<p>一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作，这就是事务的原子性。</p>
<p>上面这段话取自《高性能MySQL》这本书对原子性的定义，原子性可以概括为就是要实现要么全部失败，要么全部成功。</p>
<p>以上概念相信大家伙儿都了解，那么数据库是怎么实现的呢？ 就是通过<strong>回滚</strong>操作。<br>所谓回滚操作就是当发生错误异常或者显式的执行rollback语句时需要把数据还原到原先的模样，所以这时候就需要用到undo log来进行回滚，接下来看一下undo log在实现事务原子性时怎么发挥作用的</p>
<h5 id="1-1-undo-log-的生成"><a href="#1-1-undo-log-的生成" class="headerlink" title="1.1 undo log 的生成"></a>1.1 undo log 的生成</h5><p>假设有两个表 bank和finance，表中原始数据如图所示，当进行插入，删除以及更新操作时生成的undo log如下面图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe331bab111c?w=4652&h=1848&f=png&s=867671" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fe2457ff3820?w=1904&h=744&f=png&s=319469" alt="img"></p>
<p>从上图可以了解到数据的变更都伴随着回滚日志的产生：<br>(1) 产生了被修改前数据(zhangsan,1000) 的回滚日志</p>
<p>(2) 产生了被修改前数据(zhangsan,0) 的回滚日志</p>
<p>根据上面流程可以得出如下结论：<br><strong>1.每条数据变更(insert/update/delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上</strong><br><strong>2.所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</strong></p>
<p>思考：为什么先写日志后写数据库？ —稍后做解释</p>
<h5 id="1-2-根据undo-log-进行回滚"><a href="#1-2-根据undo-log-进行回滚" class="headerlink" title="1.2 根据undo log 进行回滚"></a>1.2 根据undo log 进行回滚</h5><p>为了做到同时成功或者失败，当系统发生错误或者执行rollback操作时需要根据undo log 进行回滚</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2fece4894a8a8?w=3748&h=1100&f=png&s=475112" alt="img"></p>
<p>回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如：</p>
<p>(1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句</p>
<p>(2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句</p>
<p>(3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</p>
<h4 id="2-持久性的实现"><a href="#2-持久性的实现" class="headerlink" title="2.持久性的实现"></a>2.持久性的实现</h4><p>事务一旦提交，其所作做的修改会永久保存到数据库中，此时即使系统崩溃修改的数据也不会丢失。</p>
<p>先了解一下MySQL的数据存储机制，MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。<br>为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：<br><strong>读数据</strong>：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；<br><strong>写数据</strong>：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中；</p>
<p>上面这种缓冲池的措施虽然在性能方面带来了质的飞跃，但是它也带来了新的问题，当MySQL系统宕机，断电的时候可能会丢数据！！！</p>
<p>因为我们的数据已经提交了，但此时是在缓冲池里头，还没来得及在磁盘持久化，所以我们急需一种机制需要存一下已提交事务的数据，为恢复数据使用。</p>
<p>于是 redo log就派上用场了。下面看下redo log是什么时候产生的</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a26f9acf011739?w=994&h=373&f=png&s=120202" alt="img"></p>
<p>既然redo log也需要存储，也涉及磁盘IO为啥还用它？</p>
<p>（1）redo log 的存储是顺序存储，而缓存同步是随机操作。</p>
<p>（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。</p>
<hr>
<h4 id="3-隔离性实现"><a href="#3-隔离性实现" class="headerlink" title="3.隔离性实现"></a>3.隔离性实现</h4><p>隔离性是事务ACID特性里最复杂的一个。在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。</p>
<p>级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p>
<p>Mysql 隔离级别有以下四种（级别由低到高）：</p>
<ul>
<li><strong>READ UNCOMMITED</strong> (未提交读)</li>
<li><strong>READ COMMITED</strong> (提交读)</li>
<li><strong>REPEATABLE READ</strong> (可重复读)</li>
<li><strong>SERIALIZABLE</strong> (可序列化)</li>
</ul>
<p>只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。前面说过原子性，隔离性，持久性的目的都是为了要做到一致性，但隔离型跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</p>
<p>那么隔离性是要做到什么呢？ <strong>隔离性是要管理多个并发读写请求的访问顺序。</strong> 这种顺序包括<strong>串行</strong>或者是<strong>并行</strong><br>说明一点，写请求不仅仅是指insert操作，又包括update操作。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c1c8b5285ee3?w=688&h=233&f=png&s=40492" alt="img"></p>
<p>总之，从隔离性的实现可以看出这是一场数据的可靠性与性能之间的权衡。</p>
<ul>
<li>可靠性性高的，并发性能低(比如 Serializable)</li>
<li>可靠性低的，并发性能高(比如 Read Uncommited)</li>
</ul>
<p><strong>READ UNCOMMITTED</strong></p>
<p>在READ UNCOMMITTED隔离级别下，事务中的修改即使还没提交，对其他事务是可见的。事务可以读取未提交的数据，造成脏读。</p>
<p>因为读不会加任何锁，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到<strong>读写并行</strong>。</p>
<p>换句话说，读的操作不能排斥写请求。<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2ed4dbd348a68?w=4284&h=1288&f=png&s=731191" alt="img"></p>
<p>优点：读写并行，性能高<br>缺点：造成脏读</p>
<p><strong>READ COMMITTED</strong></p>
<p>一个事务的修改在他提交之前的所有修改，对其他事务都是不可见的。其他事务能读到已提交的修改变化。在很多场景下这种逻辑是可以接受的。</p>
<p>InnoDB在 READ COMMITTED，使用排它锁,读取数据不加锁而是使用了MVCC机制。或者换句话说他采用了<strong>读写分离机制</strong>。<br>但是该级别会产生<strong>不可重读</strong>以及<strong>幻读</strong>问题。</p>
<blockquote>
<p>什么是不可重读？</p>
</blockquote>
<p>在一个事务内多次读取的结果不一样。</p>
<blockquote>
<p>为什么会产生不可重复读？</p>
</blockquote>
<p>这跟 READ COMMITTED 级别下的MVCC机制有关系，在该隔离级别下每次 select的时候新<strong>生成一个版本号</strong>，所以每次select的时候读的不是一个副本而是不同的副本。</p>
<p>在每次select之间有其他事务<strong>更新</strong>了我们读取的数据并提交了，那就出现了不可重复读<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f05d63f388d0?w=3612&h=1512&f=png&s=816439" alt="img"></p>
<p><strong>REPEATABLE READ</strong>(Mysql默认隔离级别)</p>
<p>在一个事务内的多次读取的结果是一样的。这种级别下可以避免，脏读，不可重复读等查询问题。mysql 有两种机制可以达到这种隔离级别的效果，分别是采用读写锁以及MVCC。</p>
<p><strong>采用读写锁实现</strong>：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2c351eb03fc24?w=1082&h=290&f=png&s=120400" alt="img"><br>为什么能可重复度？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。</p>
<p>优点：实现起来简单</p>
<p>缺点：无法做到读写并行</p>
<p><strong>采用MVCC实现</strong>：<br><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f054474b394b?w=3584&h=1512&f=png&s=756027" alt="img"></p>
<p>为什么能可重复度？因为多次读取只生成一个版本，读到的自然是相同数据。</p>
<p>优点：读写并行</p>
<p>缺点：实现的复杂度高</p>
<p>但是在该隔离级别下仍会存在幻读的问题，关于幻读的解决我打算另开一篇来介绍。</p>
<p><strong>SERIALIZABLE</strong></p>
<p>该隔离级别理解起来最简单，实现也最单。在隔离级别下除了不会造成数据不一致问题，没其他优点。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f56d34ff739e?w=3528&h=1060&f=png&s=414467" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/18/16a2f69776d551b3?w=2608&h=776&f=png&s=445068" alt="img"></p>
<p>–摘自《高性能Mysql》</p>
<h4 id="4-一致性的实现"><a href="#4-一致性的实现" class="headerlink" title="4.一致性的实现"></a>4.一致性的实现</h4><blockquote>
<p>数据库总是从一个一致性的状态转移到另一个一致性的状态.</p>
</blockquote>
<p>下面举个例子:zhangsan 从银行卡转400到理财账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">select balance from bank where name&#x3D;&quot;zhangsan&quot;;</span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 balance&#x3D;600</span><br><span class="line">update bank set balance &#x3D; balance - 400; </span><br><span class="line">&#x2F;&#x2F; 生成 重做日志 amount&#x3D;400</span><br><span class="line">update finance set amount &#x3D; amount + 400;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>1.假如执行完 <code>update bank set balance = balance - 400;</code>之发生异常了，银行卡的钱也不能平白无辜的减少，而是回滚到最初状态。</p>
<p>2.又或者事务提交之后，缓冲池还没同步到磁盘的时候宕机了，这也是不能接受的，应该在重启的时候恢复并持久化。</p>
<p>3.假如有并发事务请求的时候也应该做好事务之间的可见性问题，避免造成脏读，不可重复读，幻读等。在涉及并发的情况下往往在性能和一致性之间做平衡，做一定的取舍，所以隔离性也是对一致性的一种破坏。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文出发点是想讲一下Mysql的事务的实现原理。</p>
<p>实现事务采取了哪些技术以及思想？</p>
<ul>
<li>原子性：使用 undo log ，从而达到回滚</li>
<li>持久性：使用 redo log，从而达到故障后恢复</li>
<li>隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行</li>
<li>一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。</li>
</ul>
<p>转载自 <a href="https://www.cnblogs.com/wyc1994666/p/11367051.html" target="_blank" rel="noopener">来自大佬的链接</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>#include &lt;iostream&gt;</title>
    <url>/2020/03/30/include-iostream/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>pip包管理器</title>
    <url>/2020/04/21/pip%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>命令</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td><code>pip list</code></td>
<td>列出pip管理的所有包</td>
</tr>
<tr>
<td><code>pip install 包名</code></td>
<td>安装包</td>
</tr>
<tr>
<td><code>pip uninstall 包名</code></td>
<td>卸载包</td>
</tr>
<tr>
<td><code>pip -V</code></td>
<td>查看版本</td>
</tr>
<tr>
<td><code>pip freeze &gt; requirement.txt</code></td>
<td>将pip管理的包和版本号输出到文档</td>
</tr>
<tr>
<td><code>pip install -r requirement.txt</code></td>
<td>暗转requirement.txt中的所有依赖</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>redis缓存穿透、缓存击穿、缓存雪崩</title>
    <url>/2020/06/01/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>随着互联网系统发展的逐步完善，提高系统的QPS（每秒查询率），目前的绝大部分系统都增加了<a href="http://mp.weixin.qq.com/s?__biz=MzU5NTAzNjM0Mw==&mid=2247484731&idx=2&sn=932f690ee1b775e864d3e113739a421a&chksm=fe7954e3c90eddf5d2f7de72909a43b5151797df7212b10311c497c3d1708d9a0613279f5734&scene=21#wechat_redirect" target="_blank" rel="noopener">缓存机制</a>从而避免请求过多的直接与数据库操作从而造成系统瓶颈，极大的提升了用户体验和系统稳定性。但同时，一个缓存机制的设计如果不是很好，就可能带来一些问题：<strong>缓存穿透、缓存击穿与缓存雪崩效应</strong>。这些问题的出现本质上都是在一定的条件下导致的数据库DB的访问量过高导致的系统QPS较低的问题。</p>
<p>前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。常见的缓存机制如下图：</p>
<img src="/2020/06/01/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/缓存机制.png" style="zoom:60%;">

<h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<p>如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li><strong>接口层增加校验</strong>，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为<strong>key-null</strong>，<strong>缓存有效时间可以设置短点</strong>，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
</ol>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p><strong>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期）</strong>，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>设置热点数据永远不过期。</li>
<li>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。</li>
<li>布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，</li>
</ol>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，    缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
</ol>
]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
  </entry>
  <entry>
    <title>python入门（上）</title>
    <url>/2020/09/10/python%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Python入门-上"><a href="#Python入门-上" class="headerlink" title="Python入门(上)"></a>Python入门(上)</h1><p>[TOC]</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p>
<p>本实验包括以下内容：</p>
<ul>
<li>变量、运算符与数据类型<ul>
<li>注释</li>
<li>运算符</li>
<li>变量和赋值</li>
<li>数据类型与转换</li>
<li>print() 函数</li>
</ul>
</li>
<li>位运算<ul>
<li>原码、反码和补码</li>
<li>按位非操作 ~</li>
<li>按位与操作 &amp;</li>
<li>按位或操作 |</li>
<li>按位异或操作 ^</li>
<li>按位左移操作 &lt;&lt;</li>
<li>按位右移操作 &gt;&gt;</li>
<li>利用位运算实现快速计算</li>
<li>利用位运算实现整数集合</li>
</ul>
</li>
<li>条件语句<ul>
<li>if 语句</li>
<li>if - else 语句</li>
<li>if - elif - else 语句</li>
<li>assert 关键词</li>
</ul>
</li>
<li>循环语句<ul>
<li>while 循环</li>
<li>while - else 循环</li>
<li>for 循环</li>
<li>for - else 循环</li>
<li>range() 函数</li>
<li>enumerate()函数</li>
<li>break 语句</li>
<li>continue 语句</li>
<li>pass 语句</li>
<li>推导式</li>
</ul>
</li>
<li>异常处理<ul>
<li>Python 标准异常总结</li>
<li>Python 标准警告总结</li>
<li>try - except 语句</li>
<li>try - except - finally 语句</li>
<li>try - except - else 语句</li>
<li>raise语句</li>
</ul>
</li>
</ul>
<h1 id="变量、运算符与数据类型"><a href="#变量、运算符与数据类型" class="headerlink" title="变量、运算符与数据类型"></a>变量、运算符与数据类型</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><ul>
<li>在 Python 中，<code>#</code> 表示注释，作用于整行。</li>
</ul>
<p>【例子】单行注释</p>
<p>[1]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是一个注释</span><br><span class="line">print(&quot;Hello world&quot;)</span><br><span class="line"></span><br><span class="line"># Hello world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> 表示区间注释，在三引号之间的所有内容被注释</li>
</ul>
<p>【例子】多行注释</p>
<p>[2]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;</span><br><span class="line">这是多行注释，用三个单引号</span><br><span class="line">这是多行注释，用三个单引号</span><br><span class="line">这是多行注释，用三个单引号</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">print(&quot;Hello china&quot;) </span><br><span class="line"># Hello china</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">这是多行注释，用三个双引号</span><br><span class="line">这是多行注释，用三个双引号 </span><br><span class="line">这是多行注释，用三个双引号</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(&quot;hello china&quot;) </span><br><span class="line"># hello china</span><br><span class="line">Hello china</span><br><span class="line">hello china</span><br></pre></td></tr></table></figure>

<h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><p><strong>算术运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加</td>
<td><code>1 + 1</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减</td>
<td><code>2 - 1</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘</td>
<td><code>3 * 4</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
<td><code>3 / 4</code></td>
</tr>
<tr>
<td><code>//</code></td>
<td>整除（地板除）</td>
<td><code>3 // 4</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>取余</td>
<td><code>3 % 4</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂</td>
<td><code>2 ** 3</code></td>
</tr>
</tbody></table>
<p>【例子】</p>
<p>[4]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(1 + 1)  # 2</span><br><span class="line">print(2 - 1)  # 1</span><br><span class="line">print(3 * 4)  # 12</span><br><span class="line">print(3 &#x2F; 4)  # 0.75</span><br><span class="line">print(3 &#x2F;&#x2F; 4)  # 0</span><br><span class="line">print(3 % 4)  # 3</span><br><span class="line">print(2 ** 4)  # 8</span><br><span class="line">print(5&#x2F;&#x2F;10)</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">12</span><br><span class="line">0.75</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">16</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>2 &gt; 1</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>2 &gt;= 4</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>1 &lt; 2</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>5 &lt;= 2</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>3 == 4</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>3 != 5</code></td>
</tr>
</tbody></table>
<p>【例子】</p>
<p>[4]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(2 &gt; 1)  # True</span><br><span class="line">print(2 &gt;&#x3D; 4)  # False</span><br><span class="line">print(1 &lt; 2)  # True</span><br><span class="line">print(5 &lt;&#x3D; 2)  # False</span><br><span class="line">print(3 &#x3D;&#x3D; 4)  # False</span><br><span class="line">print(3 !&#x3D; 5)  # True</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>and</code></td>
<td>与</td>
<td><code>(3 &gt; 2) and (3 &lt; 5)</code></td>
</tr>
<tr>
<td><code>or</code></td>
<td>或</td>
<td><code>(1 &gt; 3) or (9 &lt; 2)</code></td>
</tr>
<tr>
<td><code>not</code></td>
<td>非</td>
<td><code>not (2 &gt; 1)</code></td>
</tr>
</tbody></table>
<p>【例子】</p>
<p>[5]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print((3 &gt; 2) and (3 &lt; 5))  # True</span><br><span class="line">print((1 &gt; 3) or (9 &lt; 2))  # False</span><br><span class="line">print(not (2 &gt; 1))  # False</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p><strong>位运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>~</code></td>
<td>按位取反</td>
<td><code>~4</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>4 &amp; 5</code></td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>按位或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>4 ^ 5</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>4 &lt;&lt; 2</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>4 &gt;&gt; 2</code></td>
</tr>
</tbody></table>
<p>【例子】有关二进制的运算，参见“位运算”部分的讲解。</p>
<p>[6]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(bin(4))  # 0b100</span><br><span class="line">print(bin(5))  # 0b101</span><br><span class="line">print(bin(~4), ~4)  # -0b101 -5</span><br><span class="line">print(bin(4 &amp; 5), 4 &amp; 5)  # 0b100 4</span><br><span class="line">print(bin(4 | 5), 4 | 5)  # 0b101 5</span><br><span class="line">print(bin(4 ^ 5), 4 ^ 5)  # 0b1 1</span><br><span class="line">print(bin(4 &lt;&lt; 2), 4 &lt;&lt; 2)  # 0b10000 16</span><br><span class="line">print(bin(4 &gt;&gt; 2), 4 &gt;&gt; 2)  # 0b1 1</span><br><span class="line">0b100</span><br><span class="line">0b101</span><br><span class="line">-0b101 -5</span><br><span class="line">0b100 4</span><br><span class="line">0b101 5</span><br><span class="line">0b1 1</span><br><span class="line">0b10000 16</span><br><span class="line">0b1 1</span><br></pre></td></tr></table></figure>

<p><strong>三元运算符</strong></p>
<p>【例子】</p>
<p>[7]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, y &#x3D; 4, 5</span><br><span class="line">if x &lt; y:</span><br><span class="line">    small &#x3D; x</span><br><span class="line">else:</span><br><span class="line">    small &#x3D; y</span><br><span class="line"></span><br><span class="line">print(small)  # 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>有了这个三元操作符的条件表达式，你可以使用一条语句来完成以上的条件判断和赋值操作。</p>
<p>【例子】</p>
<p>[8]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, y &#x3D; 4, 5</span><br><span class="line">small &#x3D; x if x &lt; y else y</span><br><span class="line">print(small)  # 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>其他运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>in</code></td>
<td>存在</td>
<td><code>&#39;A&#39; in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td>
</tr>
<tr>
<td><code>not in</code></td>
<td>不存在</td>
<td><code>&#39;h&#39; not in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td>
</tr>
<tr>
<td><code>is</code></td>
<td>是</td>
<td><code>&quot;hello&quot; is &quot;hello&quot;</code></td>
</tr>
<tr>
<td><code>not is</code></td>
<td>不是</td>
<td><code>&quot;hello&quot; is not &quot;hello&quot;</code></td>
</tr>
</tbody></table>
<p>【例子】</p>
<p>[9]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">letters &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br><span class="line">if &#39;A&#39; in letters:</span><br><span class="line">    print(&#39;A&#39; + &#39; exists&#39;)</span><br><span class="line">if &#39;h&#39; not in letters:</span><br><span class="line">    print(&#39;h&#39; + &#39; not exists&#39;)</span><br><span class="line"></span><br><span class="line"># A exists</span><br><span class="line"># h not exists</span><br><span class="line">A exists</span><br><span class="line">h not exists</span><br></pre></td></tr></table></figure>

<p>【例子】比较的两个变量均指向不可变类型。</p>
<p>[10]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; &quot;hello&quot;</span><br><span class="line">b &#x3D; &quot;hello&quot;</span><br><span class="line">print(a is b, a &#x3D;&#x3D; b)  # True True</span><br><span class="line">print(a is not b, a !&#x3D; b)  # False False</span><br><span class="line">True True</span><br><span class="line">False False</span><br></pre></td></tr></table></figure>

<p>【例子】比较的两个变量均指向可变类型。</p>
<p>[11]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [&quot;hello&quot;]</span><br><span class="line">b &#x3D; [&quot;hello&quot;]</span><br><span class="line">print(a is b, a &#x3D;&#x3D; b)  # False True</span><br><span class="line">print(a is not b, a !&#x3D; b)  # True False</span><br><span class="line">False True</span><br><span class="line">True False</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>is, is not 对比的是两个变量的内存地址</li>
<li>==, != 对比的是两个变量的值</li>
<li>比较的两个变量，指向的都是地址不可变的类型（str等），那么is，is not 和 ==，！= 是完全等价的。</li>
<li>对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的。</li>
</ul>
<p><strong>运算符的优先级</strong></p>
<ul>
<li>一元运算符优于二元运算符。例如<code>3 ** -2</code>等价于<code>3 ** (-2)</code>。</li>
<li>先算术运算，后移位运算，最后位运算。例如 <code>1 &lt;&lt; 3 + 2 &amp; 7</code>等价于 <code>1 &lt;&lt; (3 + 2)) &amp; 7</code>。</li>
<li>逻辑运算最后结合。例如<code>3 &lt; 4 and 4 &lt; 5</code>等价于<code>(3 &lt; 4) and (4 &lt; 5)</code>。</li>
</ul>
<p>【例子】</p>
<p>[12]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(-3 ** 2)  # -9</span><br><span class="line">print(3 ** -2)  # 0.1111111111111111</span><br><span class="line">print(1 &lt;&lt; 3 + 2 &amp; 7)  # 0</span><br><span class="line">print(-3 * 2 + 5 &#x2F; -2 - 4)  # -12.5</span><br><span class="line">print(3 &lt; 4 and 4 &lt; 5)  # True</span><br><span class="line">-9</span><br><span class="line">0.1111111111111111</span><br><span class="line">0</span><br><span class="line">-12.5</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="3-变量和赋值"><a href="#3-变量和赋值" class="headerlink" title="3. 变量和赋值"></a>3. 变量和赋值</h2><ul>
<li>在使用变量之前，需要对其先赋值。</li>
<li>变量名可以包括字母、数字、下划线、但变量名不能以数字开头。</li>
<li>Python 变量名是大小写敏感的，foo != Foo。</li>
</ul>
<p>【例子】</p>
<p>[13]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">teacher &#x3D; &quot;老马的程序人生&quot;</span><br><span class="line">print(teacher)  # 老马的程序人生</span><br><span class="line">老马的程序人生</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[14]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first &#x3D; 2</span><br><span class="line">second &#x3D; 3</span><br><span class="line">third &#x3D; first + second</span><br><span class="line">print(third)  # 5</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[15]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myTeacher &#x3D; &quot;老马的程序人生&quot;</span><br><span class="line">yourTeacher &#x3D; &quot;小马的程序人生&quot;</span><br><span class="line">ourTeacher &#x3D; myTeacher + &#39;,&#39; + yourTeacher</span><br><span class="line">print(ourTeacher)  # 老马的程序人生,小马的程序人生</span><br><span class="line">老马的程序人生,小马的程序人生</span><br></pre></td></tr></table></figure>

<h2 id="4-数据类型与转换"><a href="#4-数据类型与转换" class="headerlink" title="4. 数据类型与转换"></a>4. 数据类型与转换</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>整型 <code>&lt;class &#39;int&#39;&gt;</code></td>
<td><code>-876, 10</code></td>
</tr>
<tr>
<td>float</td>
<td>浮点型<code>&lt;class &#39;float&#39;&gt;</code></td>
<td><code>3.149, 11.11</code></td>
</tr>
<tr>
<td>bool</td>
<td>布尔型<code>&lt;class &#39;bool&#39;&gt;</code></td>
<td><code>True, False</code></td>
</tr>
</tbody></table>
<p><strong>整型</strong></p>
<p>【例子】通过 <code>print()</code> 可看出 <code>a</code> 的值，以及类 (class) 是<code>int</code>。</p>
<p>[16]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1031</span><br><span class="line">print(a, type(a))</span><br><span class="line"># 1031 &lt;class &#39;int&#39;&gt;</span><br><span class="line">1031 &lt;class &#39;int&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>Python 里面万物皆对象（object），整型也不例外，只要是对象，就有相应的属性 （attributes） 和方法（methods）。</p>
<p>【例子】</p>
<p>[17]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b &#x3D; dir(int)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"># [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;,</span><br><span class="line"># &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;,</span><br><span class="line"># &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;,</span><br><span class="line"># &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;,</span><br><span class="line"># &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;,</span><br><span class="line"># &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;,</span><br><span class="line"># &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;,</span><br><span class="line"># &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;,</span><br><span class="line"># &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;,</span><br><span class="line"># &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;,</span><br><span class="line"># &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;,</span><br><span class="line"># &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;,</span><br><span class="line"># &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;,</span><br><span class="line"># &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;]</span><br><span class="line">[&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;, &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;, &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;, &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;]</span><br></pre></td></tr></table></figure>

<p>对它们有个大概印象就可以了，具体怎么用，需要哪些参数 （argument），还需要查文档。看个<code>bit_length()</code>的例子。</p>
<p>【例子】找到一个整数的二进制表示，再返回其长度。</p>
<p>[18]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1031</span><br><span class="line">print(bin(a))  # 0b10000000111</span><br><span class="line">print(a.bit_length())  # 11</span><br><span class="line">0b10000000111</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p><strong>浮点型</strong></p>
<p>【例子】</p>
<p>[19]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(1, type(1))</span><br><span class="line"># 1 &lt;class &#39;int&#39;&gt;</span><br><span class="line"></span><br><span class="line">print(1., type(1.))</span><br><span class="line"># 1.0 &lt;class &#39;float&#39;&gt;</span><br><span class="line"></span><br><span class="line">a &#x3D; 0.00000023</span><br><span class="line">b &#x3D; 2.3e-7</span><br><span class="line">print(a)  # 2.3e-07</span><br><span class="line">print(b)  # 2.3e-07</span><br><span class="line">1 &lt;class &#39;int&#39;&gt;</span><br><span class="line">1.0 &lt;class &#39;float&#39;&gt;</span><br><span class="line">2.3e-07</span><br><span class="line">2.3e-07</span><br></pre></td></tr></table></figure>

<p>有时候我们想保留浮点型的小数点后 <code>n</code> 位。可以用 <code>decimal</code> 包里的 <code>Decimal</code> 对象和 <code>getcontext()</code> 方法来实现。</p>
<p>[21]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import decimal</span><br><span class="line">from decimal import Decimal</span><br></pre></td></tr></table></figure>

<p>Python 里面有很多用途广泛的包 (package)，用什么你就引进 (import) 什么。包也是对象，也可以用上面提到的<code>dir(decimal)</code> 来看其属性和方法。</p>
<p>【例子】<code>getcontext()</code> 显示了 <code>Decimal</code> 对象的默认精度值是 28 位 (<code>prec=28</code>)。</p>
<p>[22]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; decimal.getcontext()</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"># Context(prec&#x3D;28, rounding&#x3D;ROUND_HALF_EVEN, Emin&#x3D;-999999, Emax&#x3D;999999,</span><br><span class="line"># capitals&#x3D;1, clamp&#x3D;0, flags&#x3D;[], </span><br><span class="line"># traps&#x3D;[InvalidOperation, DivisionByZero, Overflow])</span><br><span class="line">Context(prec&#x3D;28, rounding&#x3D;ROUND_HALF_EVEN, Emin&#x3D;-999999, Emax&#x3D;999999, capitals&#x3D;1, clamp&#x3D;0, flags&#x3D;[], traps&#x3D;[InvalidOperation, DivisionByZero, Overflow])</span><br></pre></td></tr></table></figure>

<p>[23]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b &#x3D; Decimal(1) &#x2F; Decimal(3)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"># 0.3333333333333333333333333333</span><br><span class="line">0.3333333333333333333333333333</span><br></pre></td></tr></table></figure>

<p>【例子】使 1/3 保留 4 位，用 <code>getcontext().prec</code> 来调整精度。</p>
<p>[24]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decimal.getcontext().prec &#x3D; 4</span><br><span class="line">c &#x3D; Decimal(1) &#x2F; Decimal(3)</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line"># 0.3333</span><br><span class="line">0.3333</span><br></pre></td></tr></table></figure>

<p><strong>布尔型</strong></p>
<p>布尔 (boolean) 型变量只能取两个值，<code>True</code> 和 <code>False</code>。当把布尔型变量用在数字运算中，用 <code>1</code> 和 <code>0</code> 代表 <code>True</code> 和 <code>False</code>。</p>
<p>【例子】</p>
<p>[25]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(True + True)  # 2</span><br><span class="line">print(True + False)  # 1</span><br><span class="line">print(True * False)  # 0</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>除了直接给变量赋值 <code>True</code> 和 <code>False</code>，还可以用 <code>bool(X)</code> 来创建变量，其中 <code>X</code> 可以是</p>
<ul>
<li>基本类型：整型、浮点型、布尔型</li>
<li>容器类型：字符串、元组、列表、字典和集合</li>
</ul>
<p>【例子】<code>bool</code> 作用在基本类型变量：<code>X</code> 只要不是整型 <code>0</code>、浮点型 <code>0.0</code>，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p>
<p>[26]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(type(0), bool(0), bool(1))</span><br><span class="line"># &lt;class &#39;int&#39;&gt; False True</span><br><span class="line"></span><br><span class="line">print(type(10.31), bool(0.00), bool(10.31))</span><br><span class="line"># &lt;class &#39;float&#39;&gt; False True</span><br><span class="line"></span><br><span class="line">print(type(True), bool(False), bool(True))</span><br><span class="line"># &lt;class &#39;bool&#39;&gt; False True</span><br><span class="line">&lt;class &#39;int&#39;&gt; False True</span><br><span class="line">&lt;class &#39;float&#39;&gt; False True</span><br><span class="line">&lt;class &#39;bool&#39;&gt; False True</span><br></pre></td></tr></table></figure>

<p>【例子】<code>bool</code> 作用在容器类型变量：<code>X</code> 只要不是空的变量，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p>
<p>[27]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(type(&#39;&#39;), bool(&#39;&#39;), bool(&#39;python&#39;))</span><br><span class="line"># &lt;class &#39;str&#39;&gt; False True</span><br><span class="line"></span><br><span class="line">print(type(()), bool(()), bool((10,)))</span><br><span class="line"># &lt;class &#39;tuple&#39;&gt; False True</span><br><span class="line"></span><br><span class="line">print(type([]), bool([]), bool([1, 2]))</span><br><span class="line"># &lt;class &#39;list&#39;&gt; False True</span><br><span class="line"></span><br><span class="line">print(type(&#123;&#125;), bool(&#123;&#125;), bool(&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;))</span><br><span class="line"># &lt;class &#39;dict&#39;&gt; False True</span><br><span class="line"></span><br><span class="line">print(type(set()), bool(set()), bool(&#123;1, 2&#125;))</span><br><span class="line"># &lt;class &#39;set&#39;&gt; False True</span><br><span class="line">&lt;class &#39;str&#39;&gt; False True</span><br><span class="line">&lt;class &#39;tuple&#39;&gt; False True</span><br><span class="line">&lt;class &#39;list&#39;&gt; False True</span><br><span class="line">&lt;class &#39;dict&#39;&gt; False True</span><br><span class="line">&lt;class &#39;set&#39;&gt; False True</span><br></pre></td></tr></table></figure>

<p>确定<code>bool(X)</code> 的值是 <code>True</code> 还是 <code>False</code>，就看 <code>X</code> 是不是空，空的话就是 <code>False</code>，不空的话就是 <code>True</code>。</p>
<ul>
<li>对于数值变量，<code>0</code>, <code>0.0</code> 都可认为是空的。</li>
<li>对于容器变量，里面没元素就是空的。</li>
</ul>
<p><strong>获取类型信息</strong></p>
<ul>
<li>获取类型信息 <code>type(object)</code></li>
</ul>
<p>【例子】</p>
<p>[28]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(isinstance(1, int))  # True</span><br><span class="line">print(isinstance(5.2, float))  # True</span><br><span class="line">print(isinstance(True, bool))  # True</span><br><span class="line">print(isinstance(&#39;5.2&#39;, str))  # True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li><code>type()</code> 不会认为子类是一种父类类型，不考虑继承关系。</li>
<li><code>isinstance()</code> 会认为子类是一种父类类型，考虑继承关系。</li>
</ul>
<p>如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。</p>
<p><strong>类型转换</strong></p>
<ul>
<li>转换为整型 <code>int(x, base=10)</code></li>
<li>转换为字符串 <code>str(object=&#39;&#39;)</code></li>
<li>转换为浮点型 <code>float(x)</code></li>
</ul>
<p>【例子】</p>
<p>[29]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(int(&#39;520&#39;))  # 520</span><br><span class="line">print(int(520.52))  # 520</span><br><span class="line">print(float(&#39;520.52&#39;))  # 520.52</span><br><span class="line">print(float(520))  # 520.0</span><br><span class="line">print(str(10 + 10))  # 20</span><br><span class="line">print(str(10.1 + 5.2))  # 15.3</span><br><span class="line">520</span><br><span class="line">520</span><br><span class="line">520.52</span><br><span class="line">520.0</span><br><span class="line">20</span><br><span class="line">15.3</span><br></pre></td></tr></table></figure>

<h2 id="5-print-函数"><a href="#5-print-函数" class="headerlink" title="5. print() 函数"></a>5. print() 函数</h2><p>[ ]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(*objects, sep&#x3D;&#39; &#39;, end&#x3D;&#39;\n&#39;, file&#x3D;sys.stdout, flush&#x3D;False)</span><br></pre></td></tr></table></figure>

<ul>
<li>将对象以字符串表示的方式格式化输出到流文件对象file里。其中所有非关键字参数都按<code>str()</code>方式进行转换为字符串输出；</li>
<li>关键字参数<code>sep</code>是实现分隔符，比如多个参数输出时想要输出中间的分隔字符；</li>
<li>关键字参数<code>end</code>是输出结束时的字符，默认是换行符<code>\n</code>；</li>
<li>关键字参数<code>file</code>是定义流输出的文件，可以是标准的系统输出<code>sys.stdout</code>，也可以重定义为别的文件；</li>
<li>关键字参数<code>flush</code>是立即把内容输出到流文件，不作缓存。</li>
</ul>
<p>【例子】没有参数时，每次输出后都会换行。</p>
<p>[31]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shoplist &#x3D; [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]</span><br><span class="line">print(&quot;This is printed without &#39;end&#39;and &#39;sep&#39;.&quot;)</span><br><span class="line">for item in shoplist:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"># This is printed without &#39;end&#39;and &#39;sep&#39;.</span><br><span class="line"># apple</span><br><span class="line"># mango</span><br><span class="line"># carrot</span><br><span class="line"># banana</span><br><span class="line">This is printed without &#39;end&#39;and &#39;sep&#39;.</span><br><span class="line">apple</span><br><span class="line">mango</span><br><span class="line">carrot</span><br><span class="line">banana</span><br></pre></td></tr></table></figure>

<p>【例子】每次输出结束都用<code>end</code>设置的参数<code>&amp;</code>结尾，并没有默认换行。</p>
<p>[32]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shoplist &#x3D; [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]</span><br><span class="line">print(&quot;This is printed with &#39;end&#x3D;&#39;&amp;&#39;&#39;.&quot;)</span><br><span class="line">for item in shoplist:</span><br><span class="line">    print(item, end&#x3D;&#39;&amp;&#39;)</span><br><span class="line">print(&#39;hello world&#39;)</span><br><span class="line"></span><br><span class="line"># This is printed with &#39;end&#x3D;&#39;&amp;&#39;&#39;.</span><br><span class="line"># apple&amp;mango&amp;carrot&amp;banana&amp;hello world</span><br><span class="line">This is printed with &#39;end&#x3D;&#39;&amp;&#39;&#39;.</span><br><span class="line">apple&amp;mango&amp;carrot&amp;banana&amp;hello world</span><br></pre></td></tr></table></figure>

<p>【例子】<code>item</code>值与<code>&#39;another string&#39;</code>两个值之间用<code>sep</code>设置的参数<code>&amp;</code>分割。由于<code>end</code>参数没有设置，因此默认是输出解释后换行，即<code>end</code>参数的默认值为<code>\n</code>。</p>
<p>[33]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shoplist &#x3D; [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]</span><br><span class="line">print(&quot;This is printed with &#39;sep&#x3D;&#39;&amp;&#39;&#39;.&quot;)</span><br><span class="line">for item in shoplist:</span><br><span class="line">    print(item, &#39;another string&#39;, sep&#x3D;&#39;&amp;&#39;)</span><br><span class="line"></span><br><span class="line"># This is printed with &#39;sep&#x3D;&#39;&amp;&#39;&#39;.</span><br><span class="line"># apple&amp;another string</span><br><span class="line"># mango&amp;another string</span><br><span class="line"># carrot&amp;another string</span><br><span class="line"># banana&amp;another string</span><br><span class="line">This is printed with &#39;sep&#x3D;&#39;&amp;&#39;&#39;.</span><br><span class="line">apple&amp;another string</span><br><span class="line">mango&amp;another string</span><br><span class="line">carrot&amp;another string</span><br><span class="line">banana&amp;another string</span><br></pre></td></tr></table></figure>

<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="1-原码、反码和补码"><a href="#1-原码、反码和补码" class="headerlink" title="1. 原码、反码和补码"></a>1. 原码、反码和补码</h2><p>二进制有三种不同的表示形式：原码、反码和补码，计算机内部使用补码来表示。</p>
<p><strong>原码</strong>：就是其二进制表示（注意，有一位符号位）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 00 11 -&gt; 3</span><br><span class="line">10 00 00 11 -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>反码</strong>：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 00 11 -&gt; 3</span><br><span class="line">11 11 11 00 -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>补码</strong>：正数的补码就是原码，负数的补码是反码+1。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 00 11 -&gt; 3</span><br><span class="line">11 11 11 01 -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>符号位</strong>：最高位为符号位，0表示正数，1表示负数。在位运算中符号位也参与运算。</p>
<h2 id="2-按位运算"><a href="#2-按位运算" class="headerlink" title="2. 按位运算"></a>2. 按位运算</h2><ul>
<li>按位非操作 ~</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">~ <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>~</code> 把<code>num</code>的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">~</span><br><span class="line">---</span><br><span class="line">11 11 10 10 -&gt; -6</span><br><span class="line"></span><br><span class="line">11 11 10 11 -&gt; -5</span><br><span class="line">~</span><br><span class="line">---</span><br><span class="line">00 00 01 00 -&gt; 4</span><br></pre></td></tr></table></figure>

<ul>
<li>按位与操作 &amp;</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>只有两个对应位都为 1 时才为 1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">&amp;</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 01 00 -&gt; 4</span><br></pre></td></tr></table></figure>

<ul>
<li>按位或操作 |</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>只要两个对应位中有一个 1 时就为 1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">|</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 01 11 -&gt; 7</span><br></pre></td></tr></table></figure>

<ul>
<li>按位异或操作 ^</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>只有两个对应位不同时才为 1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">^</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 00 11 -&gt; 3</span><br></pre></td></tr></table></figure>

<p>异或操作的性质：满足交换律和结合律</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A: <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span></span><br><span class="line">B: <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">A^B: <span class="number">00</span> <span class="number">00</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">B^A: <span class="number">00</span> <span class="number">00</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">A^A: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">A^<span class="number">0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span></span><br><span class="line"></span><br><span class="line">A^B^A: = A^A^B = B = <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按位左移操作 &lt;&lt;</li>
</ul>
<p><code>num &lt;&lt; i</code> 将<code>num</code>的二进制表示向左移动<code>i</code>位所得的值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 10 11 -&gt; 11</span><br><span class="line"><span class="number">11</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">01 01 10 00 -&gt; 88</span><br></pre></td></tr></table></figure>

<ul>
<li>按位右移操作 &gt;&gt;</li>
</ul>
<p><code>num &gt;&gt; i</code> 将<code>num</code>的二进制表示向右移动<code>i</code>位所得的值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 10 11 -&gt; 11</span><br><span class="line"><span class="number">11</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">---</span><br><span class="line">00 00 00 10 -&gt; 2</span><br></pre></td></tr></table></figure>

<h2 id="3-利用位运算实现快速计算"><a href="#3-利用位运算实现快速计算" class="headerlink" title="3. 利用位运算实现快速计算"></a>3. 利用位运算实现快速计算</h2><p>通过 <code>&lt;&lt;</code>，<code>&gt;&gt;</code> 快速计算2的倍数问题。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">n &lt;&lt; 1 -&gt; 计算 n*2</span><br><span class="line">n &gt;&gt; 1 -&gt; 计算 n/2，负奇数的运算不可用</span><br><span class="line">n &lt;&lt; m -&gt; 计算 n*(2^m)，即乘以 2 的 m 次方</span><br><span class="line">n &gt;&gt; m -&gt; 计算 n/(2^m)，即除以 2 的 m 次方</span><br><span class="line">1 &lt;&lt; n -&gt; 2^n</span><br></pre></td></tr></table></figure>

<p>通过 <code>^</code> 快速交换两个整数。 通过 <code>^</code> 快速交换两个整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br></pre></td></tr></table></figure>

<p>通过 <code>a &amp; (-a)</code> 快速获取<code>a</code>的最后为 1 位置的整数。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">&amp;</span><br><span class="line">11 11 10 11 -&gt; -5</span><br><span class="line">---</span><br><span class="line">00 00 00 01 -&gt; 1</span><br><span class="line"></span><br><span class="line">00 00 11 10 -&gt; 14</span><br><span class="line">&amp;</span><br><span class="line">11 11 00 10 -&gt; -14</span><br><span class="line">---</span><br><span class="line">00 00 00 10 -&gt; 2</span><br></pre></td></tr></table></figure>

<h2 id="4-利用位运算实现整数集合"><a href="#4-利用位运算实现整数集合" class="headerlink" title="4. 利用位运算实现整数集合"></a>4. 利用位运算实现整数集合</h2><p>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</p>
<p>比如集合 <code>{1, 3, 4, 8}</code>，可以表示成 <code>01 00 01 10 10</code> 而对应的位运算也就可以看作是对集合进行的操作。</p>
<p>元素与集合的操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a | (1&lt;&lt;i)  -&gt; 把 i 插入到集合中</span><br><span class="line">a &amp; ~(1&lt;&lt;i) -&gt; 把 i 从集合中删除</span><br><span class="line">a &amp; (1&lt;&lt;i)  -&gt; 判断 i 是否属于该集合（零不属于，非零属于）</span><br></pre></td></tr></table></figure>

<p>集合之间的操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a 补   -&gt; ~a</span><br><span class="line">a 交 b -&gt; a &amp; b</span><br><span class="line">a 并 b -&gt; a | b</span><br><span class="line">a 差 b -&gt; a &amp; (~b)</span><br></pre></td></tr></table></figure>

<p>注意：整数在内存中是以补码的形式存在的，输出自然也是按照补码输出。</p>
<p>【例子】C#语言输出负数。</p>
<p>[ ]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        string s1 &#x3D; Convert.ToString(-3, 2);</span><br><span class="line">        Console.WriteLine(s1); </span><br><span class="line">        &#x2F;&#x2F; 11111111111111111111111111111101</span><br><span class="line">        </span><br><span class="line">        string s2 &#x3D; Convert.ToString(-3, 16);</span><br><span class="line">        Console.WriteLine(s2); </span><br><span class="line">        &#x2F;&#x2F; fffffffd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【例子】 Python 的<code>bin()</code> 输出。</p>
<p>[37]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(bin(3))  # 0b11</span><br><span class="line">print(bin(-3))  # -0b11</span><br><span class="line"></span><br><span class="line">print(bin(-3 &amp; 0xffffffff))  </span><br><span class="line"># 0b11111111111111111111111111111101</span><br><span class="line"></span><br><span class="line">print(bin(0xfffffffd))       </span><br><span class="line"># 0b11111111111111111111111111111101</span><br><span class="line"></span><br><span class="line">print(0xfffffffd)  # 4294967293</span><br><span class="line">0b11</span><br><span class="line">-0b11</span><br><span class="line">0b11111111111111111111111111111101</span><br><span class="line">0b11111111111111111111111111111101</span><br><span class="line">4294967293</span><br></pre></td></tr></table></figure>

<p>是不是很颠覆认知，我们从结果可以看出：</p>
<ul>
<li>Python中<code>bin</code>一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，巨坑。</li>
<li>Python中的整型是补码形式存储的。</li>
<li>Python中整型是不限制长度的不会超范围溢出。</li>
</ul>
<p>所以为了获得负数（十进制表示）的补码，需要手动将其和十六进制数<code>0xffffffff</code>进行按位与操作，再交给<code>bin()</code>进行输出，得到的才是负数的补码表示。</p>
<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    expr_true_suite</span><br></pre></td></tr></table></figure>

<ul>
<li>if 语句的 <code>expr_true_suite</code> 代码块只有当条件表达式 <code>expression</code> 结果为真时才执行，否则将继续执行紧跟在该代码块后面的语句。</li>
<li>单个 if 语句中的 <code>expression</code> 条件表达式可以通过布尔操作符 <code>and</code>，<code>or</code>和<code>not</code> 实现多重条件判断。</li>
</ul>
<p>【例子】</p>
<p>[38]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if 2 &gt; 1 and not 2 &gt; 3:</span><br><span class="line">    print(&#39;Correct Judgement!&#39;)</span><br><span class="line"></span><br><span class="line"># Correct Judgement!</span><br><span class="line">Correct Judgement!</span><br></pre></td></tr></table></figure>

<h2 id="2-if-else-语句"><a href="#2-if-else-语句" class="headerlink" title="2. if - else 语句"></a>2. if - else 语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    expr_true_suite</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    expr_false_suite</span><br></pre></td></tr></table></figure>

<ul>
<li>Python 提供与 if 搭配使用的 else，如果 if 语句的条件表达式结果布尔值为假，那么程序将执行 else 语句后的代码。</li>
</ul>
<p>【例子】</p>
<p>[39]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)</span><br><span class="line">guess &#x3D; int(temp) # input 函数将接收的任何数据类型都默认为 str。</span><br><span class="line">if guess &#x3D;&#x3D; 666:</span><br><span class="line">    print(&quot;你太了解小姐姐的心思了！&quot;)</span><br><span class="line">    print(&quot;哼，猜对也没有奖励！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;猜错了，小姐姐现在心里想的是666！&quot;)</span><br><span class="line">print(&quot;游戏结束，不玩儿啦！&quot;)</span><br><span class="line">猜一猜小姐姐想的是哪个数字？666</span><br><span class="line">你太了解小姐姐的心思了！</span><br><span class="line">哼，猜对也没有奖励！</span><br><span class="line">游戏结束，不玩儿啦！</span><br></pre></td></tr></table></figure>

<p><code>if</code>语句支持嵌套，即在一个<code>if</code>语句中嵌入另一个<code>if</code>语句，从而构成不同层次的选择结构。</p>
<p>【例子】Python 使用缩进而不是大括号来标记代码块边界，因此要特别注意<code>else</code>的悬挂问题。</p>
<p>[40]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hi &#x3D; 6</span><br><span class="line">if hi &gt; 2:</span><br><span class="line">    if hi &gt; 7:</span><br><span class="line">        print(&#39;好棒!好棒!&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;切~&#39;)</span><br><span class="line"></span><br><span class="line"># 无输出</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[41]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)</span><br><span class="line">guess &#x3D; int(temp)</span><br><span class="line">if guess &gt; 8:</span><br><span class="line">    print(&quot;大了，大了&quot;)</span><br><span class="line">else:</span><br><span class="line">    if guess &#x3D;&#x3D; 8:</span><br><span class="line">        print(&quot;你太了解小姐姐的心思了！&quot;)</span><br><span class="line">        print(&quot;哼，猜对也没有奖励！&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;小了，小了&quot;)</span><br><span class="line">print(&quot;游戏结束，不玩儿啦！&quot;)</span><br><span class="line">猜一猜小姐姐想的是哪个数字？8</span><br><span class="line">你太了解小姐姐的心思了！</span><br><span class="line">哼，猜对也没有奖励！</span><br><span class="line">游戏结束，不玩儿啦！</span><br></pre></td></tr></table></figure>

<h2 id="3-if-elif-else-语句"><a href="#3-if-elif-else-语句" class="headerlink" title="3. if - elif - else 语句"></a>3. if - elif - else 语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1:</span><br><span class="line">    expr1_true_suite</span><br><span class="line"><span class="keyword">elif</span> expression2:</span><br><span class="line">    expr2_true_suite</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"><span class="keyword">elif</span> expressionN:</span><br><span class="line">    exprN_true_suite</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    expr_false_suite</span><br></pre></td></tr></table></figure>

<ul>
<li>elif 语句即为 else if，用来检查多个表达式是否为真，并在为真时执行特定代码块中的代码。</li>
</ul>
<p>【例子】</p>
<p>[42]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp &#x3D; input(&#39;请输入成绩:&#39;)</span><br><span class="line">source &#x3D; int(temp)</span><br><span class="line">if 100 &gt;&#x3D; source &gt;&#x3D; 90:</span><br><span class="line">    print(&#39;A&#39;)</span><br><span class="line">elif 90 &gt; source &gt;&#x3D; 80:</span><br><span class="line">    print(&#39;B&#39;)</span><br><span class="line">elif 80 &gt; source &gt;&#x3D; 60:</span><br><span class="line">    print(&#39;C&#39;)</span><br><span class="line">elif 60 &gt; source &gt;&#x3D; 0:</span><br><span class="line">    print(&#39;D&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;输入错误！&#39;)</span><br><span class="line">请输入成绩:99</span><br><span class="line">A</span><br></pre></td></tr></table></figure>

<h2 id="4-assert-关键词"><a href="#4-assert-关键词" class="headerlink" title="4. assert 关键词"></a>4. assert 关键词</h2><ul>
<li><code>assert</code>这个关键词我们称之为“断言”，当这个关键词后边的条件为 False 时，程序自动崩溃并抛出<code>AssertionError</code>的异常。</li>
</ul>
<p>【例子】</p>
<p>[ ]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_list &#x3D; [&#39;lsgogroup&#39;]</span><br><span class="line">my_list.pop(0)</span><br><span class="line">assert len(my_list) &gt; 0</span><br><span class="line"></span><br><span class="line"># AssertionError</span><br></pre></td></tr></table></figure>

<p>【例子】在进行单元测试时，可以用来在程序中置入检查点，只有条件为 True 才能让程序正常工作。</p>
<p>[ ]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert 3 &gt; 7</span><br><span class="line"></span><br><span class="line"># AssertionError</span><br></pre></td></tr></table></figure>

<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a>1. while 循环</h2><p><code>while</code>语句最基本的形式包括一个位于顶部的布尔表达式，一个或多个属于<code>while</code>代码块的缩进语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 布尔表达式:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<p><code>while</code>循环的代码块会一直循环执行，直到布尔表达式的值为布尔假。</p>
<p>如果布尔表达式不带有<code>&lt;、&gt;、==、！=、in、not in</code>等运算符，仅仅给出数值之类的条件，也是可以的。当<code>while</code>后写入一个非零整数时，视为真值，执行循环体；写入<code>0</code>时，视为假值，不执行循环体。也可以写入<code>str、list</code>或任何序列，长度非零则视为真值，执行循环体；否则视为假值，不执行循环体。</p>
<p>【例子】</p>
<p>[44]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count &#x3D; 0</span><br><span class="line">while count &lt; 3:</span><br><span class="line">    temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)</span><br><span class="line">    guess &#x3D; int(temp)</span><br><span class="line">    if guess &gt; 8:</span><br><span class="line">        print(&quot;大了，大了&quot;)</span><br><span class="line">    else:</span><br><span class="line">        if guess &#x3D;&#x3D; 8:</span><br><span class="line">            print(&quot;你太了解小姐姐的心思了！&quot;)</span><br><span class="line">            print(&quot;哼，猜对也没有奖励！&quot;)</span><br><span class="line">            count &#x3D; 3</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;小了，小了&quot;)</span><br><span class="line">    count &#x3D; count + 1</span><br><span class="line">print(&quot;游戏结束，不玩儿啦！&quot;)</span><br><span class="line">猜一猜小姐姐想的是哪个数字？8</span><br><span class="line">你太了解小姐姐的心思了！</span><br><span class="line">哼，猜对也没有奖励！</span><br><span class="line">游戏结束，不玩儿啦！</span><br></pre></td></tr></table></figure>

<p>【例子】布尔表达式返回0，循环终止。</p>
<p>[45]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string &#x3D; &#39;abcd&#39;</span><br><span class="line">while string:</span><br><span class="line">    print(string)</span><br><span class="line">    string &#x3D; string[1:]</span><br><span class="line"></span><br><span class="line"># abcd</span><br><span class="line"># bcd</span><br><span class="line"># cd</span><br><span class="line"># d</span><br><span class="line">abcd</span><br><span class="line">bcd</span><br><span class="line">cd</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-while-else-循环"><a href="#2-while-else-循环" class="headerlink" title="2. while - else 循环"></a>2. while - else 循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 布尔表达式:</span><br><span class="line">    代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<p>当<code>while</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>while</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容。</p>
<p>【例子】</p>
<p>[46]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count &#x3D; 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">    print(&quot;%d is  less than 5&quot; % count)</span><br><span class="line">    count &#x3D; count + 1</span><br><span class="line">else:</span><br><span class="line">    print(&quot;%d is not less than 5&quot; % count)</span><br><span class="line">    </span><br><span class="line"># 0 is  less than 5</span><br><span class="line"># 1 is  less than 5</span><br><span class="line"># 2 is  less than 5</span><br><span class="line"># 3 is  less than 5</span><br><span class="line"># 4 is  less than 5</span><br><span class="line"># 5 is not less than 5</span><br><span class="line">0 is  less than 5</span><br><span class="line">1 is  less than 5</span><br><span class="line">2 is  less than 5</span><br><span class="line">3 is  less than 5</span><br><span class="line">4 is  less than 5</span><br><span class="line">5 is not less than 5</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[47]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count &#x3D; 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">    print(&quot;%d is  less than 5&quot; % count)</span><br><span class="line">    count &#x3D; 6</span><br><span class="line">    break</span><br><span class="line">else:</span><br><span class="line">    print(&quot;%d is not less than 5&quot; % count)</span><br><span class="line"></span><br><span class="line"># 0 is  less than 5</span><br><span class="line">0 is  less than 5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h2><p><code>for</code>循环是迭代循环，在Python中相当于一个通用的序列迭代器，可以遍历任何有序序列，如<code>str、list、tuple</code>等，也可以遍历任何可迭代对象，如<code>dict</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<p>每次循环，迭代变量被设置为可迭代对象的当前元素，提供给代码块使用。</p>
<p>【例子】</p>
<p>[48]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in &#39;ILoveLSGO&#39;:</span><br><span class="line">    print(i, end&#x3D;&#39; &#39;)  # 不换行输出</span><br><span class="line"></span><br><span class="line"># I L o v e L S G O</span><br><span class="line">I L o v e L S G O</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[49]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">member &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;刘德华&#39;, &#39;刘六&#39;, &#39;周润发&#39;]</span><br><span class="line">for each in member:</span><br><span class="line">    print(each)</span><br><span class="line"></span><br><span class="line"># 张三</span><br><span class="line"># 李四</span><br><span class="line"># 刘德华</span><br><span class="line"># 刘六</span><br><span class="line"># 周润发</span><br><span class="line"></span><br><span class="line">for i in range(len(member)):</span><br><span class="line">    print(member[i])</span><br><span class="line"></span><br><span class="line"># 张三</span><br><span class="line"># 李四</span><br><span class="line"># 刘德华</span><br><span class="line"># 刘六</span><br><span class="line"># 周润发</span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">刘德华</span><br><span class="line">刘六</span><br><span class="line">周润发</span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">刘德华</span><br><span class="line">刘六</span><br><span class="line">周润发</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[50]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line"></span><br><span class="line">for key, value in dic.items():</span><br><span class="line">    print(key, value, sep&#x3D;&#39;:&#39;, end&#x3D;&#39; &#39;)</span><br><span class="line">    </span><br><span class="line"># a:1 b:2 c:3 d:4 </span><br><span class="line">a:1 b:2 c:3 d:4</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[51]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line"></span><br><span class="line">for key in dic.keys():</span><br><span class="line">    print(key, end&#x3D;&#39; &#39;)</span><br><span class="line">    </span><br><span class="line"># a b c d </span><br><span class="line">a b c d</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[52]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line"></span><br><span class="line">for value in dic.values():</span><br><span class="line">    print(value, end&#x3D;&#39; &#39;)</span><br><span class="line">    </span><br><span class="line"># 1 2 3 4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-for-else-循环"><a href="#4-for-else-循环" class="headerlink" title="4. for - else 循环"></a>4. for - else 循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">    代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<p>当<code>for</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>for</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容，与<code>while - else</code>语句一样。</p>
<p>【例子】</p>
<p>[53]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for num in range(10, 20):  # 迭代 10 到 20 之间的数字</span><br><span class="line">    for i in range(2, num):  # 根据因子迭代</span><br><span class="line">        if num % i &#x3D;&#x3D; 0:  # 确定第一个因子</span><br><span class="line">            j &#x3D; num &#x2F; i  # 计算第二个因子</span><br><span class="line">            print(&#39;%d 等于 %d * %d&#39; % (num, i, j))</span><br><span class="line">            break  # 跳出当前循环</span><br><span class="line">    else:  # 循环的 else 部分</span><br><span class="line">        print(num, &#39;是一个质数&#39;)</span><br><span class="line"></span><br><span class="line"># 10 等于 2 * 5</span><br><span class="line"># 11 是一个质数</span><br><span class="line"># 12 等于 2 * 6</span><br><span class="line"># 13 是一个质数</span><br><span class="line"># 14 等于 2 * 7</span><br><span class="line"># 15 等于 3 * 5</span><br><span class="line"># 16 等于 2 * 8</span><br><span class="line"># 17 是一个质数</span><br><span class="line"># 18 等于 2 * 9</span><br><span class="line"># 19 是一个质数</span><br><span class="line">10 等于 2 * 5</span><br><span class="line">11 是一个质数</span><br><span class="line">12 等于 2 * 6</span><br><span class="line">13 是一个质数</span><br><span class="line">14 等于 2 * 7</span><br><span class="line">15 等于 3 * 5</span><br><span class="line">16 等于 2 * 8</span><br><span class="line">17 是一个质数</span><br><span class="line">18 等于 2 * 9</span><br><span class="line">19 是一个质数</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-range-函数"><a href="#5-range-函数" class="headerlink" title="5. range() 函数"></a>5. range() 函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">range([start,] stop[, step=<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>这个BIF（Built-in functions）有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。</li>
<li><code>step=1</code> 表示第三个参数的默认值是1。</li>
<li><code>range</code> 这个BIF的作用是生成一个从<code>start</code>参数的值开始到<code>stop</code>参数的值结束的数字序列，该序列包含<code>start</code>的值但不包含<code>stop</code>的值。</li>
</ul>
<p>【例子】</p>
<p>[54]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(2, 9):  # 不包含9</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line"># 3</span><br><span class="line"># 4</span><br><span class="line"># 5</span><br><span class="line"># 6</span><br><span class="line"># 7</span><br><span class="line"># 8</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[55]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(1, 10, 2):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># 1</span><br><span class="line"># 3</span><br><span class="line"># 5</span><br><span class="line"># 7</span><br><span class="line"># 9</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-enumerate-函数"><a href="#6-enumerate-函数" class="headerlink" title="6. enumerate()函数"></a>6. enumerate()函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">enumerate(sequence, [start=<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>sequence：一个序列、迭代器或其他支持迭代对象。</li>
<li>start：下标起始位置。</li>
<li>返回 enumerate(枚举) 对象</li>
</ul>
<p>【例子】</p>
<p>[56]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seasons &#x3D; [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]</span><br><span class="line">lst &#x3D; list(enumerate(seasons))</span><br><span class="line">print(lst)</span><br><span class="line"># [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span><br><span class="line">lst &#x3D; list(enumerate(seasons, start&#x3D;1))  # 下标从 1 开始</span><br><span class="line">print(lst)</span><br><span class="line"># [(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span><br><span class="line">[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span><br><span class="line">[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</span><br></pre></td></tr></table></figure>

<p><code>enumerate()</code>与 for 循环的结合使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(A)</span><br><span class="line">    do something <span class="keyword">with</span> a</span><br></pre></td></tr></table></figure>

<p>用 <code>enumerate(A)</code> 不仅返回了 <code>A</code> 中的元素，还顺便给该元素一个索引值 (默认从 0 开始)。此外，用 <code>enumerate(A, j)</code> 还可以确定索引起始值为 <code>j</code>。</p>
<p>【例子】</p>
<p>[57]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">languages &#x3D; [&#39;Python&#39;, &#39;R&#39;, &#39;Matlab&#39;, &#39;C++&#39;]</span><br><span class="line">for language in languages:</span><br><span class="line">    print(&#39;I love&#39;, language)</span><br><span class="line">print(&#39;Done!&#39;)</span><br><span class="line"># I love Python</span><br><span class="line"># I love R</span><br><span class="line"># I love Matlab</span><br><span class="line"># I love C++</span><br><span class="line"># Done!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i, language in enumerate(languages, 2):</span><br><span class="line">    print(i, &#39;I love&#39;, language)</span><br><span class="line">print(&#39;Done!&#39;)</span><br><span class="line"># 2 I love Python</span><br><span class="line"># 3 I love R</span><br><span class="line"># 4 I love Matlab</span><br><span class="line"># 5 I love C++</span><br><span class="line"># Done!</span><br><span class="line">I love Python</span><br><span class="line">I love R</span><br><span class="line">I love Matlab</span><br><span class="line">I love C++</span><br><span class="line">Done!</span><br><span class="line">2 I love Python</span><br><span class="line">3 I love R</span><br><span class="line">4 I love Matlab</span><br><span class="line">5 I love C++</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-break-语句"><a href="#7-break-语句" class="headerlink" title="7. break 语句"></a>7. break 语句</h2><p><code>break</code>语句可以跳出当前所在层的循环。</p>
<p>【例子】</p>
<p>[59]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">secret &#x3D; random.randint(1, 10) #[1,10]之间的随机数</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)</span><br><span class="line">    guess &#x3D; int(temp)</span><br><span class="line">    if guess &gt; secret:</span><br><span class="line">        print(&quot;大了，大了&quot;)</span><br><span class="line">    else:</span><br><span class="line">        if guess &#x3D;&#x3D; secret:</span><br><span class="line">            print(&quot;你太了解小姐姐的心思了！&quot;)</span><br><span class="line">            print(&quot;哼，猜对也没有奖励！&quot;)</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;小了，小了&quot;)</span><br><span class="line">print(&quot;游戏结束，不玩儿啦！&quot;)</span><br><span class="line">猜一猜小姐姐想的是哪个数字？8</span><br><span class="line">你太了解小姐姐的心思了！</span><br><span class="line">哼，猜对也没有奖励！</span><br><span class="line">游戏结束，不玩儿啦！</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-continue-语句"><a href="#8-continue-语句" class="headerlink" title="8. continue 语句"></a>8. continue 语句</h2><p><code>continue</code>终止本轮循环并开始下一轮循环。</p>
<p>【例子】</p>
<p>[60]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    if i % 2 !&#x3D; 0:</span><br><span class="line">        print(i)</span><br><span class="line">        continue</span><br><span class="line">    i +&#x3D; 2</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line"># 1</span><br><span class="line"># 4</span><br><span class="line"># 3</span><br><span class="line"># 6</span><br><span class="line"># 5</span><br><span class="line"># 8</span><br><span class="line"># 7</span><br><span class="line"># 10</span><br><span class="line"># 9</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">10</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-pass-语句"><a href="#9-pass-语句" class="headerlink" title="9. pass 语句"></a>9. pass 语句</h2><p><code>pass</code> 语句的意思是“不做任何事”，如果你在需要有语句的地方不写任何语句，那么解释器会提示出错，而 <code>pass</code> 语句就是用来解决这些问题的。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SyntaxError: unexpected EOF while parsing</span></span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>pass</code>是空语句，不做任何操作，只起到占位的作用，其作用是为了保持程序结构的完整性。尽管<code>pass</code>语句不做任何操作，但如果暂时不确定要在一个位置放上什么样的代码，可以先放置一个<code>pass</code>语句，让代码可以正常运行。</p>
<hr>
<h2 id="10-推导式"><a href="#10-推导式" class="headerlink" title="10. 推导式"></a>10. 推导式</h2><p><strong>列表推导式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ expr <span class="keyword">for</span> value <span class="keyword">in</span> collection [<span class="keyword">if</span> condition] ]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[61]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [-4, -2, 0, 2, 4]</span><br><span class="line">y &#x3D; [a * 2 for a in x]</span><br><span class="line">print(y)</span><br><span class="line"># [-8, -4, 0, 4, 8]</span><br><span class="line">[-8, -4, 0, 4, 8]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[63]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [i ** 2 for i in range(1, 10)]</span><br><span class="line">print(x)</span><br><span class="line"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[64]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [(i, i ** 2) for i in range(6)]</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"># [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</span><br><span class="line">[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[65]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [i for i in range(100) if (i % 2) !&#x3D; 0 and (i % 3) &#x3D;&#x3D; 0]</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line"># [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]</span><br><span class="line">[3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[66]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [(i, j) for i in range(0, 3) for j in range(0, 3)]</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"># [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span><br><span class="line">[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[67]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [[i, j] for i in range(0, 3) for j in range(0, 3)]</span><br><span class="line">print(x)</span><br><span class="line"># [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span><br><span class="line"></span><br><span class="line">x[0][0] &#x3D; 10</span><br><span class="line">print(x)</span><br><span class="line"># [[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span><br><span class="line">[[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span><br><span class="line">[[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[68]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [(i, j) for i in range(0, 3) if i &lt; 1 for j in range(0, 3) if j &gt; 1]</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"># [(0, 2)]</span><br><span class="line">[(0, 2)]</span><br></pre></td></tr></table></figure>

<p><strong>元组推导式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">( expr <span class="keyword">for</span> value <span class="keyword">in</span> collection [<span class="keyword">if</span> condition] )</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[69]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; (x for x in range(10))</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"># &lt;generator object &lt;genexpr&gt; at 0x0000025BE511CC48&gt;</span><br><span class="line"></span><br><span class="line">print(tuple(a))</span><br><span class="line"></span><br><span class="line"># (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000014CEC2E28B8&gt;</span><br><span class="line">(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br></pre></td></tr></table></figure>

<p><strong>字典推导式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection [<span class="keyword">if</span> condition] &#125;</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[70]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b &#x3D; &#123;i: i % 2 &#x3D;&#x3D; 0 for i in range(10) if i % 3 &#x3D;&#x3D; 0&#125;</span><br><span class="line">print(b)</span><br><span class="line"># &#123;0: True, 3: False, 6: True, 9: False&#125;</span><br><span class="line">&#123;0: True, 3: False, 6: True, 9: False&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合推导式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; expr for value in collection [if condition] &#125;</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[71]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c &#x3D; &#123;i for i in [1, 2, 3, 4, 5, 5, 6, 4, 3, 2, 1]&#125;</span><br><span class="line">print(c)</span><br><span class="line"># &#123;1, 2, 3, 4, 5, 6&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5, 6&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其它</strong></p>
<ul>
<li><code>next(iterator[, default])</code> Return the next item from the iterator. If default is given and the iterator is exhausted, it is returned instead of raising StopIteration.</li>
</ul>
<p>【例子】</p>
<p>[72]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e &#x3D; (i for i in range(10))</span><br><span class="line">print(e)</span><br><span class="line"># &lt;generator object &lt;genexpr&gt; at 0x0000007A0B8D01B0&gt;</span><br><span class="line"></span><br><span class="line">print(next(e))  # 0</span><br><span class="line">print(next(e))  # 1</span><br><span class="line"></span><br><span class="line">for each in e:</span><br><span class="line">    print(each, end&#x3D;&#39; &#39;)</span><br><span class="line"></span><br><span class="line"># 2 3 4 5 6 7 8 9</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000014CEC389C78&gt;</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[73]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; sum([i for i in range(101)])</span><br><span class="line">print(s)  # 5050</span><br><span class="line">s &#x3D; sum((i for i in range(101)))</span><br><span class="line">print(s)  # 5050</span><br><span class="line">5050</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而恢复程序的正常运行。</p>
<h2 id="1-Python-标准异常总结"><a href="#1-Python-标准异常总结" class="headerlink" title="1. Python 标准异常总结"></a>1. Python 标准异常总结</h2><ul>
<li>BaseException：所有异常的 <strong>基类</strong></li>
<li>Exception：常规异常的 <strong>基类</strong></li>
<li>StandardError：所有的内建标准异常的基类</li>
<li>ArithmeticError：所有数值计算异常的基类</li>
<li>FloatingPointError：浮点计算异常</li>
<li>OverflowError：数值运算超出最大限制</li>
<li>ZeroDivisionError：除数为零</li>
<li>AssertionError：断言语句（assert）失败</li>
<li>AttributeError：尝试访问未知的对象属性</li>
<li>EOFError：没有内建输入，到达EOF标记</li>
<li>EnvironmentError：操作系统异常的基类</li>
<li>IOError：输入/输出操作失败</li>
<li>OSError：操作系统产生的异常（例如打开一个不存在的文件）</li>
<li>WindowsError：系统调用失败</li>
<li>ImportError：导入模块失败的时候</li>
<li>KeyboardInterrupt：用户中断执行</li>
<li>LookupError：无效数据查询的基类</li>
<li>IndexError：索引超出序列的范围</li>
<li>KeyError：字典中查找一个不存在的关键字</li>
<li>MemoryError：内存溢出（可通过删除对象释放内存）</li>
<li>NameError：尝试访问一个不存在的变量</li>
<li>UnboundLocalError：访问未初始化的本地变量</li>
<li>ReferenceError：弱引用试图访问已经垃圾回收了的对象</li>
<li>RuntimeError：一般的运行时异常</li>
<li>NotImplementedError：尚未实现的方法</li>
<li>SyntaxError：语法错误导致的异常</li>
<li>IndentationError：缩进错误导致的异常</li>
<li>TabError：Tab和空格混用</li>
<li>SystemError：一般的解释器系统异常</li>
<li>TypeError：不同类型间的无效操作</li>
<li>ValueError：传入无效的参数</li>
<li>UnicodeError：Unicode相关的异常</li>
<li>UnicodeDecodeError：Unicode解码时的异常</li>
<li>UnicodeEncodeError：Unicode编码错误导致的异常</li>
<li>UnicodeTranslateError：Unicode转换错误导致的异常</li>
</ul>
<p>异常体系内部有层次关系，Python异常体系中的部分关系如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200710131404548.png" alt="Image"></p>
<hr>
<h2 id="2-Python标准警告总结"><a href="#2-Python标准警告总结" class="headerlink" title="2. Python标准警告总结"></a>2. Python标准警告总结</h2><ul>
<li>Warning：警告的基类</li>
<li>DeprecationWarning：关于被弃用的特征的警告</li>
<li>FutureWarning：关于构造将来语义会有改变的警告</li>
<li>UserWarning：用户代码生成的警告</li>
<li>PendingDeprecationWarning：关于特性将会被废弃的警告</li>
<li>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告</li>
<li>SyntaxWarning：可疑语法的警告</li>
<li>ImportWarning：用于在导入模块过程中触发的警告</li>
<li>UnicodeWarning：与Unicode相关的警告</li>
<li>BytesWarning：与字节或字节码相关的警告</li>
<li>ResourceWarning：与资源使用相关的警告</li>
</ul>
<hr>
<h2 id="3-try-except-语句"><a href="#3-try-except-语句" class="headerlink" title="3. try - except 语句"></a>3. try - except 语句</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检测范围</span><br><span class="line"><span class="keyword">except</span> Exception[<span class="keyword">as</span> reason]:</span><br><span class="line">    出现异常后的处理代码</span><br></pre></td></tr></table></figure>

<p>try 语句按照如下方式工作：</p>
<ul>
<li>首先，执行<code>try</code>子句（在关键字<code>try</code>和关键字<code>except</code>之间的语句）</li>
<li>如果没有异常发生，忽略<code>except</code>子句，<code>try</code>子句执行后结束。</li>
<li>如果在执行<code>try</code>子句的过程中发生了异常，那么<code>try</code>子句余下的部分将被忽略。如果异常的类型和<code>except</code>之后的名称相符，那么对应的<code>except</code>子句将被执行。最后执行<code>try - except</code>语句之后的代码。</li>
<li>如果一个异常没有与任何的<code>except</code>匹配，那么这个异常将会传递给上层的<code>try</code>中。</li>
</ul>
<p>【例子】</p>
<p>[2]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    f &#x3D; open(&#39;test.txt&#39;)</span><br><span class="line">    print(f.read())</span><br><span class="line">    f.close()</span><br><span class="line">except OSError:</span><br><span class="line">    print(&#39;打开文件出错&#39;)</span><br><span class="line"></span><br><span class="line"># 打开文件出错</span><br><span class="line">打开文件出错</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[3]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    f &#x3D; open(&#39;test.txt&#39;)</span><br><span class="line">    print(f.read())</span><br><span class="line">    f.close()</span><br><span class="line">except OSError as error:</span><br><span class="line">    print(&#39;打开文件出错\n原因是：&#39; + str(error))</span><br><span class="line"></span><br><span class="line"># 打开文件出错</span><br><span class="line"># 原因是：[Errno 2] No such file or directory: &#39;test.txt&#39;</span><br><span class="line">打开文件出错</span><br><span class="line">原因是：[Errno 2] No such file or directory: &#39;test.txt&#39;</span><br></pre></td></tr></table></figure>

<p>一个<code>try</code>语句可能包含多个<code>except</code>子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p>
<p>【例子】</p>
<p>[4]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    int(&quot;abc&quot;)</span><br><span class="line">    s &#x3D; 1 + &#39;1&#39;</span><br><span class="line">    f &#x3D; open(&#39;test.txt&#39;)</span><br><span class="line">    print(f.read())</span><br><span class="line">    f.close()</span><br><span class="line">except OSError as error:</span><br><span class="line">    print(&#39;打开文件出错\n原因是：&#39; + str(error))</span><br><span class="line">except TypeError as error:</span><br><span class="line">    print(&#39;类型出错\n原因是：&#39; + str(error))</span><br><span class="line">except ValueError as error:</span><br><span class="line">    print(&#39;数值出错\n原因是：&#39; + str(error))</span><br><span class="line"></span><br><span class="line"># 数值出错</span><br><span class="line"># 原因是：invalid literal for int() with base 10: &#39;abc&#39;</span><br><span class="line">数值出错</span><br><span class="line">原因是：invalid literal for int() with base 10: &#39;abc&#39;</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[5]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;v&#39;: 22&#125;</span><br><span class="line">try:</span><br><span class="line">    x &#x3D; dict1[&#39;y&#39;]</span><br><span class="line">except LookupError:</span><br><span class="line">    print(&#39;查询错误&#39;)</span><br><span class="line">except KeyError:</span><br><span class="line">    print(&#39;键错误&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"># 查询错误</span><br><span class="line">查询错误</span><br></pre></td></tr></table></figure>

<p><code>try-except-else</code>语句尝试查询不在<code>dict</code>中的键值对，从而引发了异常。这一异常准确地说应属于<code>KeyError</code>，但由于<code>KeyError</code>是<code>LookupError</code>的子类，且将<code>LookupError</code>置于<code>KeyError</code>之前，因此程序优先执行该<code>except</code>代码块。所以，使用多个<code>except</code>代码块时，必须坚持对其规范排序，要从最具针对性的异常到最通用的异常。</p>
<p>【例子】</p>
<p>[6]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;v&#39;: 22&#125;</span><br><span class="line">try:</span><br><span class="line">    x &#x3D; dict1[&#39;y&#39;]</span><br><span class="line">except KeyError:</span><br><span class="line">    print(&#39;键错误&#39;)</span><br><span class="line">except LookupError:</span><br><span class="line">    print(&#39;查询错误&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"># 键错误</span><br><span class="line">键错误</span><br></pre></td></tr></table></figure>

<p>【例子】一个 <code>except</code> 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。</p>
<p>[7]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    s &#x3D; 1 + &#39;1&#39;</span><br><span class="line">    int(&quot;abc&quot;)</span><br><span class="line">    f &#x3D; open(&#39;test.txt&#39;)</span><br><span class="line">    print(f.read())</span><br><span class="line">    f.close()</span><br><span class="line">except (OSError, TypeError, ValueError) as error:</span><br><span class="line">    print(&#39;出错了！\n原因是：&#39; + str(error))</span><br><span class="line"></span><br><span class="line"># 出错了！</span><br><span class="line"># 原因是：unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br><span class="line">出错了！</span><br><span class="line">原因是：unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-try-except-finally-语句"><a href="#4-try-except-finally-语句" class="headerlink" title="4. try - except - finally 语句"></a>4. try - except - finally 语句</h2><p>try: 检测范围 except Exception[as reason]: 出现异常后的处理代码 finally: 无论如何都会被执行的代码</p>
<p>不管<code>try</code>子句里面有没有发生异常，<code>finally</code>子句都会执行。</p>
<p>【例子】如果一个异常在<code>try</code>子句里被抛出，而又没有任何的<code>except</code>把它截住，那么这个异常会在<code>finally</code>子句执行后被抛出。</p>
<p>[10]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def divide(x, y):</span><br><span class="line">    try:</span><br><span class="line">        result &#x3D; x &#x2F; y</span><br><span class="line">        print(&quot;result is&quot;, result)</span><br><span class="line">    except ZeroDivisionError:</span><br><span class="line">        print(&quot;division by zero!&quot;)</span><br><span class="line">    finally:</span><br><span class="line">        print(&quot;executing finally clause&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">divide(2, 1)</span><br><span class="line"># result is 2.0</span><br><span class="line"># executing finally clause</span><br><span class="line">divide(2, 0)</span><br><span class="line"># division by zero!</span><br><span class="line"># executing finally clause</span><br><span class="line">divide(&quot;2&quot;, &quot;1&quot;)</span><br><span class="line"># executing finally clause</span><br><span class="line"># TypeError: unsupported operand type(s) for &#x2F;: &#39;str&#39; and &#39;str&#39;</span><br><span class="line">result is 2.0</span><br><span class="line">executing finally clause</span><br><span class="line">division by zero!</span><br><span class="line">executing finally clause</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-try-except-else-语句"><a href="#5-try-except-else-语句" class="headerlink" title="5. try - except - else 语句"></a>5. try - except - else 语句</h2><p>如果在<code>try</code>子句执行时没有发生异常，Python将执行<code>else</code>语句后的语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    检测范围</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    出现异常后的处理代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure>

<p>使用<code>except</code>而不带任何异常类型，这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息，因为它捕获所有的异常。</p>
<p>try: 检测范围 except(Exception1[, Exception2[,…ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 else: 如果没有异常执行这块代码</p>
<p>【例子】</p>
<p>[12]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    fh &#x3D; open(&quot;testfile.txt&quot;, &quot;w&quot;)</span><br><span class="line">    fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)</span><br><span class="line">except IOError:</span><br><span class="line">    print(&quot;Error: 没有找到文件或读取文件失败&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;内容写入文件成功&quot;)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line"># 内容写入文件成功</span><br><span class="line">内容写入文件成功</span><br></pre></td></tr></table></figure>

<p>注意：<code>else</code>语句的存在必须以<code>except</code>语句的存在为前提，在没有<code>except</code>语句的<code>try</code>语句中使用<code>else</code>语句，会引发语法错误。</p>
<hr>
<h2 id="6-raise语句"><a href="#6-raise语句" class="headerlink" title="6. raise语句"></a>6. raise语句</h2><p>Python 使用<code>raise</code>语句抛出一个指定的异常。</p>
<p>【例子】</p>
<p>[13]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise NameError(&#39;HiThere&#39;)</span><br><span class="line">except NameError:</span><br><span class="line">    print(&#39;An exception flew by!&#39;)</span><br><span class="line">    </span><br><span class="line"># An exception flew by!</span><br><span class="line">An exception flew by!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot之配置自定义servlet|filter|listener</title>
    <url>/2020/04/10/spring-boot%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89servlet-filter-listener/</url>
    <content><![CDATA[<h3 id="配置Servlet"><a href="#配置Servlet" class="headerlink" title="配置Servlet"></a>配置Servlet</h3><h4 id="法一注解式"><a href="#法一注解式" class="headerlink" title="法一注解式"></a>法一注解式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义servlet，利用@WebServlet注解标识，并在启动类添加扫描，这样项目启动时会将该servlet注入到ioc容器</span><br><span class="line">@WebServlet(name &#x3D; &quot;secondServlet&quot;,urlPatterns &#x3D; &quot;&#x2F;second&quot;)</span><br><span class="line">public class SecondServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;second servlet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">&#x2F;&#x2F;启动时会扫面@WebServlet,@WebFilter,@WebListener注解,下面的例子同理</span><br><span class="line">@ServletComponentScan</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="法二Bean式"><a href="#法二Bean式" class="headerlink" title="法二Bean式"></a>法二Bean式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;主要通过@Configration配置类将该servlet注入到容器中</span><br><span class="line">public class FirstServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;first servlet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过这种方式则不需要在启动类上添加@ServletComponentScan注解</span><br><span class="line">@Configuration</span><br><span class="line">public class ServletConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean getServlet()&#123;</span><br><span class="line">        ServletRegistrationBean bean &#x3D; new ServletRegistrationBean(new FirstServlet());</span><br><span class="line">        bean.addUrlMappings(&quot;&#x2F;first&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置Filter"><a href="#配置Filter" class="headerlink" title="配置Filter"></a>配置Filter</h3><p>通过上面的介绍，filter和listener就很好掌握，只要同理就行</p>
<h4 id="法一注解式-1"><a href="#法一注解式-1" class="headerlink" title="法一注解式"></a>法一注解式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;利用WebFilter注解注入容器，并在启动类上添加@ServletComponentScan</span><br><span class="line">@WebFilter(filterName &#x3D; &quot;FirstFilter&quot;,urlPatterns &#x3D; &quot;&#x2F;first&quot;)</span><br><span class="line">public class FirstFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;进入first filter&quot;);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(&quot;离开first filter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="法二Bean式-1"><a href="#法二Bean式-1" class="headerlink" title="法二Bean式"></a>法二Bean式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SecondFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;进入Second filter&quot;);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(&quot;离开Second filter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FilterConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean getFilter()&#123;</span><br><span class="line">        FilterRegistrationBean bean &#x3D; new FilterRegistrationBean(new SecondFilter());</span><br><span class="line">        &#x2F;&#x2F;bean.addUrlPatterns(new String[]&#123;&quot;*.do&quot;,&quot;*.jsp&quot;&#125;);&#x2F;&#x2F;配置多个过滤模式</span><br><span class="line">        bean.addUrlPatterns(&quot;&#x2F;second filter&quot;);&#x2F;&#x2F;必须要有斜杠</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置Listener"><a href="#配置Listener" class="headerlink" title="配置Listener"></a>配置Listener</h3><h4 id="法一注解式-2"><a href="#法一注解式-2" class="headerlink" title="法一注解式"></a>法一注解式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;利用@WebListener注解注入容器，并在启动类上添加@ServletComponentScan</span><br><span class="line">@WebListener</span><br><span class="line">public class FirstListener implements ServletContextListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;first listener init..,&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="法二Bean式-2"><a href="#法二Bean式-2" class="headerlink" title="法二Bean式"></a>法二Bean式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ListenerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletListenerRegistrationBean getListener()&#123;</span><br><span class="line">        ServletListenerRegistrationBean bean &#x3D; new ServletListenerRegistrationBean(new SecondListener());</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>servlet</tag>
        <tag>filter</tag>
        <tag>listener</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu双网卡网络设置</title>
    <url>/2020/09/10/ubuntu%E5%8F%8C%E7%BD%91%E5%8D%A1%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="当前操作"><a href="#当前操作" class="headerlink" title="当前操作"></a>当前操作</h4><p>在<code>/etc/rc.local</code>启动文件中添加<code>route add</code>命令指定网段，网卡和网关信息</p>
<p>sudo route add -net 192.168.8.0/24 【内网网卡名】</p>
<p>sudo route add -net 192.168.8.0/24 gw 192.168.8.1 # 路由网关地址</p>
<p>sudo route add -net 192.168.10.0/24 【外网网卡名】</p>
<p>sudo route add -net 192.168.10.0/24 gw 192.168.10.1 # 路由网关地址</p>
<h5 id="route-n"><a href="#route-n" class="headerlink" title="route -n"></a>route -n</h5><p>查看路由表</p>
<h5 id="route-add"><a href="#route-add" class="headerlink" title="route add"></a>route add</h5><p><em>命令解释</em>：<code>route add</code>命令的主要作用是添加静态路由</p>
<h5 id="route-del"><a href="#route-del" class="headerlink" title="route del"></a>route del</h5><p><em>命令解释</em>：<code>route del</code>命令的主要作用是删除<code>route -n</code>列出的静态路由。（网段相同，掩码相同则从上到下一条条删除）</p>
<p><em>注意</em>：直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来设置路由永久有效。</p>
<h4 id="目前遇到的问题"><a href="#目前遇到的问题" class="headerlink" title="目前遇到的问题"></a>目前遇到的问题</h4><ol>
<li><p>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 可以ping通</p>
<p>但是ping局域网内的其他机器会没有反应（怀疑是不是huawei路由器的问题-待验证）</p>
</li>
<li><p>指定相关<code>IP</code>到指定的网卡，使得访问只能走指定的网关（目前思路：可能需要修改<code>host</code>文件？通过<code>route add</code>命令设置到指定网关）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>python入门（中）</title>
    <url>/2020/09/10/python%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Python入门-中"><a href="#Python入门-中" class="headerlink" title="Python入门(中)"></a>Python入门(中)</h1><p>[TOC]</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p>
<p><strong>本实验包括以下内容</strong>：</p>
<ol>
<li>列表<ul>
<li>列表的定义</li>
<li>列表的创建</li>
<li>向列表中添加元素</li>
<li>删除列表中的元素</li>
<li>获取列表中的元素</li>
<li>列表的常用操作符</li>
<li>列表的其他方法</li>
</ul>
</li>
<li>元组<ul>
<li>创建和访问一个元组</li>
<li>更新和删除一个元组</li>
<li>元组相关的操作符</li>
<li>内置方法</li>
<li>解压元组</li>
</ul>
</li>
<li>字符串<ul>
<li>字符串的定义</li>
<li>字符串的切片与拼接</li>
<li>字符串的常用内置方法</li>
<li>字符串格式化</li>
</ul>
</li>
<li>字典<ul>
<li>可变类型与不可变类型</li>
<li>字典的定义</li>
<li>创建和访问字典</li>
<li>字典的内置方法</li>
</ul>
</li>
<li>集合<ul>
<li>集合的创建</li>
<li>访问集合中的值</li>
<li>集合的内置方法</li>
<li>集合的转换</li>
<li>不可变集合</li>
</ul>
</li>
<li>序列<ul>
<li>针对序列的内置函数</li>
</ul>
</li>
</ol>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>简单数据类型</p>
<ul>
<li>整型<code>&lt;class &#39;int&#39;&gt;</code></li>
<li>浮点型<code>&lt;class &#39;float&#39;&gt;</code></li>
<li>布尔型<code>&lt;class &#39;bool&#39;&gt;</code></li>
</ul>
<p>容器数据类型</p>
<ul>
<li>列表<code>&lt;class &#39;list&#39;&gt;</code></li>
<li>元组<code>&lt;class &#39;tuple&#39;&gt;</code></li>
<li>字典<code>&lt;class &#39;dict&#39;&gt;</code></li>
<li>集合<code>&lt;class &#39;set&#39;&gt;</code></li>
<li>字符串<code>&lt;class &#39;str&#39;&gt;</code></li>
</ul>
<h2 id="1-列表的定义"><a href="#1-列表的定义" class="headerlink" title="1. 列表的定义"></a>1. 列表的定义</h2><p>列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象，语法为 <code>[元素1, 元素2, ..., 元素n]</code>。</p>
<ul>
<li>关键点是「中括号 []」和「逗号 ,」</li>
<li>中括号 把所有元素绑在一起</li>
<li>逗号 将每个元素一一分开</li>
</ul>
<h2 id="2-列表的创建"><a href="#2-列表的创建" class="headerlink" title="2. 列表的创建"></a>2. 列表的创建</h2><ul>
<li>创建一个普通列表</li>
</ul>
<p>【例子】</p>
<p>[1]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; [2, 3, 4, 5, 6, 7]</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [2, 3, 4, 5, 6, 7] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;] &lt;class &#39;list&#39;&gt;</span><br><span class="line">hello</span><br><span class="line">[2, 3, 4, 5, 6, 7] &lt;class &#39;list&#39;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用<code>range()</code>创建列表</li>
</ul>
<p>【例子】</p>
<p>[2]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; list(range(10))</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; list(range(1, 11, 2))</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [1, 3, 5, 7, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; list(range(10, 1, -2))</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [10, 8, 6, 4, 2] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[1, 3, 5, 7, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[10, 8, 6, 4, 2] &lt;class &#39;list&#39;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用推导式创建列表</li>
</ul>
<p>【例子】</p>
<p>[3]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [0] * 5</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; [0 for i in range(5)]</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; [i for i in range(10)]</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; [i for i in range(1, 10, 2)]</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [1, 3, 5, 7, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; [i for i in range(10, 1, -2)]</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [10, 8, 6, 4, 2] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; [i ** 2 for i in range(1, 10)]</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x &#x3D; [i for i in range(100) if (i % 2) !&#x3D; 0 and (i % 3) &#x3D;&#x3D; 0]</span><br><span class="line">print(x, type(x))</span><br><span class="line"></span><br><span class="line"># [3, 9, 15, 21, 27, 33, 39,</span><br><span class="line">[0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[1, 3, 5, 7, 9] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[10, 8, 6, 4, 2] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99] &lt;class &#39;list&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的<code>[1,2,3]</code>，也有3个指针和3个整数对象。</p>
<p><code>x = [a] * 4</code>操作中，只是创建4个指向list的引用，所以一旦<code>a</code>改变，<code>x</code>中4个<code>a</code>也会随之改变。</p>
<p>【例子】</p>
<p>[4]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [[0] * 3] * 4</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x[0][0] &#x3D; 1</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">a &#x3D; [0] * 3</span><br><span class="line">x &#x3D; [a] * 4</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br><span class="line"></span><br><span class="line">x[0][0] &#x3D; 1</span><br><span class="line">print(x, type(x))</span><br><span class="line"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class &#39;list&#39;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个混合列表</li>
</ul>
<p>【例子】</p>
<p>[5]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mix &#x3D; [1, &#39;lsgo&#39;, 3.14, [1, 2, 3]]</span><br><span class="line">print(mix, type(mix))  </span><br><span class="line"># [1, &#39;lsgo&#39;, 3.14, [1, 2, 3]] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[1, &#39;lsgo&#39;, 3.14, [1, 2, 3]] &lt;class &#39;list&#39;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个空列表</li>
</ul>
<p>【例子】</p>
<p>[6]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">empty &#x3D; []</span><br><span class="line">print(empty, type(empty))  # [] &lt;class &#39;list&#39;&gt;</span><br><span class="line">[] &lt;class &#39;list&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>列表不像元组，列表内容可更改 (mutable)，因此附加 (<code>append</code>, <code>extend</code>)、插入 (<code>insert</code>)、删除 (<code>remove</code>, <code>pop</code>) 这些操作都可以用在它身上。</p>
<h2 id="3-向列表中添加元素"><a href="#3-向列表中添加元素" class="headerlink" title="3. 向列表中添加元素"></a>3. 向列表中添加元素</h2><ul>
<li><code>list.append(obj)</code> 在列表末尾添加新的对象，只接受一个参数，参数可以是任何数据类型，被追加的元素在 list 中保持着原结构类型。</li>
</ul>
<p>【例子】</p>
<p>[7]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">x.append(&#39;Thursday&#39;)</span><br><span class="line">print(x)  </span><br><span class="line"># [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Thursday&#39;]</span><br><span class="line"></span><br><span class="line">print(len(x))  # 6</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Thursday&#39;]</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意<code>append()</code>和<code>extend()</code>的区别。</p>
<p>【例子】</p>
<p>[8]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">x.append([&#39;Thursday&#39;, &#39;Sunday&#39;])</span><br><span class="line">print(x)  </span><br><span class="line"># [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, [&#39;Thursday&#39;, &#39;Sunday&#39;]]</span><br><span class="line"></span><br><span class="line">print(len(x))  # 6</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, [&#39;Thursday&#39;, &#39;Sunday&#39;]]</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<ul>
<li><code>list.extend(seq)</code> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
</ul>
<p>【例子】</p>
<p>[9]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">x.extend([&#39;Thursday&#39;, &#39;Sunday&#39;])</span><br><span class="line">print(x)  </span><br><span class="line"># [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Thursday&#39;, &#39;Sunday&#39;]</span><br><span class="line"></span><br><span class="line">print(len(x))  # 7</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Thursday&#39;, &#39;Sunday&#39;]</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>严格来说 <code>append</code> 是追加，把一个东西整体添加在列表后，而 <code>extend</code> 是扩展，把一个东西里的所有元素添加在列表后。</p>
<ul>
<li><code>list.insert(index, obj)</code> 在编号 <code>index</code> 位置插入 <code>obj</code>。</li>
</ul>
<p>【例子】</p>
<p>[10]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">x.insert(2, &#39;Sunday&#39;)</span><br><span class="line">print(x)</span><br><span class="line"># [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Sunday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line"></span><br><span class="line">print(len(x))  # 6</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Sunday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="4-删除列表中的元素"><a href="#4-删除列表中的元素" class="headerlink" title="4. 删除列表中的元素"></a>4. 删除列表中的元素</h2><ul>
<li><code>list.remove(obj)</code> 移除列表中某个值的第一个匹配项</li>
</ul>
<p>【例子】</p>
<p>[11]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">x.remove(&#39;Monday&#39;)</span><br><span class="line">print(x)  # [&#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">[&#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>list.pop([index=-1])</code> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li>
</ul>
<p>【例子】</p>
<p>[12]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">y &#x3D; x.pop()</span><br><span class="line">print(y)  # Friday</span><br><span class="line"></span><br><span class="line">y &#x3D; x.pop(0)</span><br><span class="line">print(y)  # Monday</span><br><span class="line"></span><br><span class="line">y &#x3D; x.pop(-2)</span><br><span class="line">print(y)  # Wednesday</span><br><span class="line">print(x)  # [&#39;Tuesday&#39;, &#39;Thursday&#39;]</span><br><span class="line">Friday</span><br><span class="line">Monday</span><br><span class="line">Wednesday</span><br><span class="line">[&#39;Tuesday&#39;, &#39;Thursday&#39;]</span><br></pre></td></tr></table></figure>

<p><code>remove</code> 和 <code>pop</code> 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引。</p>
<ul>
<li><code>del var1[, var2 ……]</code> 删除单个或多个对象。</li>
</ul>
<p>【例子】</p>
<p>如果知道要删除的元素在列表中的位置，可使用<code>del</code>语句。</p>
<p>[13]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">del x[0:2]</span><br><span class="line">print(x)  # [&#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">[&#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br></pre></td></tr></table></figure>

<p>如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句；如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。</p>
<h2 id="5-获取列表中的元素"><a href="#5-获取列表中的元素" class="headerlink" title="5. 获取列表中的元素"></a>5. 获取列表中的元素</h2><ul>
<li>通过元素的索引值，从列表获取单个元素，注意，列表索引值是从0开始的。</li>
<li>通过将索引指定为-1，可让Python返回最后一个列表元素，索引 -2 返回倒数第二个列表元素，以此类推。</li>
</ul>
<p>【例子】</p>
<p>[14]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, [&#39;Thursday&#39;, &#39;Friday&#39;]]</span><br><span class="line">print(x[0], type(x[0]))  # Monday &lt;class &#39;str&#39;&gt;</span><br><span class="line">print(x[-1], type(x[-1]))  # [&#39;Thursday&#39;, &#39;Friday&#39;] &lt;class &#39;list&#39;&gt;</span><br><span class="line">print(x[-2], type(x[-2]))  # Wednesday &lt;class &#39;str&#39;&gt;</span><br><span class="line">Monday &lt;class &#39;str&#39;&gt;</span><br><span class="line">[&#39;Thursday&#39;, &#39;Friday&#39;] &lt;class &#39;list&#39;&gt;</span><br><span class="line">Wednesday &lt;class &#39;str&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>切片的通用写法是 <code>start : stop : step</code></p>
<ul>
<li>情况 1 - “start :”</li>
<li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往列表尾部切片。</li>
</ul>
<p>【例子】</p>
<p>[15]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">print(x[3:])  # [&#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">print(x[-3:])  # [&#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">[&#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">[&#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li>情况 2 - “: stop”</li>
<li>以 <code>step</code> 为 1 (默认) 从列表头部往编号 <code>stop</code> 切片。</li>
</ul>
<p>【例子】</p>
<p>[16]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">week &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">print(week[:3])  # [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;]</span><br><span class="line">print(week[:-3])  # [&#39;Monday&#39;, &#39;Tuesday&#39;]</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;]</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li>情况 3 - “start : stop”</li>
<li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往编号 <code>stop</code> 切片。</li>
</ul>
<p>【例子】</p>
<p>[17]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">week &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">print(week[1:3])  # [&#39;Tuesday&#39;, &#39;Wednesday&#39;]</span><br><span class="line">print(week[-3:-1])  # [&#39;Wednesday&#39;, &#39;Thursday&#39;]</span><br><span class="line">[&#39;Tuesday&#39;, &#39;Wednesday&#39;]</span><br><span class="line">[&#39;Wednesday&#39;, &#39;Thursday&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li>情况 4 - “start : stop : step”</li>
<li>以具体的 <code>step</code> 从编号 <code>start</code> 往编号 <code>stop</code> 切片。注意最后把 <code>step</code> 设为 -1，相当于将列表反向排列。</li>
</ul>
<p>【例子】</p>
<p>[18]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">week &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">print(week[1:4:2])  # [&#39;Tuesday&#39;, &#39;Thursday&#39;]</span><br><span class="line">print(week[:4:2])  # [&#39;Monday&#39;, &#39;Wednesday&#39;]</span><br><span class="line">print(week[1::2])  # [&#39;Tuesday&#39;, &#39;Thursday&#39;]</span><br><span class="line">print(week[::-1])  </span><br><span class="line"># [&#39;Friday&#39;, &#39;Thursday&#39;, &#39;Wednesday&#39;, &#39;Tuesday&#39;, &#39;Monday&#39;]</span><br><span class="line">[&#39;Tuesday&#39;, &#39;Thursday&#39;]</span><br><span class="line">[&#39;Monday&#39;, &#39;Wednesday&#39;]</span><br><span class="line">[&#39;Tuesday&#39;, &#39;Thursday&#39;]</span><br><span class="line">[&#39;Friday&#39;, &#39;Thursday&#39;, &#39;Wednesday&#39;, &#39;Tuesday&#39;, &#39;Monday&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li>情况 5 - “ : “</li>
<li>复制列表中的所有元素（浅拷贝）。</li>
</ul>
<p>【例子】</p>
<p>[19]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eek &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">print(week[:])  </span><br><span class="line"># [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br><span class="line">[&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]</span><br></pre></td></tr></table></figure>

<p>【例子】浅拷贝与深拷贝</p>
<p>[20]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [123, 456, 789, 213]</span><br><span class="line">list2 &#x3D; list1</span><br><span class="line">list3 &#x3D; list1[:]</span><br><span class="line"></span><br><span class="line">print(list2)  # [123, 456, 789, 213]</span><br><span class="line">print(list3)  # [123, 456, 789, 213]</span><br><span class="line">list1.sort()</span><br><span class="line">print(list2)  # [123, 213, 456, 789] </span><br><span class="line">print(list3)  # [123, 456, 789, 213]</span><br><span class="line"></span><br><span class="line">list1 &#x3D; [[123, 456], [789, 213]]</span><br><span class="line">list2 &#x3D; list1</span><br><span class="line">list3 &#x3D; list1[:]</span><br><span class="line">print(list2)  # [[123, 456], [789, 213]]</span><br><span class="line">print(list3)  # [[123, 456], [789, 213]]</span><br><span class="line">list1[0][0] &#x3D; 111</span><br><span class="line">print(list2)  # [[111, 456], [789, 213]]</span><br><span class="line">print(list3)  # [[111, 456], [789, 213]]</span><br><span class="line">[123, 456, 789, 213]</span><br><span class="line">[123, 456, 789, 213]</span><br><span class="line">[123, 213, 456, 789]</span><br><span class="line">[123, 456, 789, 213]</span><br><span class="line">[[123, 456], [789, 213]]</span><br><span class="line">[[123, 456], [789, 213]]</span><br><span class="line">[[111, 456], [789, 213]]</span><br><span class="line">[[111, 456], [789, 213]]</span><br></pre></td></tr></table></figure>

<h2 id="6-列表的常用操作符"><a href="#6-列表的常用操作符" class="headerlink" title="6. 列表的常用操作符"></a>6. 列表的常用操作符</h2><ul>
<li>等号操作符：<code>==</code></li>
<li>连接操作符 <code>+</code></li>
<li>重复操作符 <code>*</code></li>
<li>成员关系操作符 <code>in</code>、<code>not in</code></li>
</ul>
<p>「等号 ==」，只有成员、成员位置都相同时才返回True。</p>
<p>列表拼接有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p>
<p>【例子】</p>
<p>[21]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [123, 456]</span><br><span class="line">list2 &#x3D; [456, 123]</span><br><span class="line">list3 &#x3D; [123, 456]</span><br><span class="line"></span><br><span class="line">print(list1 &#x3D;&#x3D; list2)  # False</span><br><span class="line">print(list1 &#x3D;&#x3D; list3)  # True</span><br><span class="line"></span><br><span class="line">list4 &#x3D; list1 + list2  # extend()</span><br><span class="line">print(list4)  # [123, 456, 456, 123]</span><br><span class="line"></span><br><span class="line">list5 &#x3D; list3 * 3</span><br><span class="line">print(list5)  # [123, 456, 123, 456, 123, 456]</span><br><span class="line"></span><br><span class="line">list3 *&#x3D; 3</span><br><span class="line">print(list3)  # [123, 456, 123, 456, 123, 456]</span><br><span class="line"></span><br><span class="line">print(123 in list3)  # True</span><br><span class="line">print(456 not in list3)  # False</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">[123, 456, 456, 123]</span><br><span class="line">[123, 456, 123, 456, 123, 456]</span><br><span class="line">[123, 456, 123, 456, 123, 456]</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>前面三种方法（<code>append</code>, <code>extend</code>, <code>insert</code>）可对列表增加元素，它们没有返回值，是直接修改了原数据对象。 而将两个list相加，需要创建新的 list 对象，从而需要消耗额外的内存，特别是当 list 较大时，尽量不要使用 “+” 来添加list。</p>
<h2 id="7-列表的其它方法"><a href="#7-列表的其它方法" class="headerlink" title="7. 列表的其它方法"></a>7. 列表的其它方法</h2><p><code>list.count(obj)</code> 统计某个元素在列表中出现的次数</p>
<p>【例子】</p>
<p>[22]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [123, 456] * 3</span><br><span class="line">print(list1)  # [123, 456, 123, 456, 123, 456]</span><br><span class="line">num &#x3D; list1.count(123)</span><br><span class="line">print(num)  # 3</span><br><span class="line">[123, 456, 123, 456, 123, 456]</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><code>list.index(x[, start[, end]])</code> 从列表中找出某个值第一个匹配项的索引位置</p>
<p>【例子】</p>
<p>[23]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 &#x3D; [123, 456] * 5</span><br><span class="line">print(list1.index(123))  # 0</span><br><span class="line">print(list1.index(123, 1))  # 2</span><br><span class="line">print(list1.index(123, 3, 7))  # 4</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><code>list.reverse()</code> 反向列表中元素</p>
<p>【例子】</p>
<p>[24]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [123, 456, 789]</span><br><span class="line">x.reverse()</span><br><span class="line">print(x)  # [789, 456, 123]</span><br><span class="line">[789, 456, 123]</span><br></pre></td></tr></table></figure>

<p><code>list.sort(key=None, reverse=False)</code> 对原列表进行排序。</p>
<ul>
<li><code>key</code> – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li><code>reverse</code> – 排序规则，<code>reverse = True</code> 降序， <code>reverse = False</code> 升序（默认）。</li>
<li>该方法没有返回值，但是会对列表的对象进行排序。</li>
</ul>
<p>【例子】</p>
<p>[25]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [123, 456, 789, 213]</span><br><span class="line">x.sort()</span><br><span class="line">print(x)</span><br><span class="line"># [123, 213, 456, 789]</span><br><span class="line"></span><br><span class="line">x.sort(reverse&#x3D;True)</span><br><span class="line">print(x)</span><br><span class="line"># [789, 456, 213, 123]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取列表的第二个元素</span><br><span class="line">def takeSecond(elem):</span><br><span class="line">    return elem[1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x &#x3D; [(2, 2), (3, 4), (4, 1), (1, 3)]</span><br><span class="line">x.sort(key&#x3D;takeSecond)</span><br><span class="line">print(x)</span><br><span class="line"># [(4, 1), (2, 2), (1, 3), (3, 4)]</span><br><span class="line"></span><br><span class="line">x.sort(key&#x3D;lambda a: a[0])</span><br><span class="line">print(x)</span><br><span class="line"># [(1, 3), (2, 2), (3, 4), (4, 1)]</span><br><span class="line">[123, 213, 456, 789]</span><br><span class="line">[789, 456, 213, 123]</span><br><span class="line">[(4, 1), (2, 2), (1, 3), (3, 4)]</span><br><span class="line">[(1, 3), (2, 2), (3, 4), (4, 1)]</span><br></pre></td></tr></table></figure>

<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>「元组」定义语法为：<code>(元素1, 元素2, ..., 元素n)</code></p>
<ul>
<li>小括号把所有元素绑在一起</li>
<li>逗号将每个元素一一分开</li>
</ul>
<h2 id="1-创建和访问一个元组"><a href="#1-创建和访问一个元组" class="headerlink" title="1. 创建和访问一个元组"></a>1. 创建和访问一个元组</h2><ul>
<li>Python 的元组与列表类似，不同之处在于tuple被创建后就不能对其进行修改，类似字符串。</li>
<li>元组使用小括号，列表使用方括号。</li>
<li>元组与列表类似，也用整数来对它进行索引 (indexing) 和切片 (slicing)。</li>
</ul>
<p>【例子】</p>
<p>[26]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 &#x3D; (1, 10.31, &#39;python&#39;)</span><br><span class="line">t2 &#x3D; 1, 10.31, &#39;python&#39;</span><br><span class="line">print(t1, type(t1))</span><br><span class="line"># (1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;</span><br><span class="line"></span><br><span class="line">print(t2, type(t2))</span><br><span class="line"># (1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;</span><br><span class="line"></span><br><span class="line">tuple1 &#x3D; (1, 2, 3, 4, 5, 6, 7, 8)</span><br><span class="line">print(tuple1[1])  # 2</span><br><span class="line">print(tuple1[5:])  # (6, 7, 8)</span><br><span class="line">print(tuple1[:5])  # (1, 2, 3, 4, 5)</span><br><span class="line">tuple2 &#x3D; tuple1[:]</span><br><span class="line">print(tuple2)  # (1, 2, 3, 4, 5, 6, 7, 8)</span><br><span class="line">(1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;</span><br><span class="line">(1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;</span><br><span class="line">2</span><br><span class="line">(6, 7, 8)</span><br><span class="line">(1, 2, 3, 4, 5)</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, 8)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建元组可以用小括号 ()，也可以什么都不用，为了可读性，建议还是用 ()。</li>
<li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。</li>
</ul>
<p>【例子】</p>
<p>[27]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; (1)</span><br><span class="line">print(type(x))  # &lt;class &#39;int&#39;&gt;</span><br><span class="line">x &#x3D; 2, 3, 4, 5</span><br><span class="line">print(type(x))  # &lt;class &#39;tuple&#39;&gt;</span><br><span class="line">x &#x3D; []</span><br><span class="line">print(type(x))  # &lt;class &#39;list&#39;&gt;</span><br><span class="line">x &#x3D; ()</span><br><span class="line">print(type(x))  # &lt;class &#39;tuple&#39;&gt;</span><br><span class="line">x &#x3D; (1,)</span><br><span class="line">print(type(x))  # &lt;class &#39;tuple&#39;&gt;</span><br><span class="line">&lt;class &#39;int&#39;&gt;</span><br><span class="line">&lt;class &#39;tuple&#39;&gt;</span><br><span class="line">&lt;class &#39;list&#39;&gt;</span><br><span class="line">&lt;class &#39;tuple&#39;&gt;</span><br><span class="line">&lt;class &#39;tuple&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[28]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(8 * (8))  # 64</span><br><span class="line">print(8 * (8,))  # (8, 8, 8, 8, 8, 8, 8, 8)</span><br><span class="line">64</span><br><span class="line">(8, 8, 8, 8, 8, 8, 8, 8)</span><br></pre></td></tr></table></figure>

<p>【例子】创建二维元组。</p>
<p>[29]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; (1, 10.31, &#39;python&#39;), (&#39;data&#39;, 11)</span><br><span class="line">print(x)</span><br><span class="line"># ((1, 10.31, &#39;python&#39;), (&#39;data&#39;, 11))</span><br><span class="line"></span><br><span class="line">print(x[0])</span><br><span class="line"># (1, 10.31, &#39;python&#39;)</span><br><span class="line">print(x[0][0], x[0][1], x[0][2])</span><br><span class="line"># 1 10.31 python</span><br><span class="line"></span><br><span class="line">print(x[0][0:2])</span><br><span class="line"># (1, 10.31)</span><br><span class="line">((1, 10.31, &#39;python&#39;), (&#39;data&#39;, 11))</span><br><span class="line">(1, 10.31, &#39;python&#39;)</span><br><span class="line">1 10.31 python</span><br><span class="line">(1, 10.31)</span><br></pre></td></tr></table></figure>

<h2 id="2-更新和删除一个元组"><a href="#2-更新和删除一个元组" class="headerlink" title="2. 更新和删除一个元组"></a>2. 更新和删除一个元组</h2><p>【例子】</p>
<p>[30]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">week &#x3D; (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)</span><br><span class="line">week &#x3D; week[:2] + (&#39;Wednesday&#39;,) + week[2:]</span><br><span class="line">print(week)  # (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)</span><br><span class="line">(&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)</span><br></pre></td></tr></table></figure>

<p>【例子】元组有不可更改 (immutable) 的性质，因此不能直接给元组的元素赋值，但是只要元组中的元素可更改 (mutable)，那么我们可以直接更改其元素，注意这跟赋值其元素不同。</p>
<p>[31]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 &#x3D; (1, 2, 3, [4, 5, 6])</span><br><span class="line">print(t1)  # (1, 2, 3, [4, 5, 6])</span><br><span class="line"></span><br><span class="line">t1[3][0] &#x3D; 9</span><br><span class="line">print(t1)  # (1, 2, 3, [9, 5, 6])</span><br><span class="line">(1, 2, 3, [4, 5, 6])</span><br><span class="line">(1, 2, 3, [9, 5, 6])</span><br></pre></td></tr></table></figure>

<h2 id="3-元组相关的操作符"><a href="#3-元组相关的操作符" class="headerlink" title="3. 元组相关的操作符"></a>3. 元组相关的操作符</h2><ul>
<li>等号操作符：<code>==</code></li>
<li>连接操作符 <code>+</code></li>
<li>重复操作符 <code>*</code></li>
<li>成员关系操作符 <code>in</code>、<code>not in</code></li>
</ul>
<p>「等号 ==」，只有成员、成员位置都相同时才返回True。</p>
<p>元组拼接有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p>
<p>【例子】</p>
<p>[32]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 &#x3D; (123, 456)</span><br><span class="line">t2 &#x3D; (456, 123)</span><br><span class="line">t3 &#x3D; (123, 456)</span><br><span class="line"></span><br><span class="line">print(t1 &#x3D;&#x3D; t2)  # False</span><br><span class="line">print(t1 &#x3D;&#x3D; t3)  # True</span><br><span class="line"></span><br><span class="line">t4 &#x3D; t1 + t2</span><br><span class="line">print(t4)  # (123, 456, 456, 123)</span><br><span class="line"></span><br><span class="line">t5 &#x3D; t3 * 3</span><br><span class="line">print(t5)  # (123, 456, 123, 456, 123, 456)</span><br><span class="line"></span><br><span class="line">t3 *&#x3D; 3</span><br><span class="line">print(t3)  # (123, 456, 123, 456, 123, 456)</span><br><span class="line"></span><br><span class="line">print(123 in t3)  # True</span><br><span class="line">print(456 not in t3)  # False</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">(123, 456, 456, 123)</span><br><span class="line">(123, 456, 123, 456, 123, 456)</span><br><span class="line">(123, 456, 123, 456, 123, 456)</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h2 id="4-内置方法"><a href="#4-内置方法" class="headerlink" title="4. 内置方法"></a>4. 内置方法</h2><p>元组大小和内容都不可更改，因此只有 <code>count</code> 和 <code>index</code> 两种方法。</p>
<p>【例子】</p>
<p>[33]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 10.31, &#39;python&#39;)</span><br><span class="line">print(t.count(&#39;python&#39;))  # 1</span><br><span class="line">print(t.index(10.31))  # 1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>count(&#39;python&#39;)</code> 是记录在元组 <code>t</code> 中该元素出现几次，显然是 1 次</li>
<li><code>index(10.31)</code> 是找到该元素在元组 <code>t</code> 的索引，显然是 1</li>
</ul>
<h2 id="5-解压元组"><a href="#5-解压元组" class="headerlink" title="5. 解压元组"></a>5. 解压元组</h2><p>【例子】解压（unpack）一维元组（有几个元素左边括号定义几个变量）</p>
<p>[34]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 10.31, &#39;python&#39;)</span><br><span class="line">(a, b, c) &#x3D; t</span><br><span class="line">print(a, b, c)</span><br><span class="line"># 1 10.31 python</span><br><span class="line">1 10.31 python</span><br></pre></td></tr></table></figure>

<p>【例子】解压二维元组（按照元组里的元组结构来定义变量）</p>
<p>[35]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 10.31, (&#39;OK&#39;, &#39;python&#39;))</span><br><span class="line">(a, b, (c, d)) &#x3D; t</span><br><span class="line">print(a, b, c, d)</span><br><span class="line"># 1 10.31 OK python</span><br><span class="line">1 10.31 OK python</span><br></pre></td></tr></table></figure>

<p>【例子】如果你只想要元组其中几个元素，用通配符「*」，英文叫 wildcard，在计算机语言中代表一个或多个元素。下例就是把多个元素丢给了 <code>rest</code> 变量。</p>
<p>[36]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; 1, 2, 3, 4, 5</span><br><span class="line">a, b, *rest, c &#x3D; t</span><br><span class="line">print(a, b, c)  # 1 2 5</span><br><span class="line">print(rest)  # [3, 4]</span><br><span class="line">1 2 5</span><br><span class="line">[3, 4]</span><br></pre></td></tr></table></figure>

<p>【例子】如果你根本不在乎 rest 变量，那么就用通配符「*」加上下划线「_」。</p>
<p>[37]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; 1, 2, 3, 4, 5</span><br><span class="line">a, b, *_ &#x3D; t</span><br><span class="line">print(a, b)  # 1 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1-字符串的定义"><a href="#1-字符串的定义" class="headerlink" title="1. 字符串的定义"></a>1. 字符串的定义</h2><ul>
<li>Python 中字符串被定义为引号之间的字符集合。</li>
<li>Python 支持使用成对的 单引号 或 双引号。</li>
</ul>
<p>【例子】</p>
<p>[38]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 &#x3D; &#39;i love Python!&#39;</span><br><span class="line">print(t1, type(t1))</span><br><span class="line"># i love Python! &lt;class &#39;str&#39;&gt;</span><br><span class="line"></span><br><span class="line">t2 &#x3D; &quot;I love Python!&quot;</span><br><span class="line">print(t2, type(t2))</span><br><span class="line"># I love Python! &lt;class &#39;str&#39;&gt;</span><br><span class="line"></span><br><span class="line">print(5 + 8)  # 13</span><br><span class="line">print(&#39;5&#39; + &#39;8&#39;)  # 58</span><br><span class="line">i love Python! &lt;class &#39;str&#39;&gt;</span><br><span class="line">I love Python! &lt;class &#39;str&#39;&gt;</span><br><span class="line">13</span><br><span class="line">58</span><br></pre></td></tr></table></figure>

<ul>
<li>Python 的常用转义字符</li>
</ul>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\\</code></td>
<td>反斜杠符号</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>横向制表符(TAB)</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
</tr>
</tbody></table>
<p>【例子】如果字符串中需要出现单引号或双引号，可以使用转义符号<code>\</code>对字符串中的符号进行转义。</p>
<p>[39]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;let\&#39;s go&#39;)  # let&#39;s go</span><br><span class="line">print(&quot;let&#39;s go&quot;)  # let&#39;s go</span><br><span class="line">print(&#39;C:\\now&#39;)  # C:\now</span><br><span class="line">print(&quot;C:\\Program Files\\Intel\\Wifi\\Help&quot;)</span><br><span class="line"># C:\Program Files\Intel\Wifi\Help</span><br><span class="line">let&#39;s go</span><br><span class="line">let&#39;s go</span><br><span class="line">C:\now</span><br><span class="line">C:\Program Files\Intel\Wifi\Help</span><br></pre></td></tr></table></figure>

<p>【例子】原始字符串只需要在字符串前边加一个英文字母 r 即可。</p>
<p>[40]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(r&#39;C:\Program Files\Intel\Wifi\Help&#39;)  </span><br><span class="line"># C:\Program Files\Intel\Wifi\Help</span><br><span class="line">C:\Program Files\Intel\Wifi\Help</span><br></pre></td></tr></table></figure>

<p>【例子】三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。</p>
<p>[41]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">para_str &#x3D; &quot;&quot;&quot;这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line">TAB ( \t )。</span><br><span class="line">也可以使用换行符 [ \n ]。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(para_str)</span><br><span class="line"># 这是一个多行字符串的实例</span><br><span class="line"># 多行字符串可以使用制表符</span><br><span class="line"># TAB (    )。</span><br><span class="line"># 也可以使用换行符 [</span><br><span class="line">#  ]。</span><br><span class="line"></span><br><span class="line">para_str &#x3D; &#39;&#39;&#39;这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line">TAB ( \t )。</span><br><span class="line">也可以使用换行符 [ \n ]。</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">print(para_str)</span><br><span class="line"># 这是一个多行字符串的实例</span><br><span class="line"># 多行字符串可以使用制表符</span><br><span class="line"># TAB (      )。</span><br><span class="line"># 也可以使用换行符 [ </span><br><span class="line">#  ]。</span><br><span class="line">这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line">TAB ( 	 )。</span><br><span class="line">也可以使用换行符 [ </span><br><span class="line"> ]。</span><br><span class="line"></span><br><span class="line">这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line">TAB ( 	 )。</span><br><span class="line">也可以使用换行符 [ </span><br><span class="line"> ]。</span><br></pre></td></tr></table></figure>

<h2 id="2-字符串的切片与拼接"><a href="#2-字符串的切片与拼接" class="headerlink" title="2. 字符串的切片与拼接"></a>2. 字符串的切片与拼接</h2><ul>
<li>类似于元组具有不可修改性</li>
<li>从 0 开始 (和 Java 一样)</li>
<li>切片通常写成 <code>start:end</code> 这种形式，包括「<code>start</code> 索引」对应的元素，不包括「<code>end</code>索引」对应的元素。</li>
<li>索引值可正可负，正索引从 0 开始，从左往右；负索引从 -1 开始，从右往左。使用负数索引时，会从最后一个元素开始计数。最后一个元素的位置编号是 -1。</li>
</ul>
<p>【例子】</p>
<p>[42]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 &#x3D; &#39;I Love LsgoGroup&#39;</span><br><span class="line">print(str1[:6])  # I Love</span><br><span class="line">print(str1[5])  # e</span><br><span class="line">print(str1[:6] + &quot; 插入的字符串 &quot; + str1[6:])  </span><br><span class="line"># I Love 插入的字符串  LsgoGroup</span><br><span class="line"></span><br><span class="line">s &#x3D; &#39;Python&#39;</span><br><span class="line">print(s)  # Python</span><br><span class="line">print(s[2:4])  # th</span><br><span class="line">print(s[-5:-2])  # yth</span><br><span class="line">print(s[2])  # t</span><br><span class="line">print(s[-1])  # n</span><br><span class="line">I Love</span><br><span class="line">e</span><br><span class="line">I Love 插入的字符串  LsgoGroup</span><br><span class="line">Python</span><br><span class="line">th</span><br><span class="line">yth</span><br><span class="line">t</span><br><span class="line">n</span><br></pre></td></tr></table></figure>

<h2 id="3-字符串的常用内置方法"><a href="#3-字符串的常用内置方法" class="headerlink" title="3. 字符串的常用内置方法"></a>3. 字符串的常用内置方法</h2><ul>
<li><code>capitalize()</code> 将字符串的第一个字符转换为大写。</li>
</ul>
<p>【例子】</p>
<p>[43]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str2 &#x3D; &#39;xiaoxie&#39;</span><br><span class="line">print(str2.capitalize())  # Xiaoxie</span><br><span class="line">Xiaoxie</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lower()</code> 转换字符串中所有大写字符为小写。</li>
<li><code>upper()</code> 转换字符串中的小写字母为大写。</li>
<li><code>swapcase()</code> 将字符串中大写转换为小写，小写转换为大写。</li>
</ul>
<p>【例子】</p>
<p>[44]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str2 &#x3D; &quot;DAXIExiaoxie&quot;</span><br><span class="line">print(str2.lower())  # daxiexiaoxie</span><br><span class="line">print(str2.upper())  # DAXIEXIAOXIE</span><br><span class="line">print(str2.swapcase())  # daxieXIAOXIE</span><br><span class="line">daxiexiaoxie</span><br><span class="line">DAXIEXIAOXIE</span><br><span class="line">daxieXIAOXIE</span><br></pre></td></tr></table></figure>

<ul>
<li><code>count(str, beg= 0,end=len(string))</code> 返回<code>str</code>在 string 里面出现的次数，如果<code>beg</code>或者<code>end</code>指定则返回指定范围内<code>str</code>出现的次数。</li>
</ul>
<p>【例子】</p>
<p>[45]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str2 &#x3D; &quot;DAXIExiaoxie&quot;</span><br><span class="line">print(str2.count(&#39;xi&#39;))  # 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<ul>
<li><code>endswith(suffix, beg=0, end=len(string))</code> 检查字符串是否以指定子字符串 <code>suffix</code> 结束，如果是，返回 True，否则返回 False。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</li>
<li><code>startswith(substr, beg=0,end=len(string))</code> 检查字符串是否以指定子字符串 <code>substr</code> 开头，如果是，返回 True，否则返回 False。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</li>
</ul>
<p>【例子】</p>
<p>[46]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str2 &#x3D; &quot;DAXIExiaoxie&quot;</span><br><span class="line">print(str2.endswith(&#39;ie&#39;))  # True</span><br><span class="line">print(str2.endswith(&#39;xi&#39;))  # False</span><br><span class="line">print(str2.startswith(&#39;Da&#39;))  # False</span><br><span class="line">print(str2.startswith(&#39;DA&#39;))  # True</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<ul>
<li><code>find(str, beg=0, end=len(string))</code> 检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code>，则检查是否包含在指定范围内，如果包含，返回开始的索引值，否则返回 -1。</li>
<li><code>rfind(str, beg=0,end=len(string))</code> 类似于 <code>find()</code> 函数，不过是从右边开始查找。</li>
</ul>
<p>【例子】</p>
<p>[47]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str2 &#x3D; &quot;DAXIExiaoxie&quot;</span><br><span class="line">print(str2.find(&#39;xi&#39;))  # 5</span><br><span class="line">print(str2.find(&#39;ix&#39;))  # -1</span><br><span class="line">print(str2.rfind(&#39;xi&#39;))  # 9</span><br><span class="line">5</span><br><span class="line">-1</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<ul>
<li><code>isnumeric()</code> 如果字符串中只包含数字字符，则返回 True，否则返回 False。</li>
</ul>
<p>【例子】</p>
<p>[48]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str3 &#x3D; &#39;12345&#39;</span><br><span class="line">print(str3.isnumeric())  # True</span><br><span class="line">str3 +&#x3D; &#39;a&#39;</span><br><span class="line">print(str3.isnumeric())  # False</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ljust(width[, fillchar])</code>返回一个原字符串左对齐，并使用<code>fillchar</code>（默认空格）填充至长度<code>width</code>的新字符串。</li>
<li><code>rjust(width[, fillchar])</code>返回一个原字符串右对齐，并使用<code>fillchar</code>（默认空格）填充至长度<code>width</code>的新字符串。</li>
</ul>
<p>【例子】</p>
<p>[49]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str4 &#x3D; &#39;1101&#39;</span><br><span class="line">print(str4.ljust(8, &#39;0&#39;))  # 11010000</span><br><span class="line">print(str4.rjust(8, &#39;0&#39;))  # 00001101</span><br><span class="line">11010000</span><br><span class="line">00001101</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lstrip([chars])</code> 截掉字符串左边的空格或指定字符。</li>
<li><code>rstrip([chars])</code> 删除字符串末尾的空格或指定字符。</li>
<li><code>strip([chars])</code> 在字符串上执行<code>lstrip()</code>和<code>rstrip()</code>。</li>
</ul>
<p>【例子】</p>
<p>[50]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str5 &#x3D; &#39; I Love LsgoGroup &#39;</span><br><span class="line">print(str5.lstrip())  # &#39;I Love LsgoGroup &#39;</span><br><span class="line">print(str5.lstrip().strip(&#39;I&#39;))  # &#39; Love LsgoGroup &#39;</span><br><span class="line">print(str5.rstrip())  # &#39; I Love LsgoGroup&#39;</span><br><span class="line">print(str5.strip())  # &#39;I Love LsgoGroup&#39;</span><br><span class="line">print(str5.strip().strip(&#39;p&#39;))  # &#39;I Love LsgoGrou&#39;</span><br><span class="line">I Love LsgoGroup </span><br><span class="line"> Love LsgoGroup </span><br><span class="line"> I Love LsgoGroup</span><br><span class="line">I Love LsgoGroup</span><br><span class="line">I Love LsgoGrou</span><br></pre></td></tr></table></figure>

<ul>
<li><code>partition(sub)</code> 找到子字符串sub，把字符串分为一个三元组<code>(pre_sub,sub,fol_sub)</code>，如果字符串中不包含sub则返回<code>(&#39;原字符串&#39;,&#39;&#39;,&#39;&#39;)</code>。</li>
<li><code>rpartition(sub)</code>类似于<code>partition()</code>方法，不过是从右边开始查找。</li>
</ul>
<p>【例子】</p>
<p>[51]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str5 &#x3D; &#39; I Love LsgoGroup &#39;</span><br><span class="line">print(str5.strip().partition(&#39;o&#39;))  # (&#39;I L&#39;, &#39;o&#39;, &#39;ve LsgoGroup&#39;)</span><br><span class="line">print(str5.strip().partition(&#39;m&#39;))  # (&#39;I Love LsgoGroup&#39;, &#39;&#39;, &#39;&#39;)</span><br><span class="line">print(str5.strip().rpartition(&#39;o&#39;))  # (&#39;I Love LsgoGr&#39;, &#39;o&#39;, &#39;up&#39;)</span><br><span class="line">(&#39;I L&#39;, &#39;o&#39;, &#39;ve LsgoGroup&#39;)</span><br><span class="line">(&#39;I Love LsgoGroup&#39;, &#39;&#39;, &#39;&#39;)</span><br><span class="line">(&#39;I Love LsgoGr&#39;, &#39;o&#39;, &#39;up&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>replace(old, new [, max])</code> 把 将字符串中的<code>old</code>替换成<code>new</code>，如果<code>max</code>指定，则替换不超过<code>max</code>次。</li>
</ul>
<p>【例子】</p>
<p>[52]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str5 &#x3D; &#39; I Love LsgoGroup &#39;</span><br><span class="line">print(str5.strip().replace(&#39;I&#39;, &#39;We&#39;))  # We Love LsgoGroup</span><br><span class="line">We Love LsgoGroup</span><br></pre></td></tr></table></figure>

<ul>
<li><code>split(str=&quot;&quot;, num)</code> 不带参数默认是以空格为分隔符切片字符串，如果<code>num</code>参数有设置，则仅分隔<code>num</code>个子字符串，返回切片后的子字符串拼接的列表。</li>
</ul>
<p>【例子】</p>
<p>[53]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str5 &#x3D; &#39; I Love LsgoGroup &#39;</span><br><span class="line">print(str5.strip().split())  # [&#39;I&#39;, &#39;Love&#39;, &#39;LsgoGroup&#39;]</span><br><span class="line">print(str5.strip().split(&#39;o&#39;))  # [&#39;I L&#39;, &#39;ve Lsg&#39;, &#39;Gr&#39;, &#39;up&#39;]</span><br><span class="line">[&#39;I&#39;, &#39;Love&#39;, &#39;LsgoGroup&#39;]</span><br><span class="line">[&#39;I L&#39;, &#39;ve Lsg&#39;, &#39;Gr&#39;, &#39;up&#39;]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[54]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u &#x3D; &quot;www.baidu.com.cn&quot;</span><br><span class="line"># 使用默认分隔符</span><br><span class="line">print(u.split())  # [&#39;www.baidu.com.cn&#39;]</span><br><span class="line"></span><br><span class="line"># 以&quot;.&quot;为分隔符</span><br><span class="line">print((u.split(&#39;.&#39;)))  # [&#39;www&#39;, &#39;baidu&#39;, &#39;com&#39;, &#39;cn&#39;]</span><br><span class="line"></span><br><span class="line"># 分割0次</span><br><span class="line">print((u.split(&quot;.&quot;, 0)))  # [&#39;www.baidu.com.cn&#39;]</span><br><span class="line"></span><br><span class="line"># 分割一次</span><br><span class="line">print((u.split(&quot;.&quot;, 1)))  # [&#39;www&#39;, &#39;baidu.com.cn&#39;]</span><br><span class="line"></span><br><span class="line"># 分割两次</span><br><span class="line">print(u.split(&quot;.&quot;, 2))  # [&#39;www&#39;, &#39;baidu&#39;, &#39;com.cn&#39;]</span><br><span class="line"></span><br><span class="line"># 分割两次，并取序列为1的项</span><br><span class="line">print((u.split(&quot;.&quot;, 2)[1]))  # baidu</span><br><span class="line"></span><br><span class="line"># 分割两次，并把分割后的三个部分保存到三个变量</span><br><span class="line">u1, u2, u3 &#x3D; u.split(&quot;.&quot;, 2)</span><br><span class="line">print(u1)  # www</span><br><span class="line">print(u2)  # baidu</span><br><span class="line">print(u3)  # com.cn</span><br><span class="line">[&#39;www.baidu.com.cn&#39;]</span><br><span class="line">[&#39;www&#39;, &#39;baidu&#39;, &#39;com&#39;, &#39;cn&#39;]</span><br><span class="line">[&#39;www.baidu.com.cn&#39;]</span><br><span class="line">[&#39;www&#39;, &#39;baidu.com.cn&#39;]</span><br><span class="line">[&#39;www&#39;, &#39;baidu&#39;, &#39;com.cn&#39;]</span><br><span class="line">baidu</span><br><span class="line">www</span><br><span class="line">baidu</span><br><span class="line">com.cn</span><br></pre></td></tr></table></figure>

<p>【例子】去掉换行符</p>
<p>[55]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c &#x3D; &#39;&#39;&#39;say</span><br><span class="line">hello</span><br><span class="line">baby&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line"># say</span><br><span class="line"># hello</span><br><span class="line"># baby</span><br><span class="line"></span><br><span class="line">print(c.split(&#39;\n&#39;))  # [&#39;say&#39;, &#39;hello&#39;, &#39;baby&#39;]</span><br><span class="line">say</span><br><span class="line">hello</span><br><span class="line">baby</span><br><span class="line">[&#39;say&#39;, &#39;hello&#39;, &#39;baby&#39;]</span><br></pre></td></tr></table></figure>

<p>【例子】</p>
<p>[56]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string &#x3D; &quot;hello boy&lt;[www.baidu.com]&gt;byebye&quot;</span><br><span class="line">print(string.split(&#39;[&#39;)[1].split(&#39;]&#39;)[0])  # www.baidu.com</span><br><span class="line">print(string.split(&#39;[&#39;)[1].split(&#39;]&#39;)[0].split(&#39;.&#39;))  # [&#39;www&#39;, &#39;baidu&#39;, &#39;com&#39;]</span><br><span class="line">www.baidu.com</span><br><span class="line">[&#39;www&#39;, &#39;baidu&#39;, &#39;com&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>splitlines([keepends])</code> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数<code>keepends</code>为 False，不包含换行符，如果为 True，则保留换行符。</li>
</ul>
<p>【例子】</p>
<p>[57]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str6 &#x3D; &#39;I \n Love \n LsgoGroup&#39;</span><br><span class="line">print(str6.splitlines())  # [&#39;I &#39;, &#39; Love &#39;, &#39; LsgoGroup&#39;]</span><br><span class="line">print(str6.splitlines(True))  # [&#39;I \n&#39;, &#39; Love \n&#39;, &#39; LsgoGroup&#39;]</span><br><span class="line">[&#39;I &#39;, &#39; Love &#39;, &#39; LsgoGroup&#39;]</span><br><span class="line">[&#39;I \n&#39;, &#39; Love \n&#39;, &#39; LsgoGroup&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>maketrans(intab, outtab)</code> 创建字符映射的转换表，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</li>
<li><code>translate(table, deletechars=&quot;&quot;)</code> 根据参数<code>table</code>给出的表，转换字符串的字符，要过滤掉的字符放到<code>deletechars</code>参数中。</li>
</ul>
<p>【例子】</p>
<p>[58]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str7 &#x3D; &#39;this is string example....wow!!!&#39;</span><br><span class="line">intab &#x3D; &#39;aeiou&#39;</span><br><span class="line">outtab &#x3D; &#39;12345&#39;</span><br><span class="line">trantab &#x3D; str7.maketrans(intab, outtab)</span><br><span class="line">print(trantab)  # &#123;97: 49, 111: 52, 117: 53, 101: 50, 105: 51&#125;</span><br><span class="line">print(str7.translate(trantab))  # th3s 3s str3ng 2x1mpl2....w4w!!!</span><br><span class="line">&#123;97: 49, 101: 50, 105: 51, 111: 52, 117: 53&#125;</span><br><span class="line">th3s 3s str3ng 2x1mpl2....w4w!!!</span><br></pre></td></tr></table></figure>

<h2 id="4-字符串格式化"><a href="#4-字符串格式化" class="headerlink" title="4. 字符串格式化"></a>4. 字符串格式化</h2><ul>
<li><code>format</code> 格式化函数</li>
</ul>
<p>【例子】</p>
<p>[59]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str8 &#x3D; &quot;&#123;0&#125; Love &#123;1&#125;&quot;.format(&#39;I&#39;, &#39;Lsgogroup&#39;)  # 位置参数</span><br><span class="line">print(str8)  # I Love Lsgogroup</span><br><span class="line"></span><br><span class="line">str8 &#x3D; &quot;&#123;a&#125; Love &#123;b&#125;&quot;.format(a&#x3D;&#39;I&#39;, b&#x3D;&#39;Lsgogroup&#39;)  # 关键字参数</span><br><span class="line">print(str8)  # I Love Lsgogroup</span><br><span class="line"></span><br><span class="line">str8 &#x3D; &quot;&#123;0&#125; Love &#123;b&#125;&quot;.format(&#39;I&#39;, b&#x3D;&#39;Lsgogroup&#39;)  # 位置参数要在关键字参数之前</span><br><span class="line">print(str8)  # I Love Lsgogroup</span><br><span class="line"></span><br><span class="line">str8 &#x3D; &#39;&#123;0:.2f&#125;&#123;1&#125;&#39;.format(27.658, &#39;GB&#39;)  # 保留小数点后两位</span><br><span class="line">print(str8)  # 27.66GB</span><br><span class="line">I Love Lsgogroup</span><br><span class="line">I Love Lsgogroup</span><br><span class="line">I Love Lsgogroup</span><br><span class="line">27.66GB</span><br></pre></td></tr></table></figure>

<ul>
<li>Python 字符串格式化符号</li>
</ul>
<table>
<thead>
<tr>
<th>符 号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>格式化字符及其ASCII码</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串，用str()方法处理对象</td>
</tr>
<tr>
<td>%r</td>
<td>格式化字符串，用rper()方法处理对象</td>
</tr>
<tr>
<td>%d</td>
<td>格式化整数</td>
</tr>
<tr>
<td>%o</td>
<td>格式化无符号八进制数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化无符号十六进制数</td>
</tr>
<tr>
<td>%X</td>
<td>格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td>%f</td>
<td>格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td>%e</td>
<td>用科学计数法格式化浮点数</td>
</tr>
<tr>
<td>%E</td>
<td>作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>根据值的大小决定使用%f或%e</td>
</tr>
<tr>
<td>%G</td>
<td>作用同%g，根据值的大小决定使用%f或%E</td>
</tr>
</tbody></table>
<p>【例子】</p>
<p>[60]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;%c&#39; % 97)  # a</span><br><span class="line">print(&#39;%c %c %c&#39; % (97, 98, 99))  # a b c</span><br><span class="line">print(&#39;%d + %d &#x3D; %d&#39; % (4, 5, 9))  # 4 + 5 &#x3D; 9</span><br><span class="line">print(&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10))  # 我叫 小明 今年 10 岁!</span><br><span class="line">print(&#39;%o&#39; % 10)  # 12</span><br><span class="line">print(&#39;%x&#39; % 10)  # a</span><br><span class="line">print(&#39;%X&#39; % 10)  # A</span><br><span class="line">print(&#39;%f&#39; % 27.658)  # 27.658000</span><br><span class="line">print(&#39;%e&#39; % 27.658)  # 2.765800e+01</span><br><span class="line">print(&#39;%E&#39; % 27.658)  # 2.765800E+01</span><br><span class="line">print(&#39;%g&#39; % 27.658)  # 27.658</span><br><span class="line">text &#x3D; &quot;I am %d years old.&quot; % 22</span><br><span class="line">print(&quot;I said: %s.&quot; % text)  # I said: I am 22 years old..</span><br><span class="line">print(&quot;I said: %r.&quot; % text)  # I said: &#39;I am 22 years old.&#39;</span><br><span class="line">a</span><br><span class="line">a b c</span><br><span class="line">4 + 5 &#x3D; 9</span><br><span class="line">我叫 小明 今年 10 岁!</span><br><span class="line">12</span><br><span class="line">a</span><br><span class="line">A</span><br><span class="line">27.658000</span><br><span class="line">2.765800e+01</span><br><span class="line">2.765800E+01</span><br><span class="line">27.658</span><br><span class="line">I said: I am 22 years old..</span><br><span class="line">I said: &#39;I am 22 years old.&#39;.</span><br></pre></td></tr></table></figure>

<ul>
<li>格式化操作符辅助指令</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>m.n</code></td>
<td>m 是显示的最小总宽度,n 是小数点后的位数（如果可用的话）</td>
</tr>
<tr>
<td><code>-</code></td>
<td>用作左对齐</td>
</tr>
<tr>
<td><code>+</code></td>
<td>在正数前面显示加号( + )</td>
</tr>
<tr>
<td><code>#</code></td>
<td>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td><code>0</code></td>
<td>显示的数字前面填充’0’而不是默认的空格</td>
</tr>
</tbody></table>
<p>【例子】</p>
<p>[61]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;%5.1f&#39; % 27.658)  # &#39; 27.7&#39;</span><br><span class="line">print(&#39;%.2e&#39; % 27.658)  # 2.77e+01</span><br><span class="line">print(&#39;%10d&#39; % 10)  # &#39;        10&#39;</span><br><span class="line">print(&#39;%-10d&#39; % 10)  # &#39;10        &#39;</span><br><span class="line">print(&#39;%+d&#39; % 10)  # +10</span><br><span class="line">print(&#39;%#o&#39; % 10)  # 0o12</span><br><span class="line">print(&#39;%#x&#39; % 108)  # 0x6c</span><br><span class="line">print(&#39;%010d&#39; % 5)  # 0000000005</span><br><span class="line"> 27.7</span><br><span class="line">2.77e+01</span><br><span class="line">        10</span><br><span class="line">10        </span><br><span class="line">+10</span><br><span class="line">0o12</span><br><span class="line">0x6c</span><br><span class="line">0000000005</span><br></pre></td></tr></table></figure>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-可变类型与不可变类型"><a href="#1-可变类型与不可变类型" class="headerlink" title="1. 可变类型与不可变类型"></a>1. 可变类型与不可变类型</h2><ul>
<li>序列是以连续的整数为索引，与此不同的是，字典以”关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。</li>
<li>字典是 Python 唯一的一个 映射类型，字符串、元组、列表属于序列类型。</li>
</ul>
<p>那么如何快速判断一个数据类型 <code>X</code> 是不是可变类型的呢？两种方法：</p>
<ul>
<li>麻烦方法：用 <code>id(X)</code> 函数，对 X 进行某种操作，比较操作前后的 <code>id</code>，如果不一样，则 <code>X</code> 不可变，如果一样，则 <code>X</code> 可变。</li>
<li>便捷方法：用 <code>hash(X)</code>，只要不报错，证明 <code>X</code> 可被哈希，即不可变，反过来不可被哈希，即可变。</li>
</ul>
<p>【例子】</p>
<p>[62]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 1</span><br><span class="line">print(id(i))  # 140732167000896</span><br><span class="line">i &#x3D; i + 2</span><br><span class="line">print(id(i))  # 140732167000960</span><br><span class="line"></span><br><span class="line">l &#x3D; [1, 2]</span><br><span class="line">print(id(l))  # 4300825160</span><br><span class="line">l.append(&#39;Python&#39;)</span><br><span class="line">print(id(l))  # 4300825160</span><br><span class="line">140731832701760</span><br><span class="line">140731832701824</span><br><span class="line">2131670369800</span><br><span class="line">2131670369800</span><br></pre></td></tr></table></figure>

<ul>
<li>整数 <code>i</code> 在加 1 之后的 <code>id</code> 和之前不一样，因此加完之后的这个 <code>i</code> (虽然名字没变)，但不是加之前的那个 <code>i</code> 了，因此整数是不可变类型。</li>
<li>列表 <code>l</code> 在附加 <code>&#39;Python&#39;</code> 之后的 <code>id</code> 和之前一样，因此列表是可变类型。</li>
</ul>
<p>【例子】</p>
<p>[1]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(hash(&#39;Name&#39;))  # 7047218704141848153</span><br><span class="line"></span><br><span class="line">print(hash((1, 2, &#39;Python&#39;)))  # 1704535747474881831</span><br><span class="line"></span><br><span class="line">print(hash([1, 2, &#39;Python&#39;]))</span><br><span class="line"># TypeError: unhashable type: &#39;list&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-6668157630988609386</span><br><span class="line">-1857436431894091236</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-1-6416367464f8&gt; in &lt;module&gt;()</span><br><span class="line">      3 print(hash((1, 2, &#39;Python&#39;)))  # 1704535747474881831</span><br><span class="line">      4 </span><br><span class="line">----&gt; 5 print(hash([1, 2, &#39;Python&#39;]))</span><br><span class="line">      6 # TypeError: unhashable type: &#39;list&#39;</span><br><span class="line"></span><br><span class="line">TypeError: unhashable type: &#39;list&#39;</span><br></pre></td></tr></table></figure>

<p>[ ]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(hash(&#123;1, 2, 3&#125;))</span><br><span class="line"># TypeError: unhashable type: &#39;set&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>数值、字符和元组 都能被哈希，因此它们是不可变类型。</li>
<li>列表、集合、字典不能被哈希，因此它是可变类型。</li>
</ul>
<h2 id="2-字典的定义"><a href="#2-字典的定义" class="headerlink" title="2. 字典的定义"></a>2. 字典的定义</h2><p>字典 是无序的 键:值（<code>key:value</code>）对集合，键必须是互不相同的（在同一个字典之内）。</p>
<ul>
<li><code>dict</code> 内部存放的顺序和 <code>key</code> 放入的顺序是没有关系的。</li>
<li><code>dict</code> 查找和插入的速度极快，不会随着 <code>key</code> 的增加而增加，但是需要占用大量的内存。</li>
</ul>
<p>字典 定义语法为 <code>{元素1, 元素2, ..., 元素n}</code></p>
<ul>
<li>其中每一个元素是一个「键值对」– 键:值 (<code>key:value</code>)</li>
<li>关键点是「大括号 {}」,「逗号 ,」和「冒号 :」</li>
<li>大括号 – 把所有元素绑在一起</li>
<li>逗号 – 将每个键值对分开</li>
<li>冒号 – 将键和值分开</li>
</ul>
<h2 id="3-创建和访问字典"><a href="#3-创建和访问字典" class="headerlink" title="3. 创建和访问字典"></a>3. 创建和访问字典</h2><p>【例子】</p>
<p>[88]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brand &#x3D; [&#39;李宁&#39;, &#39;耐克&#39;, &#39;阿迪达斯&#39;]</span><br><span class="line">slogan &#x3D; [&#39;一切皆有可能&#39;, &#39;Just do it&#39;, &#39;Impossible is nothing&#39;]</span><br><span class="line">print(&#39;耐克的口号是:&#39;, slogan[brand.index(&#39;耐克&#39;)])  </span><br><span class="line"># 耐克的口号是: Just do it</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;&#39;李宁&#39;: &#39;一切皆有可能&#39;, &#39;耐克&#39;: &#39;Just do it&#39;, &#39;阿迪达斯&#39;: &#39;Impossible is nothing&#39;&#125;</span><br><span class="line">print(&#39;耐克的口号是:&#39;, dic[&#39;耐克&#39;])  </span><br><span class="line"># 耐克的口号是: Just do it</span><br><span class="line">耐克的口号是: Just do it</span><br><span class="line">耐克的口号是: Just do it</span><br></pre></td></tr></table></figure>

<p>【例子】通过字符串或数值作为<code>key</code>来创建字典。</p>
<p>[2]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic1 &#x3D; &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;</span><br><span class="line">print(dic1)  # &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;</span><br><span class="line">print(dic1[1])  # one</span><br><span class="line">print(dic1[4])  # KeyError: 4</span><br><span class="line"></span><br><span class="line">&#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;</span><br><span class="line">one</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-2-bb8d02bd63a3&gt; in &lt;module&gt;()</span><br><span class="line">      2 print(dic1)  # &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;</span><br><span class="line">      3 print(dic1[1])  # one</span><br><span class="line">----&gt; 4 print(dic1[4])  # KeyError: 4</span><br><span class="line"></span><br><span class="line">KeyError: 4</span><br></pre></td></tr></table></figure>

<p>[3]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic2 &#x3D; &#123;&#39;rice&#39;: 35, &#39;wheat&#39;: 101, &#39;corn&#39;: 67&#125;</span><br><span class="line">print(dic2)  # &#123;&#39;wheat&#39;: 101, &#39;corn&#39;: 67, &#39;rice&#39;: 35&#125;</span><br><span class="line">print(dic2[&#39;rice&#39;])  # 35</span><br><span class="line">&#123;&#39;rice&#39;: 35, &#39;wheat&#39;: 101, &#39;corn&#39;: 67&#125;</span><br><span class="line">35</span><br></pre></td></tr></table></figure>

<p>注意：如果我们取的键在字典中不存在，会直接报错<code>KeyError</code>。</p>
<p>【例子】通过元组作为<code>key</code>来创建字典，但一般不这样使用。</p>
<p>[91]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;(1, 2, 3): &quot;Tom&quot;, &quot;Age&quot;: 12, 3: [3, 5, 7]&#125;</span><br><span class="line">print(dic)  # &#123;(1, 2, 3): &#39;Tom&#39;, &#39;Age&#39;: 12, 3: [3, 5, 7]&#125;</span><br><span class="line">print(type(dic))  # &lt;class &#39;dict&#39;&gt;</span><br><span class="line">&#123;(1, 2, 3): &#39;Tom&#39;, &#39;Age&#39;: 12, 3: [3, 5, 7]&#125;</span><br><span class="line">&lt;class &#39;dict&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>通过构造函数<code>dict</code>来创建字典。</p>
<ul>
<li><code>dict()</code> 创建一个空的字典。</li>
</ul>
<p>【例子】通过<code>key</code>直接把数据放入字典中，但一个<code>key</code>只能对应一个<code>value</code>，多次对一个<code>key</code>放入 <code>value</code>，后面的值会把前面的值冲掉。</p>
<p>[92]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; dict()</span><br><span class="line">dic[&#39;a&#39;] &#x3D; 1</span><br><span class="line">dic[&#39;b&#39;] &#x3D; 2</span><br><span class="line">dic[&#39;c&#39;] &#x3D; 3</span><br><span class="line"></span><br><span class="line">print(dic)</span><br><span class="line"># &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</span><br><span class="line"></span><br><span class="line">dic[&#39;a&#39;] &#x3D; 11</span><br><span class="line">print(dic)</span><br><span class="line"># &#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</span><br><span class="line"></span><br><span class="line">dic[&#39;d&#39;] &#x3D; 4</span><br><span class="line">print(dic)</span><br><span class="line"># &#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line">&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</span><br><span class="line">&#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</span><br><span class="line">&#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict(mapping)</code> new dictionary initialized from a mapping object’s (key, value) pairs</li>
</ul>
<p>【例子】</p>
<p>[95]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic1 &#x3D; dict([(&#39;apple&#39;, 4139), (&#39;peach&#39;, 4127), (&#39;cherry&#39;, 4098)])</span><br><span class="line">print(dic1)  # &#123;&#39;cherry&#39;: 4098, &#39;apple&#39;: 4139, &#39;peach&#39;: 4127&#125;</span><br><span class="line"></span><br><span class="line">dic2 &#x3D; dict(((&#39;apple&#39;, 4139), (&#39;peach&#39;, 4127), (&#39;cherry&#39;, 4098)))</span><br><span class="line">print(dic2)  # &#123;&#39;peach&#39;: 4127, &#39;cherry&#39;: 4098, &#39;apple&#39;: 4139&#125;</span><br><span class="line">&#123;&#39;apple&#39;: 4139, &#39;peach&#39;: 4127, &#39;cherry&#39;: 4098&#125;</span><br><span class="line">&#123;&#39;apple&#39;: 4139, &#39;peach&#39;: 4127, &#39;cherry&#39;: 4098&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict(**kwargs)</code> -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)</li>
</ul>
<p>【例子】这种情况下，键只能为字符串类型，并且创建的时候字符串不能加引号，加上就会直接报语法错误。</p>
<p>[96]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; dict(name&#x3D;&#39;Tom&#39;, age&#x3D;10)</span><br><span class="line">print(dic)  # &#123;&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 10&#125;</span><br><span class="line">print(type(dic))  # &lt;class &#39;dict&#39;&gt;</span><br><span class="line">&#123;&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 10&#125;</span><br><span class="line">&lt;class &#39;dict&#39;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-字典的内置方法"><a href="#4-字典的内置方法" class="headerlink" title="4. 字典的内置方法"></a>4. 字典的内置方法</h2><ul>
<li><code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</li>
</ul>
<p>【例子】</p>
<p>[97]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seq &#x3D; (&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;)</span><br><span class="line">dic1 &#x3D; dict.fromkeys(seq)</span><br><span class="line">print(dic1)</span><br><span class="line"># &#123;&#39;name&#39;: None, &#39;age&#39;: None, &#39;sex&#39;: None&#125;</span><br><span class="line"></span><br><span class="line">dic2 &#x3D; dict.fromkeys(seq, 10)</span><br><span class="line">print(dic2)</span><br><span class="line"># &#123;&#39;name&#39;: 10, &#39;age&#39;: 10, &#39;sex&#39;: 10&#125;</span><br><span class="line"></span><br><span class="line">dic3 &#x3D; dict.fromkeys(seq, (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;))</span><br><span class="line">print(dic3)</span><br><span class="line"># &#123;&#39;name&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;age&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;sex&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;)&#125;</span><br><span class="line">&#123;&#39;name&#39;: None, &#39;age&#39;: None, &#39;sex&#39;: None&#125;</span><br><span class="line">&#123;&#39;name&#39;: 10, &#39;age&#39;: 10, &#39;sex&#39;: 10&#125;</span><br><span class="line">&#123;&#39;name&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;age&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;sex&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;)&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.keys()</code>返回一个可迭代对象，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有键。</li>
</ul>
<p>【例子】</p>
<p>[98]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Name&#39;: &#39;lsgogroup&#39;, &#39;Age&#39;: 7&#125;</span><br><span class="line">print(dic.keys())  # dict_keys([&#39;Name&#39;, &#39;Age&#39;])</span><br><span class="line">lst &#x3D; list(dic.keys())  # 转换为列表</span><br><span class="line">print(lst)  # [&#39;Name&#39;, &#39;Age&#39;]</span><br><span class="line">dict_keys([&#39;Name&#39;, &#39;Age&#39;])</span><br><span class="line">[&#39;Name&#39;, &#39;Age&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.values()</code>返回一个迭代器，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有值。</li>
</ul>
<p>【例子】</p>
<p>[100]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 7, &#39;Name&#39;: &#39;Zara&#39;&#125;</span><br><span class="line">print(dic.values())</span><br><span class="line"># dict_values([&#39;female&#39;, 7, &#39;Zara&#39;])</span><br><span class="line"></span><br><span class="line">print(list(dic.values()))</span><br><span class="line"># [7, &#39;female&#39;, &#39;Zara&#39;]</span><br><span class="line">dict_values([&#39;female&#39;, 7, &#39;Zara&#39;])</span><br><span class="line">[&#39;female&#39;, 7, &#39;Zara&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.items()</code>以列表返回可遍历的 (键, 值) 元组数组。</li>
</ul>
<p>【例子】</p>
<p>[101]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;</span><br><span class="line">print(dic.items())</span><br><span class="line"># dict_items([(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)])</span><br><span class="line"></span><br><span class="line">print(tuple(dic.items()))</span><br><span class="line"># ((&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7))</span><br><span class="line"></span><br><span class="line">print(list(dic.items()))</span><br><span class="line"># [(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)]</span><br><span class="line">dict_items([(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)])</span><br><span class="line">((&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7))</span><br><span class="line">[(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.get(key, default=None)</code> 返回指定键的值，如果值不在字典中返回默认值。</li>
</ul>
<p>【例子】</p>
<p>[102]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 27&#125;</span><br><span class="line">print(&quot;Age 值为 : %s&quot; % dic.get(&#39;Age&#39;))  # Age 值为 : 27</span><br><span class="line">print(&quot;Sex 值为 : %s&quot; % dic.get(&#39;Sex&#39;, &quot;NA&quot;))  # Sex 值为 : NA</span><br><span class="line">print(dic)  # &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 27&#125;</span><br><span class="line">Age 值为 : 27</span><br><span class="line">Sex 值为 : NA</span><br><span class="line">&#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 27&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.setdefault(key, default=None)</code>和<code>get()</code>方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。</li>
</ul>
<p>【例子】</p>
<p>[103]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;</span><br><span class="line">print(&quot;Age 键的值为 : %s&quot; % dic.setdefault(&#39;Age&#39;, None))  # Age 键的值为 : 7</span><br><span class="line">print(&quot;Sex 键的值为 : %s&quot; % dic.setdefault(&#39;Sex&#39;, None))  # Sex 键的值为 : None</span><br><span class="line">print(dic)  </span><br><span class="line"># &#123;&#39;Age&#39;: 7, &#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Sex&#39;: None&#125;</span><br><span class="line">Age 键的值为 : 7</span><br><span class="line">Sex 键的值为 : None</span><br><span class="line">&#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7, &#39;Sex&#39;: None&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key in dict</code> <code>in</code> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回<code>true</code>，否则返回<code>false</code>。而<code>not in</code>操作符刚好相反，如果键在字典 dict 里返回<code>false</code>，否则返回<code>true</code>。</li>
</ul>
<p>【例子】</p>
<p>[104]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;</span><br><span class="line"></span><br><span class="line"># in 检测键 Age 是否存在</span><br><span class="line">if &#39;Age&#39; in dic:</span><br><span class="line">    print(&quot;键 Age 存在&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;键 Age 不存在&quot;)</span><br><span class="line"></span><br><span class="line"># 检测键 Sex 是否存在</span><br><span class="line">if &#39;Sex&#39; in dic:</span><br><span class="line">    print(&quot;键 Sex 存在&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;键 Sex 不存在&quot;)</span><br><span class="line"></span><br><span class="line"># not in 检测键 Age 是否存在</span><br><span class="line">if &#39;Age&#39; not in dic:</span><br><span class="line">    print(&quot;键 Age 不存在&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;键 Age 存在&quot;)</span><br><span class="line"></span><br><span class="line"># 键 Age 存在</span><br><span class="line"># 键 Sex 不存在</span><br><span class="line"># 键 Age 存在</span><br><span class="line">键 Age 存在</span><br><span class="line">键 Sex 不存在</span><br><span class="line">键 Age 存在</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.pop(key[,default])</code>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。若<code>key</code>不存在，则返回 <code>default</code> 值。</li>
<li><code>del dict[key]</code> 删除字典给定键 <code>key</code> 所对应的值。</li>
</ul>
<p>【例子】</p>
<p>[105]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic1 &#x3D; &#123;1: &quot;a&quot;, 2: [1, 2]&#125;</span><br><span class="line">print(dic1.pop(1), dic1)  # a &#123;2: [1, 2]&#125;</span><br><span class="line"></span><br><span class="line"># 设置默认值，必须添加，否则报错</span><br><span class="line">print(dic1.pop(3, &quot;nokey&quot;), dic1)  # nokey &#123;2: [1, 2]&#125;</span><br><span class="line"></span><br><span class="line">del dic1[2]</span><br><span class="line">print(dic1)  # &#123;&#125;</span><br><span class="line">a &#123;2: [1, 2]&#125;</span><br><span class="line">nokey &#123;2: [1, 2]&#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.popitem()</code>随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。</li>
</ul>
<p>【例子】</p>
<p>[107]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic1 &#x3D; &#123;1: &quot;a&quot;, 2: [1, 2]&#125;</span><br><span class="line">print(dic1.popitem())  # &#123;2: [1, 2]&#125;</span><br><span class="line">print(dic1)  # (1, &#39;a&#39;)</span><br><span class="line">(2, [1, 2])</span><br><span class="line">&#123;1: &#39;a&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.clear()</code>用于删除字典内所有元素。</li>
</ul>
<p>【例子】</p>
<p>[108]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7&#125;</span><br><span class="line">print(&quot;字典长度 : %d&quot; % len(dic))  # 字典长度 : 2</span><br><span class="line">dic.clear()</span><br><span class="line">print(&quot;字典删除后长度 : %d&quot; % len(dic))  </span><br><span class="line"># 字典删除后长度 : 0</span><br><span class="line">字典长度 : 2</span><br><span class="line">字典删除后长度 : 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.copy()</code>返回一个字典的浅复制。</li>
</ul>
<p>【例子】</p>
<p>[109]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic1 &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;</span><br><span class="line">dic2 &#x3D; dic1.copy()</span><br><span class="line">print(&quot;dic2&quot;)  </span><br><span class="line"># &#123;&#39;Age&#39;: 7, &#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Class&#39;: &#39;First&#39;&#125;</span><br><span class="line">dic2</span><br></pre></td></tr></table></figure>

<p>【例子】直接赋值和 copy 的区别</p>
<p>[110]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic1 &#x3D; &#123;&#39;user&#39;: &#39;lsgogroup&#39;, &#39;num&#39;: [1, 2, 3]&#125;</span><br><span class="line"></span><br><span class="line"># 引用对象</span><br><span class="line">dic2 &#x3D; dic1  </span><br><span class="line"># 浅拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用</span><br><span class="line">dic3 &#x3D; dic1.copy()  </span><br><span class="line"></span><br><span class="line">print(id(dic1))  # 148635574728</span><br><span class="line">print(id(dic2))  # 148635574728</span><br><span class="line">print(id(dic3))  # 148635574344</span><br><span class="line"></span><br><span class="line"># 修改 data 数据</span><br><span class="line">dic1[&#39;user&#39;] &#x3D; &#39;root&#39;</span><br><span class="line">dic1[&#39;num&#39;].remove(1)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">print(dic1)  # &#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;</span><br><span class="line">print(dic2)  # &#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;</span><br><span class="line">print(dic3)  # &#123;&#39;user&#39;: &#39;runoob&#39;, &#39;num&#39;: [2, 3]&#125;</span><br><span class="line">2131669221448</span><br><span class="line">2131669221448</span><br><span class="line">2131669225120</span><br><span class="line">&#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;</span><br><span class="line">&#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;</span><br><span class="line">&#123;&#39;user&#39;: &#39;lsgogroup&#39;, &#39;num&#39;: [2, 3]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict.update(dict2)</code>把字典参数 <code>dict2</code> 的 <code>key:value</code>对 更新到字典 <code>dict</code> 里。</li>
</ul>
<p>【例子】</p>
<p>[111]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;</span><br><span class="line">dic2 &#x3D; &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 8&#125;</span><br><span class="line">dic.update(dic2)</span><br><span class="line">print(dic)  </span><br><span class="line"># &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 8, &#39;Name&#39;: &#39;Lsgogroup&#39;&#125;</span><br><span class="line">&#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 8, &#39;Sex&#39;: &#39;female&#39;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>Python 中<code>set</code>与<code>dict</code>类似，也是一组<code>key</code>的集合，但不存储<code>value</code>。由于<code>key</code>不能重复，所以，在<code>set</code>中，没有重复的<code>key</code>。</p>
<p>注意，<code>key</code>为不可变类型，即可哈希的值。</p>
<p>【例子】</p>
<p>[112]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; &#123;&#125;</span><br><span class="line">print(type(num))  # &lt;class &#39;dict&#39;&gt;</span><br><span class="line">num &#x3D; &#123;1, 2, 3, 4&#125;</span><br><span class="line">print(type(num))  # &lt;class &#39;set&#39;&gt;</span><br><span class="line">&lt;class &#39;dict&#39;&gt;</span><br><span class="line">&lt;class &#39;set&#39;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1-集合的创建"><a href="#1-集合的创建" class="headerlink" title="1. 集合的创建"></a>1. 集合的创建</h2><ul>
<li>先创建对象再加入元素。</li>
<li>在创建空集合的时候只能使用<code>s = set()</code>，因为<code>s = {}</code>创建的是空字典。</li>
</ul>
<p>【例子】</p>
<p>[113]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basket &#x3D; set()</span><br><span class="line">basket.add(&#39;apple&#39;)</span><br><span class="line">basket.add(&#39;banana&#39;)</span><br><span class="line">print(basket)  # &#123;&#39;banana&#39;, &#39;apple&#39;&#125;</span><br><span class="line">&#123;&#39;banana&#39;, &#39;apple&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接把一堆元素用花括号括起来<code>{元素1, 元素2, ..., 元素n}</code>。</li>
<li>重复元素在<code>set</code>中会被自动被过滤。</li>
</ul>
<p>【例子】</p>
<p>[114]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basket &#x3D; &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;</span><br><span class="line">print(basket)  # &#123;&#39;banana&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;&#125;</span><br><span class="line">&#123;&#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>set(value)</code>工厂函数，把列表或元组转换成集合。</li>
</ul>
<p>【例子】</p>
<p>[115]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; set(&#39;abracadabra&#39;)</span><br><span class="line">print(a)  </span><br><span class="line"># &#123;&#39;r&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;&#125;</span><br><span class="line"></span><br><span class="line">b &#x3D; set((&quot;Google&quot;, &quot;Lsgogroup&quot;, &quot;Taobao&quot;, &quot;Taobao&quot;))</span><br><span class="line">print(b)  </span><br><span class="line"># &#123;&#39;Taobao&#39;, &#39;Lsgogroup&#39;, &#39;Google&#39;&#125;</span><br><span class="line"></span><br><span class="line">c &#x3D; set([&quot;Google&quot;, &quot;Lsgogroup&quot;, &quot;Taobao&quot;, &quot;Google&quot;])</span><br><span class="line">print(c)  </span><br><span class="line"># &#123;&#39;Taobao&#39;, &#39;Lsgogroup&#39;, &#39;Google&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;Taobao&#39;, &#39;Google&#39;, &#39;Lsgogroup&#39;&#125;</span><br><span class="line">&#123;&#39;Taobao&#39;, &#39;Google&#39;, &#39;Lsgogroup&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>【例子】去掉列表中重复的元素</p>
<p>[116]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lst &#x3D; [0, 1, 2, 3, 4, 5, 5, 3, 1]</span><br><span class="line"></span><br><span class="line">temp &#x3D; []</span><br><span class="line">for item in lst:</span><br><span class="line">    if item not in temp:</span><br><span class="line">        temp.append(item)</span><br><span class="line"></span><br><span class="line">print(temp)  # [0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">a &#x3D; set(lst)</span><br><span class="line">print(list(a))  # [0, 1, 2, 3, 4, 5]</span><br><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line">[0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<p>从结果发现集合的两个特点：无序 (unordered) 和唯一 (unique)。</p>
<p>由于 <code>set</code> 存储的是无序集合，所以我们不可以为集合创建索引或执行切片(slice)操作，也没有键(keys)可用来获取集合中元素的值，但是可以判断一个元素是否在集合中。</p>
<h2 id="2-访问集合中的值"><a href="#2-访问集合中的值" class="headerlink" title="2. 访问集合中的值"></a>2. 访问集合中的值</h2><ul>
<li>可以使用<code>len()</code>內建函数得到集合的大小。</li>
</ul>
<p>【例子】</p>
<p>[117]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])</span><br><span class="line">print(len(s))  # 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用<code>for</code>把集合中的数据一个个读取出来。</li>
</ul>
<p>【例子】</p>
<p>[7]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])</span><br><span class="line">for item in s:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line"># Baidu</span><br><span class="line"># Google</span><br><span class="line"># Taobao</span><br><span class="line">Baidu</span><br><span class="line">Taobao</span><br><span class="line">Google</span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过<code>in</code>或<code>not in</code>判断一个元素是否在集合中已经存在</li>
</ul>
<p>【例子】</p>
<p>[119]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])</span><br><span class="line">print(&#39;Taobao&#39; in s)  # True</span><br><span class="line">print(&#39;Facebook&#39; not in s)  # True</span><br><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="3-集合的内置方法"><a href="#3-集合的内置方法" class="headerlink" title="3. 集合的内置方法"></a>3. 集合的内置方法</h2><ul>
<li><code>set.add(elmnt)</code>用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作。</li>
</ul>
<p>【例子】</p>
<p>[120]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;</span><br><span class="line">fruits.add(&quot;orange&quot;)</span><br><span class="line">print(fruits)  </span><br><span class="line"># &#123;&#39;orange&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;</span><br><span class="line"></span><br><span class="line">fruits.add(&quot;apple&quot;)</span><br><span class="line">print(fruits)  </span><br><span class="line"># &#123;&#39;orange&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;</span><br><span class="line">&#123;&#39;cherry&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;</span><br><span class="line">&#123;&#39;cherry&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.update(set)</code>用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。</li>
</ul>
<p>【例子】</p>
<p>[121]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;</span><br><span class="line">y &#x3D; &#123;&quot;google&quot;, &quot;baidu&quot;, &quot;apple&quot;&#125;</span><br><span class="line">x.update(y)</span><br><span class="line">print(x)</span><br><span class="line"># &#123;&#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;google&#39;, &#39;baidu&#39;&#125;</span><br><span class="line"></span><br><span class="line">y.update([&quot;lsgo&quot;, &quot;dreamtech&quot;])</span><br><span class="line">print(y)</span><br><span class="line"># &#123;&#39;lsgo&#39;, &#39;baidu&#39;, &#39;dreamtech&#39;, &#39;apple&#39;, &#39;google&#39;&#125;</span><br><span class="line">&#123;&#39;google&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;apple&#39;, &#39;baidu&#39;&#125;</span><br><span class="line">&#123;&#39;apple&#39;, &#39;dreamtech&#39;, &#39;lsgo&#39;, &#39;google&#39;, &#39;baidu&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.remove(item)</code> 用于移除集合中的指定元素。如果元素不存在，则会发生错误。</li>
</ul>
<p>【例子】</p>
<p>[122]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;</span><br><span class="line">fruits.remove(&quot;banana&quot;)</span><br><span class="line">print(fruits)  # &#123;&#39;apple&#39;, &#39;cherry&#39;&#125;</span><br><span class="line">&#123;&#39;cherry&#39;, &#39;apple&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.discard(value)</code> 用于移除指定的集合元素。<code>remove()</code> 方法在移除一个不存在的元素时会发生错误，而 <code>discard()</code> 方法不会。</li>
</ul>
<p>【例子】</p>
<p>[123]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;</span><br><span class="line">fruits.discard(&quot;banana&quot;)</span><br><span class="line">print(fruits)  # &#123;&#39;apple&#39;, &#39;cherry&#39;&#125;</span><br><span class="line">&#123;&#39;cherry&#39;, &#39;apple&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.pop()</code> 用于随机移除一个元素。</li>
</ul>
<p>【例子】</p>
<p>[66]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;</span><br><span class="line">x &#x3D; fruits.pop()</span><br><span class="line">print(fruits)  # &#123;&#39;cherry&#39;, &#39;apple&#39;&#125;</span><br><span class="line">print(x)  # banana</span><br><span class="line">&#123;&#39;banana&#39;, &#39;apple&#39;&#125;</span><br><span class="line">cherry</span><br></pre></td></tr></table></figure>

<p>由于 set 是无序和无重复元素的集合，所以两个或多个 set 可以做数学意义上的集合操作。</p>
<ul>
<li><code>set.intersection(set1, set2)</code> 返回两个集合的交集。</li>
<li><code>set1 &amp; set2</code> 返回两个集合的交集。</li>
<li><code>set.intersection_update(set1, set2)</code> 交集，在原始的集合上移除不重叠的元素。</li>
</ul>
<p>【例子】</p>
<p>[67]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; set(&#39;abracadabra&#39;)</span><br><span class="line">b &#x3D; set(&#39;alacazam&#39;)</span><br><span class="line">print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;</span><br><span class="line">print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;</span><br><span class="line"></span><br><span class="line">c &#x3D; a.intersection(b)</span><br><span class="line">print(c)  # &#123;&#39;a&#39;, &#39;c&#39;&#125;</span><br><span class="line">print(a &amp; b)  # &#123;&#39;c&#39;, &#39;a&#39;&#125;</span><br><span class="line">print(a)  # &#123;&#39;a&#39;, &#39;r&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;</span><br><span class="line"></span><br><span class="line">a.intersection_update(b)</span><br><span class="line">print(a)  # &#123;&#39;a&#39;, &#39;c&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;a&#39;, &#39;c&#39;, &#39;z&#39;, &#39;m&#39;&#125;</span><br><span class="line">&#123;&#39;a&#39;, &#39;c&#39;&#125;</span><br><span class="line">&#123;&#39;a&#39;, &#39;c&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;a&#39;, &#39;c&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.union(set1, set2)</code> 返回两个集合的并集。</li>
<li><code>set1 | set2</code> 返回两个集合的并集。</li>
</ul>
<p>【例子】</p>
<p>[68]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; set(&#39;abracadabra&#39;)</span><br><span class="line">b &#x3D; set(&#39;alacazam&#39;)</span><br><span class="line">print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;</span><br><span class="line">print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;</span><br><span class="line"></span><br><span class="line">print(a | b)  </span><br><span class="line"># &#123;&#39;l&#39;, &#39;d&#39;, &#39;m&#39;, &#39;b&#39;, &#39;a&#39;, &#39;r&#39;, &#39;z&#39;, &#39;c&#39;&#125;</span><br><span class="line"></span><br><span class="line">c &#x3D; a.union(b)</span><br><span class="line">print(c)  </span><br><span class="line"># &#123;&#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;m&#39;, &#39;r&#39;, &#39;b&#39;, &#39;z&#39;, &#39;l&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;a&#39;, &#39;c&#39;, &#39;z&#39;, &#39;m&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;z&#39;, &#39;d&#39;, &#39;m&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;z&#39;, &#39;d&#39;, &#39;m&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.difference(set)</code> 返回集合的差集。</li>
<li><code>set1 - set2</code> 返回集合的差集。</li>
<li><code>set.difference_update(set)</code> 集合的差集，直接在原来的集合中移除元素，没有返回值。</li>
</ul>
<p>【例子】</p>
<p>[69]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; set(&#39;abracadabra&#39;)</span><br><span class="line">b &#x3D; set(&#39;alacazam&#39;)</span><br><span class="line">print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;</span><br><span class="line">print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;</span><br><span class="line"></span><br><span class="line">c &#x3D; a.difference(b)</span><br><span class="line">print(c)  # &#123;&#39;b&#39;, &#39;d&#39;, &#39;r&#39;&#125;</span><br><span class="line">print(a - b)  # &#123;&#39;d&#39;, &#39;b&#39;, &#39;r&#39;&#125;</span><br><span class="line"></span><br><span class="line">print(a)  # &#123;&#39;r&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;</span><br><span class="line">a.difference_update(b)</span><br><span class="line">print(a)  # &#123;&#39;d&#39;, &#39;r&#39;, &#39;b&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;a&#39;, &#39;c&#39;, &#39;z&#39;, &#39;m&#39;&#125;</span><br><span class="line">&#123;&#39;d&#39;, &#39;b&#39;, &#39;r&#39;&#125;</span><br><span class="line">&#123;&#39;d&#39;, &#39;b&#39;, &#39;r&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.symmetric_difference(set)</code>返回集合的异或。</li>
<li><code>set1 ^ set2</code> 返回集合的异或。</li>
<li><code>set.symmetric_difference_update(set)</code>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</li>
</ul>
<p>【例子】</p>
<p>[70]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; set(&#39;abracadabra&#39;)</span><br><span class="line">b &#x3D; set(&#39;alacazam&#39;)</span><br><span class="line">print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;</span><br><span class="line">print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;</span><br><span class="line"></span><br><span class="line">c &#x3D; a.symmetric_difference(b)</span><br><span class="line">print(c)  # &#123;&#39;m&#39;, &#39;r&#39;, &#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;d&#39;&#125;</span><br><span class="line">print(a ^ b)  # &#123;&#39;m&#39;, &#39;r&#39;, &#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;d&#39;&#125;</span><br><span class="line"></span><br><span class="line">print(a)  # &#123;&#39;r&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;</span><br><span class="line">a.symmetric_difference_update(b)</span><br><span class="line">print(a)  # &#123;&#39;r&#39;, &#39;b&#39;, &#39;m&#39;, &#39;l&#39;, &#39;z&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;a&#39;, &#39;c&#39;, &#39;z&#39;, &#39;m&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;r&#39;, &#39;d&#39;, &#39;m&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;r&#39;, &#39;d&#39;, &#39;m&#39;&#125;</span><br><span class="line">&#123;&#39;b&#39;, &#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&#123;&#39;l&#39;, &#39;b&#39;, &#39;r&#39;, &#39;z&#39;, &#39;d&#39;, &#39;m&#39;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.issubset(set)</code>判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</li>
<li><code>set1 &lt;= set2</code> 判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</li>
</ul>
<p>【例子】</p>
<p>[71]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">y &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;</span><br><span class="line">z &#x3D; x.issubset(y)</span><br><span class="line">print(z)  # True</span><br><span class="line">print(x &lt;&#x3D; y)  # True</span><br><span class="line"></span><br><span class="line">x &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">y &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;</span><br><span class="line">z &#x3D; x.issubset(y)</span><br><span class="line">print(z)  # False</span><br><span class="line">print(x &lt;&#x3D; y)  # False</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.issuperset(set)</code>用于判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</li>
<li><code>set1 &gt;= set2</code> 判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</li>
</ul>
<p>【例子】</p>
<p>[72]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;</span><br><span class="line">y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">z &#x3D; x.issuperset(y)</span><br><span class="line">print(z)  # True</span><br><span class="line">print(x &gt;&#x3D; y)  # True</span><br><span class="line"></span><br><span class="line">x &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;</span><br><span class="line">y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">z &#x3D; x.issuperset(y)</span><br><span class="line">print(z)  # False</span><br><span class="line">print(x &gt;&#x3D; y)  # False</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set.isdisjoint(set)</code> 用于判断两个集合是不是不相交，如果是返回 True，否则返回 False。</li>
</ul>
<p>【例子】</p>
<p>[73]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;</span><br><span class="line">y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">z &#x3D; x.isdisjoint(y)</span><br><span class="line">print(z)  # False</span><br><span class="line"></span><br><span class="line">x &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;m&quot;, &quot;g&quot;&#125;</span><br><span class="line">y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">z &#x3D; x.isdisjoint(y)</span><br><span class="line">print(z)  # True</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h2 id="4-集合的转换"><a href="#4-集合的转换" class="headerlink" title="4. 集合的转换"></a>4. 集合的转换</h2><p>【例子】</p>
<p>[74]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">se &#x3D; set(range(4))</span><br><span class="line">li &#x3D; list(se)</span><br><span class="line">tu &#x3D; tuple(se)</span><br><span class="line"></span><br><span class="line">print(se, type(se))  # &#123;0, 1, 2, 3&#125; &lt;class &#39;set&#39;&gt;</span><br><span class="line">print(li, type(li))  # [0, 1, 2, 3] &lt;class &#39;list&#39;&gt;</span><br><span class="line">print(tu, type(tu))  # (0, 1, 2, 3) &lt;class &#39;tuple&#39;&gt;</span><br><span class="line">&#123;0, 1, 2, 3&#125; &lt;class &#39;set&#39;&gt;</span><br><span class="line">[0, 1, 2, 3] &lt;class &#39;list&#39;&gt;</span><br><span class="line">(0, 1, 2, 3) &lt;class &#39;tuple&#39;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-不可变集合"><a href="#5-不可变集合" class="headerlink" title="5. 不可变集合"></a>5. 不可变集合</h2><p>Python 提供了不能改变元素的集合的实现版本，即不能增加或删除元素，类型名叫<code>frozenset</code>。需要注意的是<code>frozenset</code>仍然可以进行集合操作，只是不能用带有<code>update</code>的方法。</p>
<ul>
<li><code>frozenset([iterable])</code> 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</li>
</ul>
<p>【例子】</p>
<p>[75]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; frozenset(range(10))  # 生成一个新的不可变集合</span><br><span class="line">print(a)  </span><br><span class="line"># frozenset(&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;)</span><br><span class="line"></span><br><span class="line">b &#x3D; frozenset(&#39;lsgogroup&#39;)</span><br><span class="line">print(b)  </span><br><span class="line"># frozenset(&#123;&#39;g&#39;, &#39;s&#39;, &#39;p&#39;, &#39;r&#39;, &#39;u&#39;, &#39;o&#39;, &#39;l&#39;&#125;)</span><br><span class="line">frozenset(&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;)</span><br><span class="line">frozenset(&#123;&#39;l&#39;, &#39;g&#39;, &#39;r&#39;, &#39;u&#39;, &#39;o&#39;, &#39;s&#39;, &#39;p&#39;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p>在 Python 中，序列类型包括字符串、列表、元组、集合和字典，这些序列支持一些通用的操作，但比较特殊的是，集合和字典不支持索引、切片、相加和相乘操作。</p>
<h2 id="1-针对序列的内置函数"><a href="#1-针对序列的内置函数" class="headerlink" title="1. 针对序列的内置函数"></a>1. 针对序列的内置函数</h2><ul>
<li><code>list(sub)</code> 把一个可迭代对象转换为列表。</li>
</ul>
<p>【例子】</p>
<p>[76]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; list()</span><br><span class="line">print(a)  # []</span><br><span class="line"></span><br><span class="line">b &#x3D; &#39;I Love LsgoGroup&#39;</span><br><span class="line">b &#x3D; list(b)</span><br><span class="line">print(b)  </span><br><span class="line"># [&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;]</span><br><span class="line"></span><br><span class="line">c &#x3D; (1, 1, 2, 3, 5, 8)</span><br><span class="line">c &#x3D; list(c)</span><br><span class="line">print(c)  # [1, 1, 2, 3, 5, 8]</span><br><span class="line">[]</span><br><span class="line">[&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;]</span><br><span class="line">[1, 1, 2, 3, 5, 8]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tuple(sub)</code> 把一个可迭代对象转换为元组。</li>
</ul>
<p>【例子】</p>
<p>[77]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; tuple()</span><br><span class="line">print(a)  # ()</span><br><span class="line"></span><br><span class="line">b &#x3D; &#39;I Love LsgoGroup&#39;</span><br><span class="line">b &#x3D; tuple(b)</span><br><span class="line">print(b)  </span><br><span class="line"># (&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)</span><br><span class="line"></span><br><span class="line">c &#x3D; [1, 1, 2, 3, 5, 8]</span><br><span class="line">c &#x3D; tuple(c)</span><br><span class="line">print(c)  # (1, 1, 2, 3, 5, 8)</span><br><span class="line">()</span><br><span class="line">(&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)</span><br><span class="line">(1, 1, 2, 3, 5, 8)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>str(obj)</code> 把obj对象转换为字符串</li>
</ul>
<p>【例子】</p>
<p>[78]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 123</span><br><span class="line">a &#x3D; str(a)</span><br><span class="line">print(a)  # 123</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code>len(s)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  返回对象（字符、列表、元组等）长度或元素个数。</span><br><span class="line"></span><br><span class="line">  - &#96;s&#96; -- 对象。</span><br><span class="line"></span><br><span class="line">【例子】</span><br><span class="line"></span><br><span class="line">[79]:</span><br></pre></td></tr></table></figure>
a = list()
print(len(a))  # 0
</code></pre></li>
</ul>
<p>b = (‘I’, ‘ ‘, ‘L’, ‘o’, ‘v’, ‘e’, ‘ ‘, ‘L’, ‘s’, ‘g’, ‘o’, ‘G’, ‘r’, ‘o’, ‘u’, ‘p’)<br>print(len(b))  # 16</p>
<p>c = ‘I Love LsgoGroup’<br>print(len(c))  # 16<br>0<br>16<br>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;max(sub)&#96;返回序列或者参数集合中的最大值</span><br><span class="line"></span><br><span class="line">【例子】</span><br><span class="line"></span><br><span class="line">[80]:</span><br></pre></td></tr></table></figure>
<p>print(max(1, 2, 3, 4, 5))  # 5<br>print(max([-8, 99, 3, 7, 83]))  # 99<br>print(max(‘IloveLsgoGroup’))  # v<br>5<br>99<br>v</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;min(sub)&#96;返回序列或参数集合中的最小值</span><br><span class="line"></span><br><span class="line">【例子】</span><br><span class="line"></span><br><span class="line">[81]:</span><br></pre></td></tr></table></figure>
<p>print(min(1, 2, 3, 4, 5))  # 1<br>print(min([-8, 99, 3, 7, 83]))  # -8<br>print(min(‘IloveLsgoGroup’))  # G<br>1<br>-8<br>G</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;sum(iterable[, start&#x3D;0])&#96; 返回序列&#96;iterable&#96;与可选参数&#96;start&#96;的总和。</span><br><span class="line"></span><br><span class="line">【例子】</span><br><span class="line"></span><br><span class="line">[82]:</span><br></pre></td></tr></table></figure>
<p>print(sum([1, 3, 5, 7, 9]))  # 25<br>print(sum([1, 3, 5, 7, 9], 10))  # 35<br>print(sum((1, 3, 5, 7, 9)))  # 25<br>print(sum((1, 3, 5, 7, 9), 20))  # 45<br>25<br>35<br>25<br>45</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
<p>  sorted(iterable, key=None, reverse=False)<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  对所有可迭代的对象进行排序操作。</span><br><span class="line"></span><br><span class="line">  - &#96;iterable&#96; -- 可迭代对象。</span><br><span class="line">  - &#96;key&#96; -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</span><br><span class="line">  - &#96;reverse&#96; -- 排序规则，&#96;reverse &#x3D; True&#96; 降序 ， &#96;reverse &#x3D; False&#96; 升序（默认）。</span><br><span class="line">  - 返回重新排序的列表。</span><br><span class="line"></span><br><span class="line">【例子】</span><br><span class="line"></span><br><span class="line">[83]:</span><br></pre></td></tr></table></figure><br>x = [-8, 99, 3, 7, 83]<br>print(sorted(x))  # [-8, 3, 7, 83, 99]<br>print(sorted(x, reverse=True))  # [99, 83, 7, 3, -8]</p>
<p>t = ({“age”: 20, “name”: “a”}, {“age”: 25, “name”: “b”}, {“age”: 10, “name”: “c”})<br>x = sorted(t, key=lambda a: a[“age”])<br>print(x)</p>
<h1 id="‘age’-10-‘name’-‘c’-‘age’-20-‘name’-‘a’-‘age’-25-‘name’-‘b’"><a href="#‘age’-10-‘name’-‘c’-‘age’-20-‘name’-‘a’-‘age’-25-‘name’-‘b’" class="headerlink" title="[{‘age’: 10, ‘name’: ‘c’}, {‘age’: 20, ‘name’: ‘a’}, {‘age’: 25, ‘name’: ‘b’}]"></a>[{‘age’: 10, ‘name’: ‘c’}, {‘age’: 20, ‘name’: ‘a’}, {‘age’: 25, ‘name’: ‘b’}]</h1><p>[-8, 3, 7, 83, 99]<br>[99, 83, 7, 3, -8]<br>[{‘age’: 10, ‘name’: ‘c’}, {‘age’: 20, ‘name’: ‘a’}, {‘age’: 25, ‘name’: ‘b’}]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
<p>  reversed(seq)<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  函数返回一个反转的迭代器。</span><br><span class="line"></span><br><span class="line">  - &#96;seq&#96; -- 要转换的序列，可以是 tuple, string, list 或 range。</span><br><span class="line"></span><br><span class="line">【例子】</span><br><span class="line"></span><br><span class="line">[84]:</span><br></pre></td></tr></table></figure><br>s = ‘lsgogroup’<br>x = reversed(s)<br>print(type(x))  # &lt;class ‘reversed’&gt;<br>print(x)  # &lt;reversed object at 0x000002507E8EC2C8&gt;<br>print(list(x))</p>
<h1 id="‘p’-‘u’-‘o’-‘r’-‘g’-‘o’-‘g’-‘s’-‘l’"><a href="#‘p’-‘u’-‘o’-‘r’-‘g’-‘o’-‘g’-‘s’-‘l’" class="headerlink" title="[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]"></a>[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]</h1><p>t = (‘l’, ‘s’, ‘g’, ‘o’, ‘g’, ‘r’, ‘o’, ‘u’, ‘p’)<br>print(list(reversed(t)))</p>
<h1 id="‘p’-‘u’-‘o’-‘r’-‘g’-‘o’-‘g’-‘s’-‘l’-1"><a href="#‘p’-‘u’-‘o’-‘r’-‘g’-‘o’-‘g’-‘s’-‘l’-1" class="headerlink" title="[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]"></a>[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]</h1><p>r = range(5, 9)<br>print(list(reversed(r)))</p>
<h1 id="8-7-6-5"><a href="#8-7-6-5" class="headerlink" title="[8, 7, 6, 5]"></a>[8, 7, 6, 5]</h1><p>x = [-8, 99, 3, 7, 83]<br>print(list(reversed(x)))</p>
<h1 id="83-7-3-99-8"><a href="#83-7-3-99-8" class="headerlink" title="[83, 7, 3, 99, -8]"></a>[83, 7, 3, 99, -8]</h1><p>&lt;class ‘reversed’&gt;<br>&lt;reversed object at 0x000001F0517DFD68&gt;<br>[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]<br>[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]<br>[8, 7, 6, 5]<br>[83, 7, 3, 99, -8]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;enumerate(sequence, [start&#x3D;0])&#96;</span><br><span class="line"></span><br><span class="line">【例子】用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</span><br><span class="line"></span><br><span class="line">[85]:</span><br></pre></td></tr></table></figure>
<p>seasons = [‘Spring’, ‘Summer’, ‘Fall’, ‘Winter’]<br>a = list(enumerate(seasons))<br>print(a)  </p>
<h1 id="0-‘Spring’-1-‘Summer’-2-‘Fall’-3-‘Winter’"><a href="#0-‘Spring’-1-‘Summer’-2-‘Fall’-3-‘Winter’" class="headerlink" title="[(0, ‘Spring’), (1, ‘Summer’), (2, ‘Fall’), (3, ‘Winter’)]"></a>[(0, ‘Spring’), (1, ‘Summer’), (2, ‘Fall’), (3, ‘Winter’)]</h1><p>b = list(enumerate(seasons, 1))<br>print(b)  </p>
<h1 id="1-‘Spring’-2-‘Summer’-3-‘Fall’-4-‘Winter’"><a href="#1-‘Spring’-2-‘Summer’-3-‘Fall’-4-‘Winter’" class="headerlink" title="[(1, ‘Spring’), (2, ‘Summer’), (3, ‘Fall’), (4, ‘Winter’)]"></a>[(1, ‘Spring’), (2, ‘Summer’), (3, ‘Fall’), (4, ‘Winter’)]</h1><p>for i, element in a:<br>    print(‘{0},{1}’.format(i, element))</p>
<h1 id="0-Spring"><a href="#0-Spring" class="headerlink" title="0,Spring"></a>0,Spring</h1><h1 id="1-Summer"><a href="#1-Summer" class="headerlink" title="1,Summer"></a>1,Summer</h1><h1 id="2-Fall"><a href="#2-Fall" class="headerlink" title="2,Fall"></a>2,Fall</h1><h1 id="3-Winter"><a href="#3-Winter" class="headerlink" title="3,Winter"></a>3,Winter</h1><p>[(0, ‘Spring’), (1, ‘Summer’), (2, ‘Fall’), (3, ‘Winter’)]<br>[(1, ‘Spring’), (2, ‘Summer’), (3, ‘Fall’), (4, ‘Winter’)]<br>0,Spring<br>1,Summer<br>2,Fall<br>3,Winter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
<p>  zip(iter1 [,iter2 […]])<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。</span><br><span class="line">  - 我们可以使用 &#96;list()&#96; 转换来输出列表。</span><br><span class="line">  - 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 &#96;*&#96; 号操作符，可以将元组解压为列表。</span><br><span class="line"></span><br><span class="line">【例子】</span><br><span class="line"></span><br><span class="line">[86]:</span><br></pre></td></tr></table></figure><br>a = [1, 2, 3]<br>b = [4, 5, 6]<br>c = [4, 5, 6, 7, 8]</p>
<p>zipped = zip(a, b)<br>print(zipped)  # &lt;zip object at 0x000000C5D89EDD88&gt;<br>print(list(zipped))  # [(1, 4), (2, 5), (3, 6)]<br>zipped = zip(a, c)<br>print(list(zipped))  # [(1, 4), (2, 5), (3, 6)]</p>
<p>a1, a2 = zip(*zip(a, b))<br>print(list(a1))  # [1, 2, 3]<br>print(list(a2))  # [4, 5, 6]<br>&lt;zip object at 0x000001F0517E38C8&gt;<br>[(1, 4), (2, 5), (3, 6)]<br>[(1, 4), (2, 5), (3, 6)]<br>[1, 2, 3]<br>[4, 5, 6]<br>```</p>
]]></content>
      <categories>
        <category>python基础</category>
      </categories>
  </entry>
  <entry>
    <title>wget命令</title>
    <url>/2020/05/30/wget%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><p><code>wget [选项] [参数]</code></p>
</li>
<li><p>参数</p>
<blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-a&lt;日志文件&gt;</td>
<td>在指定的日志文件中记录资料的执行过程；</td>
</tr>
<tr>
<td>-A&lt;后缀名&gt;</td>
<td>指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</td>
</tr>
<tr>
<td>-b</td>
<td>进行后台的方式运行wget；</td>
</tr>
<tr>
<td>-B&lt;连接地址&gt;</td>
<td>设置参考的连接地址的基地地址；</td>
</tr>
<tr>
<td>-c</td>
<td>继续执行上次终端的任务；</td>
</tr>
<tr>
<td>-C&lt;标志&gt;</td>
<td>设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</td>
</tr>
<tr>
<td>-d</td>
<td>调试模式运行指令；</td>
</tr>
<tr>
<td>-D&lt;域名列表&gt;</td>
<td>设置顺着的域名列表，域名之间用“，”分隔；</td>
</tr>
<tr>
<td>-e&lt;指令&gt;</td>
<td>作为文件“.wgetrc”中的一部分执行指定的指令；</td>
</tr>
<tr>
<td>-h</td>
<td>显示指令帮助信息；</td>
</tr>
<tr>
<td>-i&lt;文件&gt;</td>
<td>从指定文件获取要下载的URL地址；</td>
</tr>
<tr>
<td>-l&lt;目录列表&gt;</td>
<td>设置顺着的目录列表，多个目录用“，”分隔；</td>
</tr>
<tr>
<td>-L</td>
<td>仅顺着关联的连接；</td>
</tr>
<tr>
<td>-r</td>
<td>递归下载方式；</td>
</tr>
<tr>
<td>-nc</td>
<td>文件存在时，下载文件不覆盖原有文件；</td>
</tr>
<tr>
<td>-nv</td>
<td>下载时只显示更新和出错信息，不显示指令的详细执行过程；</td>
</tr>
<tr>
<td>-q</td>
<td>不显示指令执行过程；</td>
</tr>
<tr>
<td>-nh</td>
<td>不查询主机名称；</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细执行过程；</td>
</tr>
<tr>
<td>-V</td>
<td>显示版本信息；</td>
</tr>
<tr>
<td>–passive-ftp</td>
<td>使用被动模式PASV连接FTP服务器；</td>
</tr>
<tr>
<td>–follow-ftp</td>
<td>从HTML文件中下载FTP连接文件。</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;test.com&#x2F;testfile.zip -&gt;下载指定文件到当前文件夹</span><br><span class="line">wget -O wordpress.zip http:&#x2F;&#x2F;test.com&#x2F;download -&gt;指定保存名字</span><br><span class="line">wget --limit-rate&#x3D;300k http:&#x2F;&#x2F;www.linuxde.net&#x2F;testfile.zip -&gt;限制下载速度</span><br><span class="line">wget -c http:&#x2F;&#x2F;www.linuxde.net&#x2F;testfile.zip -&gt;断点续传</span><br><span class="line">wget -b http:&#x2F;&#x2F;www.linuxde.net&#x2F;testfile.zip -&gt;后台下载</span><br><span class="line"></span><br><span class="line"># 设置使用指定浏览器下载（伪装下载）</span><br><span class="line">wget --user-agent&#x3D;&quot;Mozilla&#x2F;5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit&#x2F;534.16 (KHTML, like Gecko) Chrome&#x2F;10.0.648.204 Safari&#x2F;534.16&quot; http:&#x2F;&#x2F;www.linuxde.net&#x2F;testfile.zip</span><br><span class="line"></span><br><span class="line">wget --spider url -&gt;测试下载</span><br><span class="line">wget --tries&#x3D;40 URL -&gt;设置重试次数为40</span><br><span class="line">wget -i filelist.txt -&gt;从filelist.txt获取下载地址</span><br><span class="line"></span><br><span class="line"># 镜像网站</span><br><span class="line"># --miror开户镜像下载。</span><br><span class="line"># -p下载所有为了html页面显示正常的文件。</span><br><span class="line"># --convert-links下载后，转换成本地的链接。</span><br><span class="line"># -P .&#x2F;LOCAL保存所有文件和目录到本地指定目录</span><br><span class="line">wget --mirror -p --convert-links -P .&#x2F;LOCAL URL</span><br><span class="line"></span><br><span class="line">wget --reject&#x3D;gif ur -&gt;下载一个网站，但你不希望下载图片，可以使用这条命令</span><br><span class="line">wget -o download.log URL -&gt;把下载信息存入日志文件</span><br><span class="line">wget -Q5m -i filelist.txt -&gt;限制总下载文件大小</span><br><span class="line">wget -r -A.pdf url -&gt;下载指定格式文件</span><br><span class="line"></span><br><span class="line"># FTP下载</span><br><span class="line">wget ftp-url</span><br><span class="line">wget --ftp-user&#x3D;USERNAME --ftp-password&#x3D;PASSWORD url</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
  </entry>
  <entry>
    <title>what is threadLocal</title>
    <url>/2020/04/20/what-is-threadLocal/</url>
    <content><![CDATA[<p>&emsp;&emsp;要是面试官问你，“在多线程环境下，如何防止自己的变量被其它线程篡改？”，你该怎么答。。。</p>
<h3 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h3><p>&emsp;&emsp;首先，它是一个数据结构，有点像<code>HashMap</code>，可以保存”key : value”键值对，但是一个<code>ThreadLocal</code>只能保存一个，并且各个线程的数据互不干扰。<strong>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localName &#x3D; new ThreadLocal();</span><br><span class="line">localName.set(&quot;hello world&quot;);</span><br><span class="line">String name &#x3D; localName.get();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在当前线程中初始化了一个<code>ThreadLocal</code>对象<code>localName</code>，并通过set方法，保存了一个值 <code>hello world</code>，同时在线程1中通过 <code>localName.get()</code>可以拿到之前设置的值，但是如果在其他线程中，拿到的将是一个<code>NULL</code>。</p>
<p> <code>set(T value)</code>和 <code>get()</code>方法的源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * Sets the current thread&#39;s copy of this thread-local variable</span><br><span class="line">    * to the specified value.  Most subclasses will have no need to</span><br><span class="line">    * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">    * method to set the values of thread-locals.</span><br><span class="line">    *</span><br><span class="line">    * @param value the value to be stored in the current thread&#39;s copy of</span><br><span class="line">    *        this thread-local.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void set(T value) &#123;</span><br><span class="line">       Thread t &#x3D; Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">       if (map !&#x3D; null)</span><br><span class="line">           map.set(this, value);</span><br><span class="line">       else</span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Returns the value in the current thread&#39;s copy of this</span><br><span class="line">    * thread-local variable.  If the variable has no value for the</span><br><span class="line">    * current thread, it is first initialized to the value returned</span><br><span class="line">    * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">    *</span><br><span class="line">    * @return the current thread&#39;s value of this thread-local</span><br><span class="line">    *&#x2F;</span><br><span class="line">public T get() &#123;</span><br><span class="line">       Thread t &#x3D; Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">       if (map !&#x3D; null) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">           if (e !&#x3D; null) &#123;</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               T result &#x3D; (T)e.value;</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Get the map associated with a ThreadLocal. Overridden in</span><br><span class="line">    * InheritableThreadLocal.</span><br><span class="line">    *</span><br><span class="line">    * @param  t the current thread</span><br><span class="line">    * @return the map</span><br><span class="line">    *&#x2F;</span><br><span class="line">   ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">       return t.threadLocals;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>线程共享变量缓存如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread.ThreadLocalMap&lt;ThreadLocal, Object&gt;;</span><br><span class="line"></span><br><span class="line">1、Thread: 当前线程，可以通过Thread.currentThread()获取。</span><br><span class="line"></span><br><span class="line">2、ThreadLocal：我们的static ThreadLocal变量。</span><br><span class="line"></span><br><span class="line">3、Object: 当前线程共享变量。</span><br></pre></td></tr></table></figure>

<p>我们调用ThreadLocal.get方法时，实际上是从当前线程中获取ThreadLocalMap&lt;ThreadLocal, Object&gt;，然后根据当前ThreadLocal获取当前线程共享变量Object。</p>
<p>ThreadLocal.set，ThreadLocal.remove实际上是同样的道理。</p>
<h3 id="这种存储结构的好处："><a href="#这种存储结构的好处：" class="headerlink" title="这种存储结构的好处："></a>这种存储结构的好处：</h3><p>1、线程死去的时候，线程共享变量ThreadLocalMap则销毁。</p>
<p>2、ThreadLocalMap&lt;ThreadLocal,Object&gt;键值对数量为ThreadLocal的数量，一般来说ThreadLocal数量很少，相比在ThreadLocal中用Map&lt;Thread, Object&gt;键值对存储线程共享变量（Thread数量一般来说比ThreadLocal数量多），性能提高很多。</p>
<p>关于ThreadLocalMap&lt;ThreadLocal, Object&gt;弱引用问题：</p>
<p>当线程没有结束，但是ThreadLocal已经被回收，则可能导致线程中存在ThreadLocalMap&lt;null, Object&gt;的键值对，造成内存泄露。（ThreadLocal被回收，ThreadLocal关联的线程共享变量还存在）。</p>
<p>虽然ThreadLocal的get，set方法可以清除ThreadLocalMap中key为null的value，但是get，set方法在内存泄露后并不会必然调用，所以为了防止此类情况的出现，我们有两种手段。</p>
<p>1、使用完线程共享变量后，显示调用ThreadLocalMap.remove方法清除线程共享变量；</p>
<p>2、JDK建议ThreadLocal定义为private static，这样ThreadLocal的弱引用问题则不存在了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>什么是事务和锁</title>
    <url>/2020/02/26/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/</url>
    <content><![CDATA[<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>&emsp;&emsp;用书本上的话来说，事务是用户定义的一个数据库操作序列，这些操作序列要么全做，要么都不做，他们是一个不可分割的工作单元，是恢复和并发控制的基本单元。</p>
<p>事务的ACID特性：</p>
<ul>
<li><p>原子性（Atomicity）</p>
<blockquote>
<p>事务是数据库的逻辑工作单元，事务中包括的诸操作要么都做，要么都不做，不可分割。</p>
</blockquote>
</li>
<li><p>一致性（Consistency）</p>
<blockquote>
<p>事务的执行结果必须使数据库从一个一致性状态转变到另一个一致性状态。</p>
</blockquote>
</li>
<li><p>隔离性（Isolation）</p>
<blockquote>
<p>一个事务的执行不能被其他事务干扰。</p>
</blockquote>
</li>
<li><p>持续性（Durability）</p>
<blockquote>
<p>一个事务一旦提交，他对数据库中的数据的改变就应该是永久的，接下来的其他操作或者故障不应该对其执行结果右任何影响。</p>
</blockquote>
</li>
</ul>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>&emsp;&emsp;保守的态度，它指的是数据对于外界的（包括系统当前的事务或来自外部系统）的事务处理修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制。在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据；修改删除数据时也要加锁，其它事务无法读取这些数据。这样就保证了操作最大程度的独占性，但随之而来的就是数据库性能的大量开销。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>&emsp;&emsp;积极的态度，乐观锁机制采取了更加宽松的加锁机制。为了减小悲观锁的开销，乐观锁应运而生，它在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>事务和锁</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是代理模式</title>
    <url>/2020/03/05/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;代理模式，即控制对象的直接访问权限。通过使用代理模式可以详细控制某个（某类）对象的方法，在调用这个方法之前做前置处理，调用这个方法之后做后置处理（这也就是Spring的AOP的微观实现）。</p>
<p><img src="/2020/03/05/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt></p>
<h3 id="核心角色"><a href="#核心角色" class="headerlink" title="核心角色"></a>核心角色</h3><ul>
<li>抽象角色：定义代理角色和真实角色的公共对外方法。</li>
<li>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。主要是关注真正的业务逻辑！</li>
<li>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以添加自己的操作，即将统一的流程控制放到代理角色中处理。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>静态代理</p>
</li>
<li><p>动态代理：<br>​ （1）JDK自带的字节码操作库实现</p>
<p> （2）javaassist字节码操作库的实现</p>
<p> （3）CGLIB第三方代理库</p>
<p> （4）ASM（底层使用指令，可维护性较差）</p>
</li>
</ul>
<h4 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h4><p>&emsp;&emsp;举一个简单的例子，比如明星和经纪人的关系，明星的面谈、签合同、唱歌、订票以及收钱等行为（方法），其中面谈、签合同、订票以及收钱等方法都可以由经纪人代理，但是唱歌需要由明星本人执行，这种显式代理的方式就是静态代理模式。</p>
<img src="/2020/03/05/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/staticProxy.png" style="zoom:50%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象明星角色</span><br><span class="line">public interface Star &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 面谈</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void confer();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 签合同</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void signContract();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 订票</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void bookTicket();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 唱歌</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void sing();</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 收钱</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	void collectMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真实明星</span><br><span class="line">public class RealStar implements Star&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void confer() &#123;</span><br><span class="line">		System.out.println(&quot;realStar面谈&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">		System.out.println(&quot;realStar签合同&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">		System.out.println(&quot;realStar订票&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sing() &#123;</span><br><span class="line">		System.out.println(&quot;周杰伦本人唱歌&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">		System.out.println(&quot;realStar收钱&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;明星经纪人</span><br><span class="line">public class ProxyStar implements Star&#123;</span><br><span class="line">	</span><br><span class="line">	private Star star;</span><br><span class="line">	</span><br><span class="line">	public ProxyStar(Star star)&#123;</span><br><span class="line">		this.star &#x3D; star;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void confer() &#123;</span><br><span class="line">		System.out.println(&quot;代理人面谈&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void signContract() &#123;</span><br><span class="line">		System.out.println(&quot;代理人签合同&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void bookTicket() &#123;</span><br><span class="line">		System.out.println(&quot;代理人订票&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sing() &#123;</span><br><span class="line">		&#x2F;&#x2F;唱歌需要真实的明星来唱，其它都可以代理</span><br><span class="line">		star.sing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void collectMoney() &#123;</span><br><span class="line">		System.out.println(&quot;代理人收钱&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端测试类</span><br><span class="line">public class Client &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Star real &#x3D; new RealStar();</span><br><span class="line">		Star proxy &#x3D; new ProxyStar(real);</span><br><span class="line">		</span><br><span class="line">		proxy.confer();</span><br><span class="line">		proxy.signContract();</span><br><span class="line">		proxy.bookTicket();</span><br><span class="line">		proxy.sing();   &#x2F;&#x2F;周杰伦本人唱歌</span><br><span class="line">		proxy.collectMoney();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h4><ul>
<li><p>JDK自带的动态代理</p>
<blockquote>
<ul>
<li><code>java.lang.reflect.Proxy</code>：动态生成代理类和对象</li>
<li><code>java.lang.reflect.InvocationHandler</code>：处理器接口，可以通过<code>invoke</code>方法实现对真实角色的访问，每次通过<code>proxy</code>生成代理类对象时都要指定对应的处理器对象。</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Star realStar &#x3D; new RealStar();</span><br><span class="line">StarHandler handler &#x3D; new StarHandler(realStar);</span><br><span class="line">Star proxy &#x3D; (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader,new Class[]&#123;Star.class&#125;,handler);</span><br><span class="line">proxy.sing();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StarHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    Star realStar;</span><br><span class="line"></span><br><span class="line">    public StarHandler(Star realStar) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.realStar &#x3D; realStar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        Object o &#x3D; null;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;真正的方法执行前&quot;);</span><br><span class="line"></span><br><span class="line">        if(method.getName().equals(&quot;sing&quot;))&#123;</span><br><span class="line">        	&#x2F;&#x2F;真正方法的调用</span><br><span class="line">            o &#x3D; method.invoke(realStar,args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;真正的方法调用后&quot;);</span><br><span class="line"></span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Star realStar &#x3D; new RealStar();</span><br><span class="line">		StarHandler handler &#x3D; new StarHandler(realStar);</span><br><span class="line">		Star proxy  &#x3D; (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Star.class&#125;, handler);</span><br><span class="line">		proxy.bookTicket();</span><br><span class="line">		proxy.sing();   &#x2F;&#x2F;周杰伦本人唱歌</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>什么是单例模式</title>
    <url>/2020/03/02/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;在标准的23种设计模式种，单例设计模式在应用中是非常常见的，而我们在学习单例模式中，一定要考虑到和多线程结合起来时可能存在的各种问题以及其解决办法，这样我们才能写出一个在多线程环境下安全、正确的单例模式。</p>
<p>单例模式常见的写法：</p>
<ul>
<li>饿汉式（静态常量）</li>
<li>饿汉式（静态代码块）</li>
<li>懒汉式（线程不安全）</li>
<li>懒汉式（线程安全，同步方法）</li>
<li>懒汉式（线程安全，同步代码块）</li>
<li>双重检查锁</li>
<li>静态内部类</li>
<li>枚举</li>
</ul>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>&emsp;&emsp;单例模式要求类能够有返回对象的一个引用<strong>（并且永远是同一个）</strong>和一个获得该实例的方法<strong>（必须是静态方法</strong>，往往使用<code>getInstance()</code>这个方法）。单例模式的实现主要通过以下步骤：</p>
<ol>
<li>将该类的构造方法定义为<strong>私有方法</strong>，这样其它的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</li>
<li>在该类种提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋值给该类保持的引用。</li>
</ol>
<blockquote>
<p><strong>注意事项：</strong>单例模式在多线程的环境下必须小心使用，如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被创建了出来，从而违反了单例模式种实例唯一的原则，解决的办法显而易见是加锁。</p>
</blockquote>
<h3 id="八种写法"><a href="#八种写法" class="headerlink" title="八种写法"></a>八种写法</h3><p>&emsp;&emsp;先简单介绍下什么是饿汉式，什么是懒汉式。顾名思义，饿汉式即需求欲望很大，无论怎么样，必须要有这个对象。而懒汉式——即无所谓，等到真正需要时再去创建对象。</p>
<h4 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class singleton()&#123;</span><br><span class="line">    private final static Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;注意构造方法必须私有</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：写法简单，就是在类加载的时候完成实例化，<strong>避免了线程同步问题</strong>。</li>
<li>缺点：没有达到懒加载的效果，如果从始至终都未使用过这个实例，会造成内存的浪费。</li>
</ul>
<h4 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">        instance &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式跟第一种方式类似，静态代码块构造对象会在类加载的时候完成的，优缺点跟上面一样。</li>
</ul>
<h4 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种写法在单线程环境下可以使用，但是多线程环境下，由于同一时间可能会有多个线程判断到<code>instance</code>为<code>null</code>，显然会产生多个实例。</li>
</ul>
<h4 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方法是对上面的线程不安全的懒汉式的改进。由于每次去获取实例的时候都会进入<code>synchronized</code>代码块而不管实例是否为null，而其实这个方法只需要执行一次实例化代码就可以，因此这样的开销非常大，所以不推荐使用。</li>
</ul>
<h4 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                instance &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>并不能起到线程同步的作用，跟第三种方式遇到的情形一致。假如两个线程同时进入了<code>if(instance == null)</code>代码块，那么还是会产生多个实例，因此同样不推荐使用。</li>
</ul>
<h4 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(singleton &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(singleton &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    singleton &#x3D; new Singleton():</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重检查锁对于多线程开发者来说并不陌生，我们进行了两次<code>if(singleton == null)</code>判断，并通过将实例singleton设置为<code>volatile</code>变量，这样可以实现变量的可见性并且禁止编译器指令重排序造成的其它问题。</li>
<li>优点：线程安全，延迟加载，效率较高。</li>
</ul>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static class SingletonInstance&#123;</span><br><span class="line">        private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要<code>Singleton</code>类被装载就会实例化，没有<code>Lazy-Loading</code>（懒加载）的作用，而静态内部类方式在<code>Singleton</code>类被装载时并不会立即实例化，而是在需要实例化时，调用<code>getInstance</code>方法，才会装载<code>SingletonInstance</code>类，从而完成Singleton的实例化。类的静态属性只会在第一次加载类的时候初始化，所以在这里，<strong><code>JVM</code>帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</strong></p>
</li>
<li><p>优点：避免了线程不安全，延迟加载，效率高。</p>
</li>
</ul>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>借助<code>JDK1.5</code>中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在<code>JDK1.5</code>中才添加，所以在实际项目开发中，使用枚举实现单例模式很少出现。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>什么是装饰者模式</title>
    <url>/2020/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;动态的给一个对象添加额外的功能，装饰者模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。</p>
<h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>处理那些可以撤销的职责</li>
<li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类的数量爆炸增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
</ol>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ol>
<li><p><code>Component</code>（抽象构件角色）</p>
<blockquote>
<p>真实对象和装饰对象有相同的接口，这样，客户端对象就能够以与真实对象相同的方式同装饰对象进行交互。</p>
</blockquote>
</li>
<li><p><code>ConcreteComponent</code>（具体构件角色，即真实对象）</p>
<blockquote>
<p>IO流中的<code>FileInputStream</code>、<code>FileOutputStream</code></p>
</blockquote>
</li>
<li><p><code>Decorator</code>（装饰角色）</p>
<blockquote>
<p>持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。</p>
</blockquote>
</li>
<li><p><code>ConcreteDecorator</code>（具体装饰角色）</p>
<blockquote>
<p>负责给构件对象增加新的责任。</p>
</blockquote>
</li>
<li><p>类图</p>
</li>
</ol>
<img src="/2020/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/myblog\source\_posts\什么是装饰者模式\051850035172757.png" style="zoom:50%;">

<h3 id="涉及角色"><a href="#涉及角色" class="headerlink" title="涉及角色"></a>涉及角色</h3><ol>
<li>抽象组件：定义一个抽象接口，来规范准备附加功能的类。</li>
<li>具体组件：将要被附加功能的类，实现抽象构件角色接口。</li>
<li>抽象装饰者：持有对具体构件角色的引用并定义与抽象构件角色一致的接口。</li>
<li>具体装饰：实现抽象装饰者角色，负责对具体构件添加额外功能。</li>
</ol>
<h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><p>&emsp;&emsp;对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。 举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，<strong>在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下</strong>，很丰盛的一顿午饭，营养又健康。那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所有食物都来继承这个类，看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Food &#123;</span><br><span class="line"></span><br><span class="line">   private String food_name;</span><br><span class="line"></span><br><span class="line">   public Food() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Food(String food_name) &#123;</span><br><span class="line">       this.food_name &#x3D; food_name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       return food_name;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，我就不解释了，然后我们写几个子类继承它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;面包类</span><br><span class="line">public class Bread extends Food &#123;</span><br><span class="line"></span><br><span class="line">   private Food basic_food;</span><br><span class="line"></span><br><span class="line">   public Bread(Food basic_food) &#123;</span><br><span class="line">       this.basic_food &#x3D; basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       &#x2F;&#x2F;加入子类实现的具体逻辑</span><br><span class="line">       return basic_food.make()+&quot;+面包&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;奶油类</span><br><span class="line">public class Cream extends Food &#123;</span><br><span class="line"></span><br><span class="line">   private Food basic_food;</span><br><span class="line"></span><br><span class="line">   public Cream(Food basic_food) &#123;</span><br><span class="line">       this.basic_food &#x3D; basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       &#x2F;&#x2F;加入子类实现的具体逻辑</span><br><span class="line">       return basic_food.make()+&quot;+奶油&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;蔬菜类</span><br><span class="line">public class Vegetable extends Food &#123;</span><br><span class="line"></span><br><span class="line">   private Food basic_food;</span><br><span class="line"></span><br><span class="line">   public Vegetable(Food basic_food) &#123;</span><br><span class="line">       this.basic_food &#x3D; basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String make() &#123;</span><br><span class="line">       &#x2F;&#x2F;加入子类实现的具体逻辑</span><br><span class="line">       return basic_food.make()+&quot;+蔬菜&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么写，不急，你看看我的Test类是怎么写的，一看你就明白了 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       Food food &#x3D; new Bread(new Vegetable(new Cream(new Food(&quot;香肠&quot;))));</span><br><span class="line">       System.out.println(food.make());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用继承去实现的话，会产生什么样的结果呢？</p>
<p>&emsp;&emsp;首先，肯定是需要创建一个Food类，然后去创建Food类的子类叫香肠奶油蔬菜三明治，但是如果我每天都不想吃同一种菜，那么每天都需要创建一个子类去继承Food类，这样下去肯定是会产生子类爆炸的。而利用装饰者模式，比如我个人就偏爱吃蔬菜、奶油、鸡蛋、面包等这几个具体的类，那么我们只需要对这几种类进行继承或者实现即可，而不用单独去一一创建组合的子类，具体吃啥则有我们自己对基本food进行自由装饰。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>什么是工厂模式</title>
    <url>/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>&emsp;&emsp;创建型设计模式中的工厂模式可以细分为三种：分别是简单工厂模式、工厂方法模式、抽象工厂模式。下面通过一些例子更加形象的理解工厂上述三种模式。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><em>定义：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</em></p>
<p>&emsp;&emsp;简单工厂模式属于类的创建型模式，又叫做<strong>静态工厂模式</strong>。通过专门定义一个工厂类来负责创建其它类的实例，被创建的实例通常都具有共同的父类。需要注意的是，简单工厂模式并不属于23种<code>GOF</code>设计模式。<strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例，简单工厂模式是工厂模式家族种最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</strong></p>
<p>简单工厂模式包含三种角色：</p>
<ol>
<li><p>工厂角色（Creator）</p>
<blockquote>
<p>这是简单工厂模式的核心，它用来<strong>负责创建所有实例</strong>的内部逻辑。工厂类<strong>可以被外界直接调用</strong>，创建所需的产品对象。</p>
</blockquote>
</li>
<li><p>抽象角色（Product）</p>
<blockquote>
<p>这是简单工厂模式所<strong>创建的所有对象的父类</strong>，它负责描述所有实例所共有的公共接口。该类可以是接口，也可以是抽象类。</p>
</blockquote>
</li>
<li><p>具体产品角色（Concrete Product）</p>
<img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/simple.png" style="zoom: 80%;">

</li>
</ol>
<h4 id="Example-for"><a href="#Example-for" class="headerlink" title="Example for"></a>Example for</h4><p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/E:%5Cmyblog%5Csource_posts%5C%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%5C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt></p>
<p>以上面的UML为例，表示用简单工厂方法模式实现的加减乘除计算器程序。</p>
<ul>
<li><p><code>OperatorFactory</code>是工厂类，其中的<code>createOperator( )</code>方法用于创建计算器对象。</p>
</li>
<li><p>其中<code>Operator</code>是一个抽象类，其中包含属性<code>numberA</code>及<code>numberB</code>，以及一个<code>getResult( )</code>方法用于返回计算结果。它的角色就是抽象角色<code>（Product）</code>。</p>
</li>
<li><p>下面的<code>AddOperator</code>、<code>SubOperator</code>、<code>MulOperator</code>、<code>DivOperator</code>是<code>Operator</code>的子类，分别代表加减乘除四种运算，他们的角色是具体产品角色<code>（Concrete Peoduct）</code>。</p>
</li>
</ul>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 简单工厂类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OperatorFactory &#123;</span><br><span class="line">    public static Operator createOperator(String operation)&#123;</span><br><span class="line">        Operator operator &#x3D; null;</span><br><span class="line">        switch (operation)&#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                operator &#x3D; new AddOperator();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                operator &#x3D; new SubOperator();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                operator &#x3D; new MulOperator();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;&#x2F;&quot;:</span><br><span class="line">                operator &#x3D; new DivOperator();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return operator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 计算器抽象类</span><br><span class="line">*&#x2F;</span><br><span class="line">public abstract class Operator&#123;</span><br><span class="line">    private double numberA;</span><br><span class="line">    private double numberB;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;获取结果的抽象方法</span><br><span class="line">    protected abstract double getResult() throws Exception;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; getter和setter方法省略</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  加法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class AddOperator extends Operator&#123;</span><br><span class="line">    &#x2F;&#x2F;实现父类的抽象方法</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult()&#123;</span><br><span class="line">        return getNumberA() + getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  减法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class SubOperator extends Operator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult()&#123;</span><br><span class="line">        return getNumberA() + getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  乘法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MulOperator extends Operator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult()&#123;</span><br><span class="line">        return getNumberA() * getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*  除法计算类</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MulOperator extends Operator&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected double getResult() throws Exception&#123;</span><br><span class="line">        if(getNmberB() &#x3D;&#x3D; 0.0)&#123;</span><br><span class="line">            throw new Exception(&quot;除数不能为0&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return getNumberA() &#x2F; getNumberB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 测试简单工厂类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class OperatorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Operator operator &#x3D; OperatorFactory.createOperator(&quot;+&quot;);</span><br><span class="line">        operator.setNumberA(10);</span><br><span class="line">        operator.setNumberB(5);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(operator.getResult());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;试想一下，当我们在coding的时候，如果在A类里面new了一个B类的对象，那么<strong>A类在某种程度上说就是依赖于B类</strong>。如果在后期开发的时候需求变化或者是维护的时候，需要修改B类的时候，我们就需要打开源代码修改所有与这个类有关的类了，做过重构的朋友就知道，这样的事情虽然无法避免，但是确实是一件让人心碎的事情。</p>
<p>简单工厂模式的优缺点：</p>
<ul>
<li>在简单工厂模式中，工厂类是整个模式的关键，它包含了必要的逻辑判断，能够根据外界给定的条件去判断应该创建哪个具体类的实例，用户使用时可以直接根据工厂类去创建所需的实例，而无需关心这些对象是如何组织并创建的，从这一点来说，这<strong>有利于整个软件体系结构的优化</strong>。</li>
<li>但是，简单工厂模式的缺点也正体现在工厂类上，<strong>由于工厂类集中了所有实例的创建逻辑</strong>，当我们增加一个新的具体类时，需要同时修改工厂类（多加几个if判断），这违反了”开闭原则“。</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><em>定义：定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</em></p>
<p>&emsp;&emsp;工厂方法模式又称<strong>多态性工厂模式</strong>，是对普通工厂方法模式的改进，在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是<strong>将具体创建的工作交给子类去做</strong>。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。简而言之，<strong>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象</strong>。</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/factory.png" alt></p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt></p>
<p>依旧以上面计算器为例，我们对OperatorFactory类更改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OperatorFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Operator createAddOperator()&#123;</span><br><span class="line">        return new AddOperator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Operator createSubOperator()&#123;</span><br><span class="line">        return new SubOperator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Operator createMulOperator()&#123;</span><br><span class="line">        return new MulOperator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Operator createDivOperator()&#123;</span><br><span class="line">        return new DivOperator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不会出现简单工厂模式中因为字符串传错而不能正常创建对象的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OperatorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Operator operator &#x3D; OperatorFactory.createAddOperator();</span><br><span class="line">        operator.setNumberA(10);</span><br><span class="line">        operator.setNumberB(5);</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(operator.getResult());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：与简单工厂模式相比，工厂方法模式避免了因为传入字符串错误而导致无法正常创建对象的问题，并且由于多态的存在，客户端代码可以做到与特定应用无关，适用于任何实体类。缺点是每次增加一个产品时，都需要增加一个具体产品类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><em>定义：提供一个接口，用于创建*</em>相关的对象家族***。</p>
<ul>
<li><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
</li>
<li><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
</li>
<li><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过<code>AbstractFactory</code>同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
</li>
</ul>
<p>从高层次来看，抽象工厂使用了组合，即 <code>Cilent</code>组合了<code>AbstractFactory</code>，而工厂方法模式使用了继承。</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abs.gif" alt></p>
<p>抽象工厂模式中包含的角色及职责：</p>
<ol>
<li><p><strong>抽象工厂角色</strong>（Creator）</p>
<p>这是抽象工厂模式的核心，任何工厂类必须实现这个接口。</p>
</li>
<li><p><strong>具体工厂角色</strong>（Concrete Creator）</p>
<p>它是抽象工厂的一个实现，负责实例化产品对象。</p>
</li>
<li><p><strong>抽象角色</strong>（Product）</p>
<p>抽象工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</p>
</li>
<li><p><strong>具体产品角色</strong>（Concrete Product）</p>
<p>抽象工厂模式所创建的具体的实例对象。</p>
</li>
</ol>
<h4 id="Example-for-1"><a href="#Example-for-1" class="headerlink" title="Example for"></a>Example for</h4><p>&emsp;&emsp;我们将创建<code>Shape</code>和<code>Color</code>接口和实现这些接口的实现类，下一步是创建抽象工厂类<code>AbastractFactory</code>。接着定义工厂类<code>ShapeFactory</code>和<code>ColorFactory</code>，这两个工厂类都是扩展了<code>AbstractFactory</code>。然后创建一个工厂生成器<code>FactoryProducer</code>。</p>
<p>下面结合UML图理解一下：</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/uml.jpg" alt></p>
<ol>
<li>根据上面的步骤，我们先为形状创建一个接口即其实现类：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Shape&#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;矩形形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Square implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;方形形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw()&#123;</span><br><span class="line">        System.out.println(&quot;园形形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后为颜色创建一个接口和他的实现类：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Color&#123;</span><br><span class="line">    void fill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Red implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill()&#123;</span><br><span class="line">        System.out.println(&quot;红色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Blue implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill()&#123;</span><br><span class="line">        System.out.println(&quot;蓝色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Green implements Color&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fill()&#123;</span><br><span class="line">        System.out.println(&quot;绿色&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为Color和Shape对象创建抽象工厂角色和具体工厂角色：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractFactory&#123;</span><br><span class="line">    public abstract Color getColor(String color);</span><br><span class="line">    public abstract Shape getShape(String shape);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 形状具体工厂</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ShapeFactory extends AbstractFactory&#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape(String shapeType)&#123;</span><br><span class="line">        if(shapeType &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(shapeType.equalsIgnoreCase(&quot;circle&quot;))&#123;</span><br><span class="line">            return new Circle();</span><br><span class="line">        &#125;esle if(shapeType.equalsIgnoreCase(&quot;rectangle&quot;))&#123;</span><br><span class="line">            return new Rectangle();</span><br><span class="line">        &#125;else if(shapeType.equalsIgnoreCase(&quot;square&quot;))&#123;</span><br><span class="line">            return new Square();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Color getColor(String color)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 颜色具体工厂</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ColorFactory extends AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">   @Override</span><br><span class="line">   public Shape getShape(String shapeType)&#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public Color getColor(String color) &#123;</span><br><span class="line">      if(color &#x3D;&#x3D; null)&#123;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;        </span><br><span class="line">      if(color.equalsIgnoreCase(&quot;red&quot;))&#123;</span><br><span class="line">         return new Red();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;green&quot;))&#123;</span><br><span class="line">         return new Green();</span><br><span class="line">      &#125; else if(color.equalsIgnoreCase(&quot;blue&quot;))&#123;</span><br><span class="line">         return new Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建工厂生成器，通过传递形状或颜色信息来获取工厂。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FactoryProducer &#123;</span><br><span class="line">   public static AbstractFactory getFactory(String choice)&#123;</span><br><span class="line">      if(choice.equalsIgnoreCase(&quot;shape&quot;))&#123;</span><br><span class="line">         return new ShapeFactory();</span><br><span class="line">      &#125; else if(choice.equalsIgnoreCase(&quot;color&quot;))&#123;</span><br><span class="line">         return new ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用<code>FactoryProducer</code>来获取<code>AbstractFactory</code>，通过传递类型信息来获取实体类的对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AbstractFactoryPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;获取形状工厂</span><br><span class="line">      AbstractFactory shapeFactory &#x3D; FactoryProducer.getFactory(&quot;SHAPE&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;获取形状为 Circle 的对象</span><br><span class="line">      Shape shape1 &#x3D; shapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;调用 Circle 的 draw 方法</span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;获取形状为 Rectangle 的对象</span><br><span class="line">      Shape shape2 &#x3D; shapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;调用 Rectangle 的 draw 方法</span><br><span class="line">      shape2.draw();</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;获取形状为 Square 的对象</span><br><span class="line">      Shape shape3 &#x3D; shapeFactory.getShape(&quot;SQUARE&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;调用 Square 的 draw 方法</span><br><span class="line">      shape3.draw();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;获取颜色工厂</span><br><span class="line">      AbstractFactory colorFactory &#x3D; FactoryProducer.getFactory(&quot;COLOR&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;获取颜色为 Red 的对象</span><br><span class="line">      Color color1 &#x3D; colorFactory.getColor(&quot;RED&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;调用 Red 的 fill 方法</span><br><span class="line">      color1.fill();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;获取颜色为 Green 的对象</span><br><span class="line">      Color color2 &#x3D; colorFactory.getColor(&quot;Green&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;调用 Green 的 fill 方法</span><br><span class="line">      color2.fill();</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;获取颜色为 Blue 的对象</span><br><span class="line">      Color color3 &#x3D; colorFactory.getColor(&quot;BLUE&quot;);</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F;调用 Blue 的 fill 方法</span><br><span class="line">      color3.fill();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三种工厂模式的区别"><a href="#三种工厂模式的区别" class="headerlink" title="三种工厂模式的区别"></a>三种工厂模式的区别</h3><p>&emsp;&emsp;GOF在《设计模式》一书种将工厂模式分为两类：工厂方法模式（FactoryMethod）和抽象工厂模式（AbstractFactory）。因此将简单工厂模式看为是工厂方法模式的一种特例，两者归为一类。</p>
<h4 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ol>
<li><p>一个抽象产品类，可以派生出多个具体产品类。</p>
</li>
<li><p>一个抽象工厂类，可以派生出多个具体工厂类。</p>
</li>
<li><p>每个具体工厂类只能创建一个具体产品类的实例。</p>
</li>
</ol>
<h4 id="抽象工厂模式-1"><a href="#抽象工厂模式-1" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><ol>
<li><p>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。</p>
</li>
<li><p>一个抽象工厂类，每个可以派生出多个具体工厂类。</p>
</li>
<li><p>每个具体工厂类可以创建多个具体产品类的实例。</p>
</li>
</ol>
<p><strong>区别</strong></p>
<ol>
<li><p>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。</p>
</li>
<li><p>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</p>
</li>
</ol>
<h3 id="形象化总结三种工厂模式"><a href="#形象化总结三种工厂模式" class="headerlink" title="形象化总结三种工厂模式"></a>形象化总结三种工厂模式</h3><p>下面例子中鼠标，键盘，耳麦为产品，惠普，戴尔为工厂。</p>
<h4 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简而言之，就是有一个专门生产某个产品的类。比如下图中的鼠标工厂，专业生产鼠标，给参数 0，生产戴尔鼠标，给参数 1，生产惠普鼠标。</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/simpleFactory.png" alt></p>
<h4 id="工厂方法模式-2"><a href="#工厂方法模式-2" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>工厂方法模式也就是鼠标工厂是个父类，有生产鼠标这个接口。</p>
<p>戴尔鼠标工厂，惠普鼠标工厂继承它，可以分别生产戴尔鼠标，惠普鼠标。</p>
<p>生产哪种鼠标不再由参数决定，而是创建鼠标工厂时，由戴尔鼠标工厂创建。</p>
<p>后续直接调用<strong>鼠标工厂.生产鼠标()</strong>即可</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/factoryMethod.png" alt></p>
<h4 id="抽象工厂模式-2"><a href="#抽象工厂模式-2" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。</p>
<p>也就是 PC 厂商是个父类，有生产鼠标，生产键盘两个接口。</p>
<p>戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。</p>
<p>创建工厂时，由戴尔工厂创建。</p>
<p>后续<strong>工厂.生产鼠标()</strong>则生产戴尔鼠标，<strong>工厂.生产键盘()</strong>则生产戴尔键盘。</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstractFactory.png" alt></p>
<p><strong><em>在抽象工厂中，假如我们要增加一个工厂：\</em></strong></p>
<p>假设我们增加华硕工厂，则我们需要增加华硕工厂，和戴尔工厂一样，继承 PC 厂商。</p>
<p>之后创建华硕鼠标，继承鼠标类。创建华硕键盘，继承键盘类即可。</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstractFactory2.png" alt></p>
<p><strong><em>在抽象工厂模式中，假如我们要增加一个产品：\</em></strong></p>
<p>假设我们增加耳麦这个产品，则首先我们需要增加耳麦这个父类，再加上戴尔耳麦，惠普耳麦这两个子类。</p>
<p>之后在PC厂商这个父类中，增加生产耳麦的接口。最后在戴尔工厂，惠普工厂这两个类中，分别实现生产戴尔耳麦，惠普耳麦的功能。 以上。</p>
<p><img src="/2020/03/01/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/abstractFactory3.png" alt></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>什么是观察者模式</title>
    <url>/2020/02/26/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>观察者模式定义了对象之间一对多的关系，这样一来，当一个对象状态改变时，它的所有依赖者都会收到通知并自动更新。</p>
</blockquote>
<p>我们可以举个例子，比如报纸或者杂志的订阅，我们读者属于订阅者，报纸或者杂志属于出版者，那么：</p>
<ol>
<li>向某家报纸社订阅报纸，只要他们有新报纸出版，就会给读者送过去，只要你是他的订阅者，那么你就一直会收到新报纸。</li>
<li>当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸过来了。</li>
<li>只要报纸社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。</li>
</ol>
<p>以上就是一个典型的适用于观察者模式的案例，我们画个图说明一下：</p>
<p><img src="/2020/02/26/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/newspaper.png" alt></p>
<p>对于这种一对多的关系，我们常用 Subject 和 Observer 接口的类设计来进行实现：</p>
<p><img src="/2020/02/26/%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/observer.png" alt></p>
<ul>
<li>Subject：这是主题接口，对象使用此接口注册为观察者，或者自己从观察者中删除</li>
<li>Observer：所有潜在的观察者都必须实现观察者接口，这个接口只有 update() 一个方法，当主题状态改变时它被调用</li>
<li>ConcreteSubject：一个具体主题总是实现主题接口，除了注册和撤销方法之外，具体主题还实现了 notifyObserver() 方法，此方法用于在改变状态时更新所有当前的观察者</li>
<li>ConcreteObserver：具体的观察者可以是实现此接口的任意类，观察者必须注册具体主题，以便接收更新</li>
</ul>
<blockquote>
<p>&emsp;&emsp;观察者模式提供一种对象设计，让主题和观察者之间松耦合。我们可以在代码中随时实现一个实现了 Observer 接口的新观察者，运行时也可以使用新观察者取代现有的观察者，主题不会收到任何的影响，同样可以在任何时候删除某些观察者。</p>
</blockquote>
<p>下面我们以微信公众号为例子，假设微信用户就是观察者，微信公众号是发布者，有多个用户关注了 NBA 这个公众号，当这个公众号更新时就会通知这些订阅者。</p>
<p>先抽象一个观察者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Observer&#123;</span><br><span class="line">	public void update(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个具体的观察者实现观察者接口，这个接口实现了更新的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VXUser implements Observer&#123;</span><br><span class="line">	private String vxName;</span><br><span class="line"></span><br><span class="line">	public VXUser(String vxName)&#123;</span><br><span class="line">		this.vxName &#x3D; vxName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void update(String message)&#123;</span><br><span class="line">		System.out.println(name + &quot;，您专注的&quot; + message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了观察者之后，我们再定义发布者，也就是微信公众号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Subject&#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;增加订阅者</span><br><span class="line">	public void registerObserver(Observer observer);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;删除订阅者</span><br><span class="line">	public void  removeObserver(Observer observer);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;更新消息时通知订阅者</span><br><span class="line">	public void notify(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上我们再定义一个具体的发布者类——微信公共号，内部维护了一个订阅该公众号的 list，并实现了接口中的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VXSubscriptionSubject implements Subject&#123;</span><br><span class="line">	&#x2F;&#x2F;存储订阅公众号的微信用户</span><br><span class="line">	private List&lt;Observer&gt; vxUserList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void registerObserver(Observer observer)&#123;</span><br><span class="line">		vxUserList.add(observer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void removeObserver(Observer observer)&#123;</span><br><span class="line">		vxUserList.remove(observer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void notify(String message)&#123;</span><br><span class="line">		for(Observer ob : vxUserList)&#123;</span><br><span class="line">			observer.update(message);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就完成了整个观察者模式的基本功能，我们可以写一个客户端程序试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		VXSubscriptionSubject vxSub &#x3D; new VXSubscriptionSubject();</span><br><span class="line">		&#x2F;&#x2F;创建一个微信用户</span><br><span class="line">		VXUser user1 &#x3D; new VXUser(&quot;user1&quot;);</span><br><span class="line">		VXUser user2 &#x3D; new VXUser(&quot;user2&quot;);</span><br><span class="line">		VXUser user3 &#x3D; new VXUser(&quot;user3&quot;);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;订阅整个公众号</span><br><span class="line">		vxSub.registerObserver(user1);</span><br><span class="line">		vxSub.registerObserver(user2);</span><br><span class="line">		vxSub.registerObserver(user3);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;公共号发布新消息</span><br><span class="line">		vxSub.notify(&quot;NBA专栏更新啦&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user1，您关注的NBA专栏更新啦</span><br><span class="line">user2，您关注的NBA专栏更新啦</span><br><span class="line">user3，您关注的NBA专栏更新啦</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;综上我们可以看到，观察者模式的实现接触了耦合，让双方都依赖于抽象，从而使得各自的变换都不会影响到另一方。但是在应用的时候需要考虑一下开发效率和运行效率的问题，程序中包含一个发布者，多个观察者，开发、调试等内容会比较复杂，而且在 Java 中消息的通知一般是顺序执行，那么一个观察者卡顿了，会影响整体的执行效率，在这种情况下需要使用异步实现。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>什么是适配器模式</title>
    <url>/2020/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p>
<p>&emsp;&emsp;适配器模式就是将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h3 id="模式中的角色"><a href="#模式中的角色" class="headerlink" title="模式中的角色"></a>模式中的角色</h3><ol>
<li><strong>目标接口（Target）</strong>：客户所期待的接口，目标可以是具体的或抽象的类，也可以是接口。</li>
<li><strong>需要适配的类（Adaptee）</strong>：需要适配的类或适配者类</li>
<li><strong>适配器（Adapter）</strong>：通过包装一个需要适配的对象，把原接口转换成目标接口。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;手机类</span><br><span class="line">public class Phone&#123;</span><br><span class="line">    public static final int V &#x3D; 220; &#x2F;&#x2F;正常电压220V，是一个常量</span><br><span class="line">    </span><br><span class="line">    private VoltageAdapter adpter;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;充电</span><br><span class="line">    public void charge()&#123;</span><br><span class="line">        adapter.changeVoltage();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAdapter(VoltageAdapter adpter)&#123;</span><br><span class="line">        this.adpter &#x3D; adpter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;变压器</span><br><span class="line">public class VoltageAdapter&#123;</span><br><span class="line">    &#x2F;&#x2F;改变电压的功能</span><br><span class="line">    public void changeVoltage()&#123;</span><br><span class="line">        System.out.println(&quot;正在充电...&quot;);</span><br><span class="line">        System.out.println(&quot;原始电压:&quot; + Phone.V + &quot;V&quot;);</span><br><span class="line">        Ststem.out.println(&quot;经过变压器转换后的电压:&quot; + (Phone.V - 200) + &quot;V&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实现适配器模式的测试类，client调用</span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line">        VoltageAdapter adapter &#x3D; new VoltageAdapter();</span><br><span class="line">        phone.setAdapter(adpter);</span><br><span class="line">        phone.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>什么是进程&amp;线程</title>
    <url>/2020/02/29/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;说起进程的由来，我们需要从操作系统的发展历史谈起。也许在今天，我们无法想象在很多年以前计算机是什么样子。我们现在可以用计算机来做很多事情：办公、娱乐、上网，但是在计算机刚出现的时候，是为了解决数学计算的问题，因为很多大量的计算通过人力去完成是很耗时间和人力成本的。在最初的时候，计算机只能接受一些特定的指令，用户输入一个指令，计算机就做一个操作。当用户在思考或者输入数据时，计算机就等待用户的输入。<br>&emsp;&emsp;显然这样效率和很低下，因为大部分时间计算机处于等待用户输入的状态而非处理数据，相当于在浪费计算机的资源。那么能不能把一系列需要操作的指令预先写下来，形成一个清单，然后一次性交给计算机，计算机不断地去读取指令来进行相应的操作？就这样，<em>批处理操作系统</em>诞生了。用户可以将需要执行的多个程序写在磁带上，然后交由计算机去读取并逐个地执行这些程序，并将输出结果写到另一个磁带上。</p>
<h3 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h3><p>&emsp;&emsp;虽然批处理操作系统的诞生极大地提高了任务处理的便捷性，但是仍然存在一个很大的问题：假如有两个任务A和B，任务A在执行到一半的过程中，需要读取大量的数据输入（I/O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。人们于是想，<em>能否在任务A读取数据的过程中，让任务B去执行，当任务A读取完数据之后，让任务B暂停，然后让任务A继续执行？</em>但是这样就有一个问题，原来每次都是一个程序在计算机里面运行，也就说内存中始终只有一个程序的运行数据。而如果想要任务A执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序，那么如何处理呢？多个程序使用的数据如何进行辨别呢？并且当一个程序运行暂停后，后面如何恢复到它之前执行的状态呢？</p>
<p>&emsp;&emsp;这个时候人们就发明了进程，用进程来对应一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂时时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。<br>&emsp;&emsp;这就引出了<strong>并发</strong>的概念，能够让操作系统从<strong>宏观</strong>上看起来同一个时间段有多个任务在执行。换句话说，进程让操作系统的并发成为了可能。 注意，虽然并发从宏观上看有多个任务在执行，但是事实上，任一个具体的时刻，只有一个任务在占用CPU资源（当然是对于单核CPU来说的）。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>&emsp;&emsp;在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。因为一个进程在一个时间段内只能做一件事情，如果一个进程有多个子任务，只能逐个地去执行这些子任务。比如对于一个监控系统来说，它不仅要把图像数据显示在画面上，还要与服务端进行通信获取图像数据，还要处理人们的交互操作。如果某一个时刻该系统正在与服务器通信获取图像数据，而用户又在监控系统上点击了某个按钮，那么该系统就要等待获取完图像数据之后才能处理用户的操作，如果获取图像数据需要耗费10s，那么用户就只有一直在等待。显然，对于这样的系统，人们是无法满足的。</p>
<p>&emsp;&emsp;那么可不可以将这些子任务分开执行呢？即在系统获取图像数据的同时，如果用户点击了某个按钮，则会暂停获取图像数据，而先去响应用户的操作（因为用户的操作往往执行时间很短），在处理完用户操作之后，再继续获取图像数据。人们就发明了线程，<strong>让一个线程去执行一个子任务，这样一个进程就包括了多个线程，每个线程负责一个独立的子任务</strong>，这样在用户点击按钮的时候，就可以暂停获取图像数据的线程，让UI线程响应用户的操作，响应完之后再切换回来，让获取图像的线程得到CPU资源。从而让用户感觉系统是同时在做多件事情的，满足了用户对实时性的要求。换句话说，进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。但是要注意，一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。</p>
<h3 id="问题和小结"><a href="#问题和小结" class="headerlink" title="问题和小结"></a>问题和小结</h3><p>&emsp;&emsp;现在很多时候都采用多线程编程，那么是不是多线程的性能一定就由于单线程呢？答案是不一定，要看具体的任务以及计算机的配置。比如说：</p>
<ul>
<li>对于单核CPU，如果是CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用CPU资源，如果采用多线程，线程切换导致的开销反而会让性能下降。但是对于比如交互类型的任务，肯定是需要使用多线程的。</li>
<li>而对于多核CPU，对于解压文件来说，多线程肯定优于单线程，因为多个线程能够更加充分利用每个核的资源。</li>
</ul>
<p>&emsp;&emsp;虽然多线程能够提升程序性能，但是相对于单线程来说，它的编程要复杂地多，要考虑线程安全问题。因此，在实际编程过程中，要根据实际情况具体选择。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2020/09/10/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>[TOC]</p>
<h2 id="1-原码、反码和补码"><a href="#1-原码、反码和补码" class="headerlink" title="1. 原码、反码和补码"></a>1. 原码、反码和补码</h2><p>二进制有三种不同的表示形式：原码、反码和补码，计算机内部使用补码来表示。</p>
<p><strong>原码</strong>：就是其二进制表示（注意，有一位符号位）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 00 11 -&gt; 3</span><br><span class="line">10 00 00 11 -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>反码</strong>：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 00 11 -&gt; 3</span><br><span class="line">11 11 11 00 -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>补码</strong>：正数的补码就是原码，负数的补码是反码+1。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 00 11 -&gt; 3</span><br><span class="line">11 11 11 01 -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>符号位</strong>：最高位为符号位，0表示正数，1表示负数。在位运算中符号位也参与运算。</p>
<h2 id="2-按位运算"><a href="#2-按位运算" class="headerlink" title="2. 按位运算"></a>2. 按位运算</h2><ul>
<li>按位非操作 ~</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">~ <span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>~</code> 把<code>num</code>的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">~</span><br><span class="line">---</span><br><span class="line">11 11 10 10 -&gt; -6</span><br><span class="line"></span><br><span class="line">11 11 10 11 -&gt; -5</span><br><span class="line">~</span><br><span class="line">---</span><br><span class="line">00 00 01 00 -&gt; 4</span><br></pre></td></tr></table></figure>

<ul>
<li>按位与操作 &amp;</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>只有两个对应位都为 1 时才为 1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">&amp;</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 01 00 -&gt; 4</span><br></pre></td></tr></table></figure>

<ul>
<li>按位或操作 |</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>只要两个对应位中有一个 1 时就为 1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">|</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 01 11 -&gt; 7</span><br></pre></td></tr></table></figure>

<ul>
<li>按位异或操作 ^</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>只有两个对应位不同时才为 1</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">^</span><br><span class="line">00 00 01 10 -&gt; 6</span><br><span class="line">---</span><br><span class="line">00 00 00 11 -&gt; 3</span><br></pre></td></tr></table></figure>

<p>异或操作的性质：满足交换律和结合律</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A: <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span></span><br><span class="line">B: <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">A^B: <span class="number">00</span> <span class="number">00</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">B^A: <span class="number">00</span> <span class="number">00</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">A^A: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">A^<span class="number">0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> <span class="number">00</span></span><br><span class="line"></span><br><span class="line">A^B^A: = A^A^B = B = <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按位左移操作 &lt;&lt;</li>
</ul>
<p><code>num &lt;&lt; i</code> 将<code>num</code>的二进制表示向左移动<code>i</code>位所得的值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 10 11 -&gt; 11</span><br><span class="line"><span class="number">11</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">---</span><br><span class="line">01 01 10 00 -&gt; 88</span><br></pre></td></tr></table></figure>

<ul>
<li>按位右移操作 &gt;&gt;</li>
</ul>
<p><code>num &gt;&gt; i</code> 将<code>num</code>的二进制表示向右移动<code>i</code>位所得的值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 10 11 -&gt; 11</span><br><span class="line"><span class="number">11</span> &gt;&gt; <span class="number">2</span></span><br><span class="line">---</span><br><span class="line">00 00 00 10 -&gt; 2</span><br></pre></td></tr></table></figure>

<h2 id="3-利用位运算实现快速计算"><a href="#3-利用位运算实现快速计算" class="headerlink" title="3. 利用位运算实现快速计算"></a>3. 利用位运算实现快速计算</h2><p>通过 <code>&lt;&lt;</code>，<code>&gt;&gt;</code> 快速计算2的倍数问题。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">n &lt;&lt; 1 -&gt; 计算 n*2</span><br><span class="line">n &gt;&gt; 1 -&gt; 计算 n/2，负奇数的运算不可用</span><br><span class="line">n &lt;&lt; m -&gt; 计算 n*(2^m)，即乘以 2 的 m 次方</span><br><span class="line">n &gt;&gt; m -&gt; 计算 n/(2^m)，即除以 2 的 m 次方</span><br><span class="line">1 &lt;&lt; n -&gt; 2^n</span><br></pre></td></tr></table></figure>

<p>通过 <code>^</code> 快速交换两个整数。 通过 <code>^</code> 快速交换两个整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br></pre></td></tr></table></figure>

<p>通过 <code>a &amp; (-a)</code> 快速获取<code>a</code>的最后为 1 位置的整数。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">00 00 01 01 -&gt; 5</span><br><span class="line">&amp;</span><br><span class="line">11 11 10 11 -&gt; -5</span><br><span class="line">---</span><br><span class="line">00 00 00 01 -&gt; 1</span><br><span class="line"></span><br><span class="line">00 00 11 10 -&gt; 14</span><br><span class="line">&amp;</span><br><span class="line">11 11 00 10 -&gt; -14</span><br><span class="line">---</span><br><span class="line">00 00 00 10 -&gt; 2</span><br></pre></td></tr></table></figure>

<h2 id="4-利用位运算实现整数集合"><a href="#4-利用位运算实现整数集合" class="headerlink" title="4. 利用位运算实现整数集合"></a>4. 利用位运算实现整数集合</h2><p>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</p>
<p>比如集合 <code>{1, 3, 4, 8}</code>，可以表示成 <code>01 00 01 10 10</code> 而对应的位运算也就可以看作是对集合进行的操作。</p>
<p>元素与集合的操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a | (1&lt;&lt;i)  -&gt; 把 i 插入到集合中</span><br><span class="line">a &amp; ~(1&lt;&lt;i) -&gt; 把 i 从集合中删除</span><br><span class="line">a &amp; (1&lt;&lt;i)  -&gt; 判断 i 是否属于该集合（零不属于，非零属于）</span><br></pre></td></tr></table></figure>

<p>集合之间的操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a 补   -&gt; ~a</span><br><span class="line">a 交 b -&gt; a &amp; b</span><br><span class="line">a 并 b -&gt; a | b</span><br><span class="line">a 差 b -&gt; a &amp; (~b)</span><br></pre></td></tr></table></figure>

<p>注意：整数在内存中是以补码的形式存在的，输出自然也是按照补码输出。</p>
<p>【例子】C#语言输出负数。</p>
<p>[ ]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        string s1 &#x3D; Convert.ToString(-3, 2);</span><br><span class="line">        Console.WriteLine(s1); </span><br><span class="line">        &#x2F;&#x2F; 11111111111111111111111111111101</span><br><span class="line">        </span><br><span class="line">        string s2 &#x3D; Convert.ToString(-3, 16);</span><br><span class="line">        Console.WriteLine(s2); </span><br><span class="line">        &#x2F;&#x2F; fffffffd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【例子】 Python 的<code>bin()</code> 输出。</p>
<p>[37]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(bin(3))  # 0b11</span><br><span class="line">print(bin(-3))  # -0b11</span><br><span class="line"></span><br><span class="line">print(bin(-3 &amp; 0xffffffff))  </span><br><span class="line"># 0b11111111111111111111111111111101</span><br><span class="line"></span><br><span class="line">print(bin(0xfffffffd))       </span><br><span class="line"># 0b11111111111111111111111111111101</span><br><span class="line"></span><br><span class="line">print(0xfffffffd)  # 4294967293</span><br><span class="line">0b11</span><br><span class="line">-0b11</span><br><span class="line">0b11111111111111111111111111111101</span><br><span class="line">0b11111111111111111111111111111101</span><br><span class="line">4294967293</span><br></pre></td></tr></table></figure>

<p>是不是很颠覆认知，我们从结果可以看出：</p>
<ul>
<li>Python中<code>bin</code>一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，巨坑。</li>
<li>Python中的整型是补码形式存储的。</li>
<li>Python中整型是不限制长度的不会超范围溢出。</li>
</ul>
<p>所以为了获得负数（十进制表示）的补码，需要手动将其和十六进制数<code>0xffffffff</code>进行按位与操作，再交给<code>bin()</code>进行输出，得到的才是负数的补码表示。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>刷算法题常用C++知识</title>
    <url>/2020/03/08/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8C-%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="输入-cin"><a href="#输入-cin" class="headerlink" title="输入(cin)"></a>输入(cin)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a&lt;&lt;b&lt;&lt;endl; &#x2F;&#x2F;给a,b赋值，输出a,b的值，换行</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>cin读入数据的效率略低于scanf。</li>
<li>cin读取数据，以空格、tab或换行作为分隔符。</li>
<li>例如(输入)：m n</li>
<li>a与b的值就分别是m和n,m与n之间的空格被直接忽略了。</li>
<li>如果使用<code>scanf(&quot;%c%c&quot;,&amp;a,&amp;b);</code>a与b的值就分别是m和空格,中间的空格被成功读取。<code>scanf(&quot;%c %c&quot;,&amp;a,&amp;b);</code>格式化输入后，a与b的值即为m和n。</li>
</ul>
<p><strong>总结：在对输入效率没有过高要求且数据是以空格、tab或换行作为分隔符德情况下，可以使用cin方便操作。</strong></p>
<h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串(string)"></a>字符串(string)</h3><h4 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char str1[10];</span><br><span class="line">scanf(&quot;%s&quot;,str1);&#x2F;&#x2F;遇到空格&#x2F;换行符为结束</span><br><span class="line">cin.getline(str1,10);&#x2F;&#x2F;读入一行</span><br><span class="line">string str2;</span><br><span class="line">cin&gt;&gt;str2;&#x2F;&#x2F;遇到空格&#x2F;换行符为结束</span><br><span class="line">getline(cin,str2);&#x2F;&#x2F;读入一行。注意使用的是string流的getline方法，因此需要导入string库</span><br></pre></td></tr></table></figure>

<h4 id="声明赋值"><a href="#声明赋值" class="headerlink" title="声明赋值"></a>声明赋值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s1,s2;&#x2F;&#x2F;声明空字符串s1,s2</span><br><span class="line">s1&#x3D;&quot;hello&quot;;&#x2F;&#x2F;给s1赋值</span><br><span class="line">s2&#x3D;s1;&#x2F;&#x2F;把s1的值赋给s2,s2的值为&quot;hello&quot;</span><br></pre></td></tr></table></figure>

<h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s3&#x3D;s1+s2;&#x2F;&#x2F;将s1,s2连接的值赋给s3,s3的值为&quot;hellohello&quot;</span><br></pre></td></tr></table></figure>

<h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><p>两种形式，substr(pos,n)和substr(pos)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s4&#x3D;s3.substr(0,3);&#x2F;&#x2F;s4的值为s3下标0开始往后3个字符，即&quot;hel&quot;</span><br><span class="line">string s5&#x3D;s3.substr(4);&#x2F;&#x2F;s4的值为s3下标4开始后面所有字符，即&quot;ohello&quot;</span><br></pre></td></tr></table></figure>

<h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><p>string重载了很多操作符，对字符串比较十分方便。<br>==,!=,&lt;,&gt;,&lt;=,&gt;=都可以用来做操作符两端字符串的比较，具体比较规则参照字符串的字典序大小。</p>
<h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><p>可以用s.length()或者s.size(),没有区别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1.length();&#x2F;&#x2F;5</span><br><span class="line">s1.size();&#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>

<h3 id="引用-amp"><a href="#引用-amp" class="headerlink" title="引用(&amp;)"></a>引用(&amp;)</h3><p>这里主要说一下引用和指针的区别。</p>
<ul>
<li>指针存储的是一块内存的地址，通过地址，可以访问这块内存；<br>引用则是一个变量的别名，在创建时必须初始化。</li>
<li>引用在初始化后不能改变，指针可以修改指向的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p&#x3D;&amp;a;&#x2F;&#x2F;初始化指针p,指向a的地址</span><br><span class="line">int &amp;r&#x3D;a;&#x2F;&#x2F;给a取一个别名r，可以说r就是a</span><br></pre></td></tr></table></figure>

<p>函数传参：以函数swap(a,b)为例。</p>
<ol>
<li><p>指针写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int *a,int *b)</span><br><span class="line">&#123;</span><br><span class="line">	int tmp;</span><br><span class="line">	tmp &#x3D; *a;</span><br><span class="line">	*a &#x3D; *b;</span><br><span class="line">	*b &#x3D; tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	int tmp;</span><br><span class="line">	tmp &#x3D; a;</span><br><span class="line">	a &#x3D; b;</span><br><span class="line">	b &#x3D; tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="常用STL容器"><a href="#常用STL容器" class="headerlink" title="常用STL容器"></a>常用STL容器</h3><p>&emsp;&emsp;C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<h4 id="vector-动态数组"><a href="#vector-动态数组" class="headerlink" title="vector(动态数组)"></a>vector(动态数组)</h4><p>头文件#include<vector></vector></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个int型的动态数组</span><br><span class="line">vector&lt;int&gt; vec;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;vec的大小</span><br><span class="line">vec.size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否为空</span><br><span class="line">vec.empty();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;vec的最大容量</span><br><span class="line">vec.max_size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;修改vec的大小</span><br><span class="line">vec.resize();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;末尾添加元素</span><br><span class="line">vec.push_back();      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;末尾删除元素</span><br><span class="line">vec.pop_back();      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下标访问</span><br><span class="line">vec[0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;迭代器遍历</span><br><span class="line">vector&lt;int&gt;::iterator it;</span><br><span class="line">for (it &#x3D; vec.begin(); it !&#x3D; vec.end(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;下标遍历</span><br><span class="line">for (unsigned i &#x3D; 0; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; vec[i]&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h4><p>头文件#include<set><br>在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。<br>比如先后向集合中插入4 3 3 2 2 1，最后集合中的结果为1 2 3 4。</set></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个int型的集合</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;set的大小</span><br><span class="line">s.size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否为空</span><br><span class="line">s.empty();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;set的最大容量</span><br><span class="line">s.max_size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向集合中添加元素</span><br><span class="line">insert(value);      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在集合中删除元素</span><br><span class="line">erase(value);      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回集合第一个元素的地址</span><br><span class="line">s.begin();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回集合最后一个元素的地址</span><br><span class="line">s.end();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;迭代器遍历</span><br><span class="line">set&lt;int&gt;::iterator it;</span><br><span class="line">for (it &#x3D; s.begin(); it !&#x3D; s.end(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;判断指定值是否存在于集合中</span><br><span class="line">if(s.find(value) &#x3D;&#x3D; s.end())</span><br><span class="line">	cout&lt;&lt;value&lt;&lt;&quot;不在集合中&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="map-映射"><a href="#map-映射" class="headerlink" title="map(映射)"></a>map(映射)</h4><p>头文件#include<map><br>自动建立Key(关键字)－ value(值)的对应。key 和 value可以是任意你需要的类型。</map></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个关键字为string型,值为int型的集合</span><br><span class="line">map&lt;string,int&gt; m;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;map的大小</span><br><span class="line">m.size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断是否为空</span><br><span class="line">m.empty();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向集合中添加元素</span><br><span class="line">m[&quot;test&quot;]&#x3D;2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在集合中删除元素</span><br><span class="line">m.erase(&quot;test&quot;);      </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回集合第一个元素的地址</span><br><span class="line">m.begin();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回集合最后一个元素的地址</span><br><span class="line">m.end();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;迭代器遍历</span><br><span class="line">map&lt;string,int&gt;::iterator it;</span><br><span class="line">for (it &#x3D; m.begin(); it !&#x3D; m.end(); it++)</span><br><span class="line">    cout &lt;&lt; it-&gt;first()&lt;&lt;it-&gt;second() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断指定关键字的数据是否存在于映射中</span><br><span class="line">if(m.find(key) &#x3D;&#x3D; m.end())</span><br><span class="line">	cout&lt;&lt;key&lt;&lt;&quot;不在映射中&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack(栈)"></a>stack(栈)</h4><p>头文件#include<stack></stack></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack&lt;int&gt; s;&#x2F;&#x2F;声明一个空栈</span><br><span class="line">s.size();&#x2F;&#x2F;栈大小</span><br><span class="line">s.push();&#x2F;&#x2F;压栈</span><br><span class="line">s.top();&#x2F;&#x2F;访问栈顶元素</span><br><span class="line">s.pop();&#x2F;&#x2F;移除栈顶元素</span><br></pre></td></tr></table></figure>

<h4 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue(队列)"></a>queue(队列)</h4><p>头文件#include<queue></queue></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue&lt;int&gt; q;&#x2F;&#x2F;声明一个空队列</span><br><span class="line">q.size();&#x2F;&#x2F;队大小</span><br><span class="line">q.push();&#x2F;&#x2F;入队</span><br><span class="line">q.front();&#x2F;&#x2F;访问队首元素</span><br><span class="line">q.back();&#x2F;&#x2F;访问队尾元素</span><br><span class="line">q.pop();&#x2F;&#x2F;移除队首元素</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/05/22/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>两两注意是相邻的两个元素的意思</li>
<li>如果有n个元素需要比较n-1次，每轮减少一次比较</li>
<li>既然叫冒泡排序，那就是从下玩往上两两比较，所以看上去就跟泡泡往上冒一样。</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;待排序数组</span><br><span class="line">int arr[] &#x3D;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int i,j,temp;</span><br><span class="line">	bool changed;</span><br><span class="line">	for(i&#x3D;0;i&lt;arr.length;i++)&#123;	</span><br><span class="line">		changed &#x3D;flase;</span><br><span class="line">		for(j&#x3D;0;j&lt;arr.length-i-1;j++)&#123;</span><br><span class="line">			if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">				changed&#x3D;true;</span><br><span class="line">				temp&#x3D;arr[j];</span><br><span class="line">				arr[j]&#x3D;arr[j+1];</span><br><span class="line">				arr[j+1]&#x3D;temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(!changed)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer-1-二维数组的查找</title>
    <url>/2020/03/03/%E5%89%91%E6%8C%87Offer-1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>&emsp;&emsp;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解决思路n次二分查找，时间复杂度为O(nlogn)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        int n&#x3D;0;   </span><br><span class="line">        for(int i&#x3D;0;i&lt;array.size();i++)&#123;</span><br><span class="line">            if(binarySearch(array[i],0,array[i].size()-1,target)!&#x3D;-1)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;二分查找</span><br><span class="line">    int binarySearch(vector&lt;int&gt; arr,int begin,int end,int target)&#123;</span><br><span class="line">        int mid;</span><br><span class="line">        while(begin&lt;&#x3D;end)&#123;</span><br><span class="line">            mid&#x3D;(begin+end)&#x2F;2;</span><br><span class="line">            if(arr[mid]&#x3D;&#x3D;target)</span><br><span class="line">                return mid;</span><br><span class="line">            if(arr[mid]&gt;target)</span><br><span class="line">                end &#x3D; mid-1;</span><br><span class="line">            if(arr[mid]&lt;target)</span><br><span class="line">                begin &#x3D; mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-11-二进制中1的个数</title>
    <url>/2020/03/08/%E5%89%91%E6%8C%87Offer-11-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        int flag &#x3D; 1;&#x2F;&#x2F;从低位到高位统计</span><br><span class="line">        while (flag !&#x3D; 0) &#123;</span><br><span class="line">            if ((n &amp; flag) !&#x3D; 0) </span><br><span class="line">                count++;</span><br><span class="line">            flag&#x3D;flag &lt;&lt; 1;&#x2F;&#x2F;要赋值</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-10-矩形覆盖</title>
    <url>/2020/03/08/%E5%89%91%E6%8C%87Offer-10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>比如n=3时，2*3的矩形块有3种覆盖方法：</p>
<img src="/2020/03/08/%E5%89%91%E6%8C%87Offer-10-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/1.png" style="zoom:50%;">

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;总结每一项之间的关系——斐波那契数列递归法</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">        if(number&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(number&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        if(number&#x3D;&#x3D;2)</span><br><span class="line">            return 2;</span><br><span class="line">        return rectCover(number-1)+rectCover(number-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;迭代法</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rectCover(int number) &#123;</span><br><span class="line">        if(number&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(number&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        if(number&#x3D;&#x3D;2)</span><br><span class="line">            return 2;</span><br><span class="line">        int result&#x3D;0,x&#x3D;1,y&#x3D;2;</span><br><span class="line">        while(number&gt;2)&#123;</span><br><span class="line">            result&#x3D;x+y;</span><br><span class="line">            x&#x3D;y;</span><br><span class="line">            y&#x3D;result;</span><br><span class="line">            number--;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-12-数值的整数次方</title>
    <url>/2020/03/08/%E5%89%91%E6%8C%87Offer-12-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        double result &#x3D;1;</span><br><span class="line">        bool flag&#x3D;true;&#x2F;&#x2F;标志exponent的正负,true为正</span><br><span class="line">        if(exponent&#x3D;&#x3D;0)</span><br><span class="line">            return result;</span><br><span class="line">        </span><br><span class="line">        if(exponent&lt;0)&#123;</span><br><span class="line">            exponent &#x3D;-exponent;</span><br><span class="line">            flag&#x3D;false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(exponent&gt;0)&#123;</span><br><span class="line">            result*&#x3D;base;</span><br><span class="line">            exponent--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!flag)</span><br><span class="line">            result&#x3D;1&#x2F;result;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-13-调整数组顺序使奇数位于偶数前面</title>
    <url>/2020/03/08/%E5%89%91%E6%8C%87Offer-13-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：两个队列分别存储奇数和偶数</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt; &amp;array) &#123;</span><br><span class="line">        queue&lt;int&gt; odd;</span><br><span class="line">        queue&lt;int&gt; even;</span><br><span class="line">        int i;</span><br><span class="line">        for(i&#x3D;0;i&lt;array.size();i++)&#123;</span><br><span class="line">            if(array[i]%2)</span><br><span class="line">                &#x2F;&#x2F;奇数</span><br><span class="line">                odd.push(array[i]);</span><br><span class="line">            else</span><br><span class="line">                even.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i&#x3D;0;</span><br><span class="line">        while(!odd.empty())&#123;</span><br><span class="line">            array[i]&#x3D;odd.front();</span><br><span class="line">            odd.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!even.empty())&#123;</span><br><span class="line">            array[i]&#x3D;even.front();</span><br><span class="line">            even.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-15-反转链表</title>
    <url>/2020/03/08/%E5%89%91%E6%8C%87Offer-15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">        ListNode* pre&#x3D;0,*next&#x3D;0;</span><br><span class="line">        while(pHead!&#x3D;NULL)&#123;</span><br><span class="line">            next&#x3D;pHead-&gt;next;&#x2F;&#x2F;记录当前节点的next节点</span><br><span class="line">            pHead-&gt;next&#x3D;pre;&#x2F;&#x2F;反转当前节点的next指针</span><br><span class="line">            pre&#x3D;pHead;&#x2F;&#x2F;为下一节点记录节点</span><br><span class="line">            pHead&#x3D;next;&#x2F;&#x2F;后移</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-14-链表中倒数第k个结点</title>
    <url>/2020/03/08/%E5%89%91%E6%8C%87Offer-14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;利用双指针间隔k步,</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123;</span><br><span class="line">        &#x2F;&#x2F;对空链的处理，倒数第0个数的处理</span><br><span class="line">        if(pListHead&#x3D;&#x3D;NULL||k&lt;1)</span><br><span class="line">            return NULL;</span><br><span class="line">        ListNode* temp &#x3D; pListHead;</span><br><span class="line">        ListNode* result &#x3D; pListHead;</span><br><span class="line">        </span><br><span class="line">        while(k&gt;0)&#123;</span><br><span class="line">        	&#x2F;&#x2F;当移动中遇到节点数不够</span><br><span class="line">            if(temp&#x3D;&#x3D;0)</span><br><span class="line">                return NULL;</span><br><span class="line">            temp&#x3D;temp-&gt;next;</span><br><span class="line">            k--;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(temp!&#x3D;0)&#123;</span><br><span class="line">            temp&#x3D;temp-&gt;next;</span><br><span class="line">            result&#x3D;result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-18-二叉树的镜像</title>
    <url>/2020/03/10/%E5%89%91%E6%8C%87Offer-18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;递归</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        if(!pRoot)return;</span><br><span class="line">        &#x2F;&#x2F;需要临时指针变量存储节点</span><br><span class="line">        TreeNode *temp &#x3D; pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left &#x3D; pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right &#x3D; temp;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-16-合并两个排序的链表</title>
    <url>/2020/03/08/%E5%89%91%E6%8C%87Offer-16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;非递归版</span><br><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;归并排序：升序</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* result&#x3D; new ListNode(-1);</span><br><span class="line">        ListNode* current &#x3D; result;</span><br><span class="line">        while(pHead1!&#x3D;0&amp;&amp;pHead2!&#x3D;0)&#123;</span><br><span class="line">            if(pHead1-&gt;val&lt;pHead2-&gt;val)&#123;</span><br><span class="line">                current-&gt;next &#x3D; pHead1;</span><br><span class="line">                pHead1&#x3D;pHead1-&gt;next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                current-&gt;next &#x3D; pHead2;</span><br><span class="line">                pHead2&#x3D;pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            current&#x3D;current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pHead1!&#x3D;0)</span><br><span class="line">            current-&gt;next &#x3D; pHead1;</span><br><span class="line">        </span><br><span class="line">        if(pHead2!&#x3D;0)</span><br><span class="line">            current-&gt;next &#x3D; pHead2;</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F;返回的链表不包括头节点</span><br><span class="line">        return result-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;递归版</span><br><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct ListNode *next;</span><br><span class="line">	ListNode(int x) :</span><br><span class="line">			val(x), next(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;归并排序：升序</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        if(pHead1&#x3D;&#x3D;0)return pHead2;</span><br><span class="line">        if(pHead2&#x3D;&#x3D;0)return pHead1;</span><br><span class="line">        </span><br><span class="line">        if(pHead1-&gt;val&lt;pHead2-&gt;val)&#123;</span><br><span class="line">            pHead1-&gt;next &#x3D; Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">            return pHead1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pHead2-&gt;next &#x3D; Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">            return pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-17-树的子结构</title>
    <url>/2020/03/10/%E5%89%91%E6%8C%87Offer-17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;先找到根节点相同的顶点后，往后开始匹配每个顶点，递归</span><br><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;判断pRoot2是不是pRoot1的子结构</span><br><span class="line">    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        bool result &#x3D;false;</span><br><span class="line">        if(pRoot1!&#x3D;0&amp;&amp;pRoot2!&#x3D;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;先找到顶点相同的点,判断是否为子结构</span><br><span class="line">            if(pRoot1-&gt;val&#x3D;&#x3D;pRoot2-&gt;val)</span><br><span class="line">                result&#x3D;isSubTree(pRoot1,pRoot2);</span><br><span class="line">                </span><br><span class="line">             &#x2F;&#x2F;找左子树</span><br><span class="line">            if(!result)</span><br><span class="line">                result &#x3D; HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;找右子树</span><br><span class="line">            if(!result)</span><br><span class="line">                result &#x3D; HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;先序遍历看是否满足</span><br><span class="line">    bool isSubTree(TreeNode* pRoot1, TreeNode* pRoot2)&#123;</span><br><span class="line">        &#x2F;&#x2F;右子树全部匹配玩</span><br><span class="line">        if(pRoot2&#x3D;&#x3D;0)</span><br><span class="line">            return true;</span><br><span class="line">        &#x2F;&#x2F;左边已经遍历完而右边还没有遍历完，则匹配失败</span><br><span class="line">        if(pRoot1&#x3D;&#x3D;0)</span><br><span class="line">            return false;</span><br><span class="line">        </span><br><span class="line">        if(pRoot1-&gt;val !&#x3D;pRoot2-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        &#x2F;&#x2F;返回递归比较左子树和右子树的结果</span><br><span class="line">        return isSubTree(pRoot1-&gt;left, pRoot2-&gt;left)&amp;&amp;</span><br><span class="line">        	isSubTree(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-2-替换空格</title>
    <url>/2020/03/03/%E5%89%91%E6%8C%87Offer-2-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>&emsp;&emsp;请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strlen(); 计算字符串长度，返回长度不包括结束符\0,仅为字符个数</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">常用的字符串初始化格式</span><br><span class="line">char str[100] &#x3D; &quot;We are happy.&quot;;</span><br><span class="line">int length &#x3D; strlen(str);</span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>&emsp;&emsp;先遍历次字符串， 统计出字符串中空格的总数，由此计算出替换之后的字符串的总长度。每替换个空格， 长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。我们还是以前面的字符串<code>&quot;We are happy.&quot;</code>为例，<code>&quot;We are happy.&quot;</code><strong>这个字符串的长度是13(不包括结尾符号’\0’)</strong>，里面有两个空格，因此替换之后字符串的长度是17。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;length表示的是非结束符的字符个数</span><br><span class="line">	void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        &#x2F;&#x2F;统计空格数</span><br><span class="line">        int i,count&#x3D;0;</span><br><span class="line">        for(i&#x3D;0;i&lt;length;i++)&#123;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39; &#39;)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;注：length是包括字符串结束符\0的长度的</span><br><span class="line">        int newLen &#x3D; length+2*count;</span><br><span class="line">        str[newLen--] &#x3D; &#39;\0&#39;;</span><br><span class="line">        for(i&#x3D;length-1 ;i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">            if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">                str[newLen--] &#x3D; &#39;0&#39;;</span><br><span class="line">                str[newLen--] &#x3D; &#39;2&#39;;</span><br><span class="line">                str[newLen--] &#x3D; &#39;%&#39;;              </span><br><span class="line">                if(--count&#x3D;&#x3D;0)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;else</span><br><span class="line">                str[newLen--] &#x3D; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-19-顺时针打印矩阵</title>
    <url>/2020/03/10/%E5%89%91%E6%8C%87Offer-19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*解题思路：顺时针打印就是按圈数循环打印，一圈包含两行或者两列，在打印的时候会出现某一圈中只包含一行，要判断从左向右打印和从右向左打印的时候是否会出现重复打印，同样只包含一列时，要判断从上向下打印和从下向上打印的时候是否会出现重复打印的情况*&#x2F;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-22-从上往下打印二叉树</title>
    <url>/2020/03/11/%E5%89%91%E6%8C%87Offer-22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路二叉树的层序遍历</span><br><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;&#x2F;&#x2F;结果集</span><br><span class="line">        if(!root)</span><br><span class="line">            return res;</span><br><span class="line">        TreeNode* temp &#x3D; root;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        </span><br><span class="line">        q.push(temp);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            temp &#x3D; q.front();</span><br><span class="line">            res.push_back(temp-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">            if(temp-&gt;left!&#x3D;NULL)</span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">            if(temp-&gt;right!&#x3D;NULL)</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-20-包含min函数的栈</title>
    <url>/2020/03/10/%E5%89%91%E6%8C%87Offer-20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;额外开辟一个栈存储每层的最小值</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;int&gt; stk1;</span><br><span class="line">    stack&lt;int&gt; min_stk2;&#x2F;&#x2F;存储最小栈</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        stk1.push(value);</span><br><span class="line">        if(!min_stk2.empty())&#123;</span><br><span class="line">            int top &#x3D; min_stk2.top();</span><br><span class="line">            if(value&lt;top)</span><br><span class="line">                min_stk2.push(value);</span><br><span class="line">            else</span><br><span class="line">                min_stk2.push(top);</span><br><span class="line">        &#125;else</span><br><span class="line">           min_stk2.push(value); </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        stk1.pop();</span><br><span class="line">        min_stk2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stk1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return min_stk2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-3-从尾到头打印链表</title>
    <url>/2020/03/04/%E5%89%91%E6%8C%87Offer-3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路：利用栈的先进后出性质</span><br><span class="line">&#x2F;**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;当作是没有头节点</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; arr;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        ListNode* temp&#x3D;head;</span><br><span class="line">        while(temp!&#x3D;0)&#123;</span><br><span class="line">            stk.push(temp-&gt;val);</span><br><span class="line">            temp&#x3D;temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!stk.empty())&#123;</span><br><span class="line">            arr.push_back(stk.top());</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-23-链表中环的入口结点</title>
    <url>/2020/03/13/%E5%89%91%E6%8C%87Offer-23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><img src="/2020/03/13/%E5%89%91%E6%8C%87Offer-23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/1.jpg" style="zoom:50%;">

<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;a&#x3D;(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离&#x3D;相遇点到环入口的距离+（k-1）圈环长度。其中	k&gt;&#x3D;1,所以k-1&gt;&#x3D;0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</span><br><span class="line">&#x2F;*</span><br><span class="line">struct ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    ListNode(int x) :</span><br><span class="line">        val(x), next(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* EntryNodeOfLoop(ListNode* pHead)</span><br><span class="line">    &#123;    </span><br><span class="line">        if(!pHead)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;设置快慢节点</span><br><span class="line">        ListNode* Fp&#x3D;pHead,*Sp&#x3D;pHead;</span><br><span class="line">        &#x2F;&#x2F;1.判断有无环</span><br><span class="line">        while(Fp!&#x3D;0&amp;&amp;Fp-&gt;next!&#x3D;0)&#123;</span><br><span class="line">            Fp&#x3D;Fp-&gt;next-&gt;next;</span><br><span class="line">            Sp&#x3D;Sp-&gt;next;</span><br><span class="line">            if(Fp&#x3D;&#x3D;Sp)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;快指针为空，则无环</span><br><span class="line">        if(!Fp||!Fp-&gt;next)</span><br><span class="line">            return 0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;再将快指针指向链头，必定可以相遇</span><br><span class="line">        Fp&#x3D;pHead;</span><br><span class="line">        while(Fp!&#x3D;Sp)&#123;</span><br><span class="line">            Fp&#x3D;Fp-&gt;next;</span><br><span class="line">            Sp&#x3D;Sp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return Fp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-5-用两个栈实现队列</title>
    <url>/2020/03/04/%E5%89%91%E6%8C%87Offer-5-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;注意：只有当第二个栈为空时，才能从第一个栈pop到第二个栈中</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        &#x2F;&#x2F;不为空</span><br><span class="line">        if(!stack2.empty())&#123;</span><br><span class="line">            int out &#x3D; stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            return out;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            int out &#x3D; stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            return out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; stack1;</span><br><span class="line">    stack&lt;int&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-4-重建二叉树</title>
    <url>/2020/03/04/%E5%89%91%E6%8C%87Offer-4-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>&emsp;&emsp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路：根据前序序列第一个结点确定根结点</span><br><span class="line">	 根据根结点在中序序列中的位置分割出左右两个子序列</span><br><span class="line">	 对左子树和右子树分别递归使用同样的方法继续分解</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123;</span><br><span class="line">        &#x2F;&#x2F;递归终止边界</span><br><span class="line">        if(vin.size()&#x3D;&#x3D;0)</span><br><span class="line">            return NULL;</span><br><span class="line">        TreeNode* root &#x3D; new TreeNode(pre[0]);</span><br><span class="line">        int i,bound;&#x2F;&#x2F;边界</span><br><span class="line">        for(i&#x3D;0;i&lt;vin.size();i++)&#123;</span><br><span class="line">            if(pre[0]&#x3D;&#x3D;vin[i])&#123;</span><br><span class="line">                bound&#x3D;i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将原数组分割成两部分（左右子树序列）</span><br><span class="line">        vector&lt;int&gt; l_pre;</span><br><span class="line">        vector&lt;int&gt; r_pre;</span><br><span class="line">        vector&lt;int&gt; l_vin;</span><br><span class="line">        vector&lt;int&gt; r_vin;</span><br><span class="line">        &#x2F;&#x2F;左子树的中序</span><br><span class="line">        for(i&#x3D;0;i&lt;bound;i++)&#123;</span><br><span class="line">            l_pre.push_back(pre[i+1]);</span><br><span class="line">            l_vin.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F;右子树的中序</span><br><span class="line">        for(i&#x3D;bound+1;i&lt;vin.size();i++)&#123;</span><br><span class="line">            r_pre.push_back(pre[i]);</span><br><span class="line">            r_vin.push_back(vin[i]);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        root-&gt;left &#x3D; reConstructBinaryTree(l_pre,l_vin);</span><br><span class="line">        root-&gt;right &#x3D; reConstructBinaryTree(r_pre,r_vin);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-6-旋转数组的最小数字</title>
    <url>/2020/03/04/%E5%89%91%E6%8C%87Offer-6-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</span><br><span class="line">        if(rotateArray.size()&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        int bound&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;rotateArray.size();i++)&#123;</span><br><span class="line">            if(rotateArray[i]&gt;rotateArray[i+1])&#123;</span><br><span class="line">                bound&#x3D;i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;vector的转置函数</span><br><span class="line">        reverse(rotateArray.begin(),rotateArray.begin()+bound);</span><br><span class="line">        reverse(rotateArray.begin()+bound+1,rotateArray.end());</span><br><span class="line">        reverse(rotateArray.begin(),rotateArray.end());</span><br><span class="line">        return rotateArray[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>单源最短路径</title>
    <url>/2020/05/09/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<img src="/2020/05/09/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/无权图单源最短路bfs.png" style="zoom:50%;">

<img src="/2020/05/09/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/有权图单源最短路.png" style="zoom:50%;">

]]></content>
      <categories>
        <category>最短路径</category>
      </categories>
  </entry>
  <entry>
    <title>剑指Offer-7-斐波那契数列</title>
    <url>/2020/03/04/%E5%89%91%E6%8C%87Offer-7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>&emsp;&emsp;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;尾递归版</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;这个数列从第3项开始，每一项都等于前两项之和。</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;非递归实现</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;这个数列从第3项开始，每一项都等于前两项之和。</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        int num&#x3D;0,num1&#x3D;1,num2&#x3D;1;</span><br><span class="line">        while(n&gt;2)&#123;</span><br><span class="line">        	num &#x3D; num1+num2;</span><br><span class="line">        	num1&#x3D;num2;</span><br><span class="line">        	num2&#x3D;num;</span><br><span class="line">        	n--;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-8-跳台阶</title>
    <url>/2020/03/04/%E5%89%91%E6%8C%87Offer-8-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;递归版(与斐波那契数列思路类似)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 思路：当前台阶的跳法总数&#x3D;当前台阶后退一阶的台阶的跳法总数+当前台阶后退二阶的台阶的跳法总数</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        if(number&#x3D;&#x3D;2)</span><br><span class="line">            return 2;</span><br><span class="line">        return jumpFloor(number-1)+jumpFloor(number-2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;非递归版</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F; 思路：当前台阶的跳法总数&#x3D;当前台阶后退一阶的台阶的跳法总数+当前台阶后退二阶的台阶的跳法总数</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        if(number&#x3D;&#x3D;1)</span><br><span class="line">            return 1;</span><br><span class="line">        if(number&#x3D;&#x3D;2)</span><br><span class="line">            return 2;</span><br><span class="line">        int num&#x3D;0,num1&#x3D;1,num2&#x3D;2;</span><br><span class="line">        while(number&gt;2)&#123;</span><br><span class="line">            num&#x3D;num1+num2;</span><br><span class="line">            num1&#x3D;num2;</span><br><span class="line">            num2&#x3D;num;</span><br><span class="line">            number--;</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-9-变态跳台阶</title>
    <url>/2020/03/05/%E5%89%91%E6%8C%87Offer-9-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;思路：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级</span><br><span class="line">	   跳1级，剩下n-1级，则剩下跳法是f(n-1)</span><br><span class="line">	   跳2级，剩下n-2级，则剩下跳法是f(n-2)</span><br><span class="line">	   所以f(n)&#x3D;f(n-1)+f(n-2)+...+f(1)</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;&#x2F;动态规划</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">       int* A &#x3D; new int[number+1];&#x2F;&#x2F;数组每一位对应跳法数</span><br><span class="line"></span><br><span class="line">	    int i, j;</span><br><span class="line">	    A[0] &#x3D; 0;&#x2F;&#x2F;initialization</span><br><span class="line">	    A[1] &#x3D; 1;</span><br><span class="line">	    for (i &#x3D; 2;i &lt;&#x3D; number;i++) &#123;</span><br><span class="line">            A[i] &#x3D; 1;&#x2F;&#x2F;由于可以一次跳级台阶，所以默认有一种跳法</span><br><span class="line">		    for (j &#x3D; 0;j &lt; i;j++)</span><br><span class="line">			    A[i] +&#x3D; A[j];</span><br><span class="line">	    &#125;</span><br><span class="line">	    return A[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>同步和异步</title>
    <url>/2020/05/22/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>同步和异步关注的是<strong>消息通信机制</strong>，所谓同步就是在发出一个调用时，在没有得到结果之前，该调用就不能返回；但是一旦调用返回，就得到返回值了。</p>
<p>换句话说就是有调用者主动等待这个调用的结果。</p>
<p>而异步则是相反，“调用再发出之后”，这个调用就直接返回了，所有没有返回结果。换句话说当这个异步过程调用发生之后，调用者不会立刻获得结果。而是在调用发出之后，“被调用者“通过状态、通知来通知调用者，或者通过回调函数来处理这个调用。</p>
<p>典型的异步编程模型例如Node.js</p>
]]></content>
      <tags>
        <tag>消息通信机制</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/05/07/%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>连通图</p>
<blockquote>
<p>图中任意两个顶点都存在路径，即为连通</p>
</blockquote>
</li>
<li><p>非连通图</p>
<blockquote>
<p>图中存在两个顶点没有路径相连通</p>
</blockquote>
</li>
<li><p>连通分量</p>
<blockquote>
<p>极大连通子图，包含最多顶点数且连通的子图；极大表示包含所有边，极小表示保证连通性的最少的边</p>
</blockquote>
</li>
<li><p>生成树</p>
<blockquote>
<p>包含连通图中的全部顶点的极小连通子图</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连通图--&gt;生成树</span><br><span class="line">非连通图--&gt;多棵生成树构成的生成森林</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>基本数学问题</title>
    <url>/2020/03/24/%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">	if(b&#x3D;0)return a;</span><br><span class="line">	return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">	return !b? a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>a和b的最小公倍数是ab的积除他们的最大公约数：ab/d</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lcm(int a,int b)&#123;</span><br><span class="line">	int d &#x3D; gcd(a,b);&#x2F;&#x2F;计算最大公约数</span><br><span class="line">	return a&#x2F;d*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="素数-质数"><a href="#素数-质数" class="headerlink" title="素数/质数"></a>素数/质数</h3><p>素数又称质数，指除了1和自身之外，不能被其他整数整除的一类数，否则其为合数。特别注意的是1既不是素数也不是合数</p>
<h4 id="素数的判断"><a href="#素数的判断" class="headerlink" title="素数的判断"></a>素数的判断</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool isPrime(int n)&#123;</span><br><span class="line">	if(n&lt;&#x3D;1)return false;</span><br><span class="line">	for(int i&#x3D;2;i*i&lt;&#x3D;n;i++)</span><br><span class="line">		if(n%i&#x3D;&#x3D;0) return false;</span><br><span class="line">	return ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="素数表的获取"><a href="#素数表的获取" class="headerlink" title="素数表的获取"></a>素数表的获取</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;time complexity O(n根号n)</span><br><span class="line">const int maxn &#x3D;101;&#x2F;&#x2F;表长</span><br><span class="line">int prime[maxn],pNum&#x3D;0;&#x2F;&#x2F;prime数组存放所有素数，pNum为素数的个数</span><br><span class="line">bool p[maxn]&#x3D;&#123;0&#125;;</span><br><span class="line">void find_prime()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;maxn;i++)&#123;</span><br><span class="line">		if(isPrime(i)&#x3D;&#x3D;true)&#123;</span><br><span class="line">			prime[pNum++]&#x3D;i;</span><br><span class="line">			p[i]&#x3D;true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;埃式筛法</span><br><span class="line">&#x2F;&#x2F;time complexity O(nloglogn)</span><br><span class="line">const int maxn &#x3D;101;&#x2F;&#x2F;表长</span><br><span class="line">int prime[maxn],pNum&#x3D;0;&#x2F;&#x2F;prime数组存放所有素数，pNum为素数的个数</span><br><span class="line">bool p[maxn]&#x3D;&#123;0&#125;;&#x2F;&#x2F;如果i为素数，p[i]为false</span><br><span class="line">void find_prime()&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;maxn;i++)&#123;</span><br><span class="line">		if(p[i]&#x3D;&#x3D;false)&#123;</span><br><span class="line">			prime[pNum++]&#x3D;i;</span><br><span class="line">			for(int j&#x3D;i+i;j&lt;maxn;j+&#x3D;i)&#123;</span><br><span class="line">				&#x2F;&#x2F;筛去所有i的倍数，循环条件不能写成j&lt;&#x3D;maxn</span><br><span class="line">				p[j]&#x3D;true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数学问题</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Kmp算法</title>
    <url>/2020/03/22/%E5%AD%A6%E4%B9%A0Kmp%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;KMP算法是用于在文本串中判断是否存在子串（或称为模式串），并返回模式串在文本串中出现的位置的字符串算法。例如，文本串为<code>text=&quot;caniwaitforyourheart&quot;</code>，模式串为<code>pattern=&quot;wait&quot;</code>。我们可以很直观的看到文本串中是包含模式串的，且所在文本串的索引值为4。</p>
<h3 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>枚举文本串的起始位置i，然后从该位开始逐位与模式串进行对比</p>
<blockquote>
<ul>
<li>若每一位都相同，则匹配成功</li>
<li>若某一位出现不同，则起始位置继续变为i+1，而模式串索引则从头开始匹配</li>
</ul>
</blockquote>
<p>这种暴力的枚举法当文本串text很长时效率会变得很低，时间复杂度为<code>O(n*m)</code>，n和m为text和pattern的长度</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;暴力算法</span><br><span class="line">&#x2F;&#x2F;返回模式串在文本串中出现的位置</span><br><span class="line">&#x2F;&#x2F;不存在则返回-1</span><br><span class="line">int count(char s[], char t[])</span><br><span class="line">&#123;	</span><br><span class="line">	int i, j;</span><br><span class="line">	&#x2F;&#x2F;枚举文本串</span><br><span class="line">	for (i &#x3D; 0, j &#x3D; 0;s[i] !&#x3D; &#39;\0&#39;;i++) &#123;</span><br><span class="line">		if (s[i] &#x3D;&#x3D; t[j]) &#123;</span><br><span class="line">			int _i &#x3D; i, _j &#x3D; j;</span><br><span class="line">			while (s[_i] &#x3D;&#x3D; t[_j]&amp;&amp; s[_i] !&#x3D; &#39;\0&#39;&amp;&amp; t[_j] !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">				_i++;</span><br><span class="line">				_j++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (t[_j] &#x3D;&#x3D; &#39;\0&#39;)</span><br><span class="line">				return i;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			j &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP登场"><a href="#KMP登场" class="headerlink" title="KMP登场"></a>KMP登场</h3><h4 id="next-数组"><a href="#next-数组" class="headerlink" title="next[]数组"></a>next[]数组</h4><p>关于获取next[]数组最重要的就是理解i节点的回退。需要关注的是若i、j索引所代表的字符若一直不相同，i节点的回退的重点在哪。我是这么理解的，因为next[]数组的0位置默认是0，不会对其有什么操作，且又是数组的起始位置，当i一直减少到0时则视为重点，跳出while循环，这一点会在代码中有所体现；同时，当i、j索引所代表的字符相同的时候，i节点后移，刚好满足记录相同前缀的下一个节点所引。总之闲话不多说，上代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造next数组</span><br><span class="line">void gen_next(char c[],int next[]) &#123;</span><br><span class="line">	int i&#x3D;0, j;&#x2F;&#x2F;i在前，j在后</span><br><span class="line">	next[0] &#x3D; 0;</span><br><span class="line">	for (j &#x3D; 1;c[j] !&#x3D; &#39;\0&#39;;j++) &#123;</span><br><span class="line">		&#x2F;&#x2F;当i&#x3D;0初始位置时，且i、j索引位置的字符都不相等，则毫无疑问next[j]&#x3D;0</span><br><span class="line">		&#x2F;&#x2F;这也是一个i索引回溯的while循环出口</span><br><span class="line">		while (i!&#x3D;0&amp;&amp;c[i] !&#x3D; c[j]) </span><br><span class="line">			i &#x3D; next[i - 1];</span><br><span class="line">			</span><br><span class="line">		&#x2F;&#x2F;当俩字符比较相同，i索引相加</span><br><span class="line">		if (c[i] &#x3D;&#x3D; c[j]) </span><br><span class="line">			i++;</span><br><span class="line">		</span><br><span class="line">		next[j] &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/03/22/%E5%AD%A6%E4%B9%A0Kmp%E7%AE%97%E6%B3%95/微信图片_20200322202200.jpg" style="zoom: 50%;">

<h4 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h4><ul>
<li>元素相同指针同时后移</li>
<li>元素不同，则令j=next[j-1]，找到相同前缀的用于比较的下个next索引，并与文本串的i索引位置继续比较；若仍不同则重复此操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;代码与构造next数组相似</span><br><span class="line">&#x2F;&#x2F;求解next数组的过程其实就是模式串pattern进行自我匹配的过程</span><br><span class="line">bool kmp(char str1[],char str2[]) &#123;</span><br><span class="line"></span><br><span class="line">	int* next &#x3D; new int[strlen(str2)];</span><br><span class="line">	gen_next(str2,next);</span><br><span class="line">	int i &#x3D; 0, j;</span><br><span class="line">	for (j &#x3D; 0;str1[j] !&#x3D; &#39;\0&#39;;j++) &#123;</span><br><span class="line">		while (i!&#x3D;0&amp;&amp; str1[j]!&#x3D;str2[i]) </span><br><span class="line">			i &#x3D; next[i - 1];</span><br><span class="line">		</span><br><span class="line">		if (str1[j] &#x3D;&#x3D; str2[i])</span><br><span class="line">			i++;</span><br><span class="line"></span><br><span class="line">		if (str2[i] &#x3D;&#x3D; &#39;\0&#39;)</span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>&emsp;&emsp;可能有人会问，既然for循环中每个j都有一个while循环，这样i回退的次数可能不可预计，为什么KMP算法的复杂度时O（n+m）呢？</p>
<p>&emsp;&emsp;首先整个for循环中j是不断加1的，所以在整个过程中j的变化次数是O（n）级别，这个应该没有疑问。接下来考虑i的变化，我们注意到i只会在一行中增加，并且每次只加1，这样在整个过程中i最多只会增加n次；而其他地方的i都是不断减少的由于i最小不会小于0，因此在整个过程中i最多只能减少n次，因此i在整个过程中的变化过程是O（N）级别的。</p>
]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/04/24/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>并查集是一种维护集合的数据结构，他的名字中”并”、”查”、”集”分别取自Union、Find、Set三个单词</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><blockquote>
<p>将自身的父节点指向自己</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;&#x3D;N;i++)</span><br><span class="line">	father[i]&#x3D;i;</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><blockquote>
<p><code>findFather(int x)</code>函数返回查找元素的x所在集合的根节点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int findFather(int x)&#123;</span><br><span class="line">	while(x!&#x3D;father[x])&#x2F;&#x2F;若不是根节点则一直循环</span><br><span class="line">		x&#x3D;father[x];</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><ol>
<li>先判断两个节点是否属于同一个集合，若是则无需合并</li>
<li>若不属于一个集合，则将任意一个集合的根节点赋给另外一个集合的根节点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void union(int x,int y)&#123;</span><br><span class="line">	int fx &#x3D; findFather(x);</span><br><span class="line">	int fy &#x3D; findFather(y);</span><br><span class="line">	if(fx!&#x3D;fy)</span><br><span class="line">		father[fx]&#x3D;fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上就是并查集的所有操作啦！</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>微服务搭建</title>
    <url>/2020/02/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="搭建微服务笔记"><a href="#搭建微服务笔记" class="headerlink" title="搭建微服务笔记"></a>搭建微服务笔记</h1><p>##1.创建maven-quickstart</p>
<h2 id="eureka自我保护与AP原则"><a href="#eureka自我保护与AP原则" class="headerlink" title="eureka自我保护与AP原则"></a>eureka自我保护与AP原则</h2><blockquote>
<p>eureka的自我保护</p>
<blockquote>
<p>某时刻一个微服务不可用了，eureka不会立刻清理，依旧会对微服务的信息进行保存<br>或者当微服务的心跳失去连接，也不会立刻清理<br>可以将自我保护机制禁用（server端）</p>
</blockquote>
</blockquote>
<h2 id="eureka集群配置"><a href="#eureka集群配置" class="headerlink" title="eureka集群配置"></a>eureka集群配置</h2><p>在单机版的基础上，服务器的路径要更多<br>client的指定的服务器的地址为集群所有的服务器的地址</p>
<p>eureka与zookeeper的优势比较</p>
<p>Netflix在设计eureka时遵循的就是AP原则<br>C:Consistency（强一致）<br>A:Availability（可用性）<br>P:Partition tolerance（分区容错性）</p>
<p>zookeeper保证cp{要通过选出leader}<br>eureka的各个结点平等</p>
<h2 id="eureka的自我保护机制"><a href="#eureka的自我保护机制" class="headerlink" title="eureka的自我保护机制"></a>eureka的自我保护机制</h2><h3 id="如果在15分钟内超过85-的结点都没有正常的心跳，那么eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况："><a href="#如果在15分钟内超过85-的结点都没有正常的心跳，那么eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：" class="headerlink" title="如果在15分钟内超过85%的结点都没有正常的心跳，那么eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况："></a>如果在15分钟内超过85%的结点都没有正常的心跳，那么eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</h3><blockquote>
<blockquote>
<p>1.eureka不再从注册中心列表中一处因为长时间没收到心跳而应该国企的服务<br>2.eureka依然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（保证当前节点依然可用）<br>3.当网络稳定时，当前实例新的注册信息会被同步到其他节点中</p>
</blockquote>
</blockquote>
<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><h3 id="客户端的软件负载均衡算法"><a href="#客户端的软件负载均衡算法" class="headerlink" title="客户端的软件负载均衡算法"></a>客户端的软件负载均衡算法</h3><h2 id="ribbon的配置"><a href="#ribbon的配置" class="headerlink" title="ribbon的配置"></a>ribbon的配置</h2><p>1.添加pom依赖<br>2.修改application.yml 追加eureka的服务注册地址<br>3.对restTemplate上添加@loadbalance注解<br>4.主启动类添加@EnableEurekaClient</p>
<p>NOTES:<br>1.微服务可以允许有自己的数据库；<br>2.同时微服务的服务名不允许有下划线，否则无法通过微服务名调用服务。<br>3.服务注册完消费端微服务需要重启去获取新的服务注册信息</p>
<h2 id="ribbon自定义"><a href="#ribbon自定义" class="headerlink" title="ribbon自定义"></a>ribbon自定义</h2><p>1.消费者主启动类添加注解@RibbonClient(name=”微服务名”，cnfiguration=自定义负载均衡规则类.class)</p>
<h2 id="Feign负载均衡"><a href="#Feign负载均衡" class="headerlink" title="Feign负载均衡"></a>Feign负载均衡</h2><blockquote>
<blockquote>
<p>feign是声明式的Web服务客户端，使得编写web服务客户端变得非常容易<br>只需要创建一个接口，然后再上面添加注解<br>参考官网:<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p>
</blockquote>
</blockquote>
<h2 id="hystrix断路器"><a href="#hystrix断路器" class="headerlink" title="hystrix断路器"></a>hystrix断路器</h2><h3 id="分布式系统中可能面临的问题："><a href="#分布式系统中可能面临的问题：" class="headerlink" title="分布式系统中可能面临的问题："></a>分布式系统中可能面临的问题：</h3><blockquote>
<blockquote>
<p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系再某些时候将不可避免地失败。（服务雪崩）<br>若每一层的链式依赖的响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的雪崩。<br>对于高流量的单体应用而言，单一的后端依赖可能会导致所有服务器上的所有资源再几秒内饱和。比失败更糟糕的式，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表名需要对故障和延迟进行隔离和管理，以便于单个依赖关系的失败，不能取消整个应用程序或其他。</p>
</blockquote>
</blockquote>
<h3 id="hytrix是什么？"><a href="#hytrix是什么？" class="headerlink" title="hytrix是什么？"></a>hytrix是什么？</h3><blockquote>
<blockquote>
<p>Hytrix是一个处理分布式系统的延迟和容错的开源库，他能保证再分布系统 中在一个依赖调用失败下，不会导致整体服务失败；而是会向调用方返回一个符合预期的可处理的备选响应（fallback），而不是长时间的等待或者抛出调用方无法处理的异常。</p>
</blockquote>
</blockquote>
<h3 id="hytrix能干什么？"><a href="#hytrix能干什么？" class="headerlink" title="hytrix能干什么？"></a>hytrix能干什么？</h3><h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><blockquote>
<p>一般是某个服务故障或者异常引起，类似于现实当中的“保险丝”，当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时。</p>
<blockquote>
<p>restController接口上添加注解，并且添加到接口调用出现错误后要调用fallback的方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>书写fallbackfang方法，供接口发生错误后的调用</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在主启动类上启动hytris，添加开启注解</p>
</blockquote>
</blockquote>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><blockquote>
<p>所谓降级，一般是整体负荷的考虑。就是当某个服务熔断之后，服务器将不会在被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省。这样做，虽然服务水平下降，但好歹可用，比直接挂掉要强。</p>
</blockquote>
<blockquote>
<blockquote>
<p>整体资源快不够了，忍痛将某些服务先关掉，待度过难关，在开启回来。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>服务降级处理是在客户端实现完成的，与服务端没有关系</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>服务限流</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>接近实时的监控</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>官网：<a href="https://github.com/Netflix/Hystrix/wiki/How-to-uses" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/How-to-uses</a></p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2020/05/07/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>散列表即为直接将查找的关键字与索引位置相关联，散列表建立了关键字和存储地址之间的一种映射关系。查找的时间复杂度O(1)。</p>
<ul>
<li><p>同义词：不同关键字却指向同一个存储地址，称为同义词，冲突</p>
</li>
<li><p>散列函数（hash）：直接定址法，除留余数法。。。</p>
</li>
<li><p>处理冲突：</p>
<blockquote>
<ol>
<li>开放定址法<ol>
<li>线性探测法</li>
<li>平方探测法</li>
<li>再散列</li>
<li>伪随机法</li>
</ol>
</li>
<li>拉链法（顺序+链式存储结构）</li>
</ol>
</blockquote>
</li>
</ul>
<p>散列表的查找效率取决于三个因素：</p>
<ol>
<li>散列函数</li>
<li>冲突处理</li>
<li>装填因子（表示装满的程度）</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2020/02/25/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>&emsp;&emsp;首先解释变量在内存中是如何存放的。</p>
<p>&emsp;&emsp;在计算机中，每个变量都会存放在内存中分配的一个空间，而每种类型的变量所占的空间又是不一样的，例如int型的变量占用4字节，而long long型的变量占用8个字节。可以把一个字节理解为一个“房间”，这样一个int型的变量就需要占用4个连续的“房间”；同理long long型变量则需要8个连续的“房间”来存放。既然有房间，就肯定有“房间号”，对应计算机中，每个字节都会有一个地址（即房间号），即变量存放的位置，而计算机就是同过地址找到某个变量的。变量的地址一般指它占用的字节中第一个字节的地址，也就是说，一个int型变量的地址就是它占用4个字节当中第一个字节的地址。</p>
<p>&emsp;&emsp;根据上面的理解，一个地址“<strong>指向</strong>”一个变量，可以通过地址来找到变量。在c语言中用“<strong>指针</strong>”来表示内存地址（或称指针指向了内存地址），而如果这个内存地址恰好是某个变量的地址，那么又称“这个指针指向该变量”。初学者可以简单理解为<strong>指针就是变量的地址</strong>（不严谨）</p>
<p>&emsp;&emsp;在c语言中，对变量的访问方式有两种：直接访问和间接访问。</p>
<blockquote>
<p><em>直接访问：变量分配的地址中直接存储目标数据；（即地址中存数据）</em><br><em>间接访问：变量分配的地址中存储的是存储目标数据的地址；（即地址中存地址）</em></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i &#x3D;200;</span><br><span class="line">	int *pointer;&#x2F;&#x2F;定义指针变量</span><br><span class="line">	pointer &#x3D; &amp;i;</span><br><span class="line">	printf(&quot;%d,%d&quot;,pointer,*pointer);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>&emsp;&emsp;<strong>指针变量用来存放指针（或者可以理解为变量地址）</strong>，这个关系就跟int型变量用来存int型常量相同。可以把地址当作常量，然后专门定义一种指针变量来存放它。指针变量的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int* p;</span><br><span class="line">double* p;</span><br><span class="line">char* p;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>在定义指针变量时必须指定基类型，即指针变量类型必须和基类的变量类型相等。</p>
</li>
<li><p>数组变量是特殊的指针</p>
<blockquote>
<ul>
<li>数组变量本身表达地址，所以<code>int a[10]; int *p = a;</code>无需用&amp;取地址 </li>
<li><code>[]</code>运算符可以对数组做，也可以对指针做：p[0] = a[0]</li>
<li>数组是一个<code>const</code>常量指针，两个数组间不能被赋值</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="const类型的指针"><a href="#const类型的指针" class="headerlink" title="const类型的指针"></a>const类型的指针</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;无非表达两种含义：指针不可修改、通过指针不可修改</span><br><span class="line">int i;</span><br><span class="line">const int* p1 &#x3D; &amp;i;</span><br><span class="line">int const* p2 &#x3D; &amp;i;</span><br><span class="line">int *const p3 &#x3D; &amp;i;</span><br><span class="line">&#x2F;&#x2F;const在*前面，代表*p不能修改，就是不可通过指针变量修改实际地址所存储的变量值</span><br><span class="line">&#x2F;&#x2F;const在*后面，指针变量不能被修改，不能指向其他指针。</span><br></pre></td></tr></table></figure>

<h3 id="指针变量运算"><a href="#指针变量运算" class="headerlink" title="指针变量运算"></a>指针变量运算</h3><p>&emsp;&emsp;指针变量可以进行加减法运算。对于一个int*型的指针变量p来说，p+1是指p所指的int型变量的下一个int型变量的地址。这个所谓的下一个是指跨越了一整个int型（即4个字节），因此如果是p+i，则说明是跨越到当前int型变量后的第i个int型变量。除此之外，指针变量支持自增和自减操作。</p>
<h4 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">malloc();申请内存空间</span><br><span class="line">free()释放内存空间</span><br><span class="line">注意：free(p),p一定要是malloc返回的首地址，否则malloc()无效</span><br><span class="line">c++中使用新的关键字new，delete来申请和释放内存</span><br></pre></td></tr></table></figure>

<p>​    </p>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>揭开二进制与位移运算的神秘面纱</title>
    <url>/2020/02/16/%E6%8F%AD%E5%BC%80%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;在计算机的世界中，根据其电气特性，其底层存储和操作的是以0101表示的二进制数。所以要理解一些计算机的操作原理，就必须了解相关二进制的计算规则。</p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>&emsp;&emsp;移位运算符是将数据看成二进制数，对其进行向左或向右移动若干位的运算。位移位运算符分为左移和右移两种，均为双目运算符。第一运算对象是移位对象，第二个运算对象是所移的二进制位数。</p>
<p> &emsp;&emsp;移位时，移出的位数全部丢弃，移出的空位补入的数与左移还是右移有关。如果是左移，则规定补入的数全部是0；如果是右移，还与被移位的数据是否带符号有关。若是不带符号数，则补入的数全部为0；若是带符号数，则补入的数全部等于原数的最左端位上的原数(即原符号位)。这里就扯出 一个符号和无符号的概念，这里预说明下，若是带符号数，符号位为1则表示负数，为0则表示正数。</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>左移&lt;&lt;</td>
<td>低位补0</td>
</tr>
<tr>
<td>右移&gt;&gt;</td>
<td>unsigned（高位补0）、signed（与符号位相同）</td>
</tr>
</tbody></table>
<h4 id="负数的右移"><a href="#负数的右移" class="headerlink" title="负数的右移"></a>负数的右移</h4><p>&emsp;&emsp;这里特别提一下负数的右移操作。相对于其他移位操作而言，负数的右移操作相对较复杂，下面是-100右移四位的其操作步骤：</p>
<p><em>注：右移的补位数与符号位相同，符号位为0则补0，为1则补1</em></p>
<ol>
<li>保持符号位不变</li>
<li>其余位向右移动4位</li>
<li>移动过程中高位补1</li>
<li>保持符号位不变，取反加一得移位后的原码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-100</span><br><span class="line">原码：1110 0100</span><br><span class="line">反码：1001 1011</span><br><span class="line">补码：1001 1100</span><br><span class="line">右移四位：1111 1001</span><br><span class="line">右移后的原码：1000 0111</span><br></pre></td></tr></table></figure>

<p>顺便提一下signed int 型1的左移问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1的补码为 00000000 00000000 00000000 00000001  &#x2F;&#x2F;最高位为符号位</span><br><span class="line">当1不断左移时，直到移动到符号位，补码如下：</span><br><span class="line">10000000 00000000 00000000 00000000</span><br><span class="line">此时符号为为1表示负数，其余位为0</span><br><span class="line">保持符号位不变取反加1后仍为</span><br><span class="line">10000000 00000000 00000000 00000000</span><br><span class="line">表示整数-0</span><br></pre></td></tr></table></figure>

<h3 id="六种位运算符"><a href="#六种位运算符" class="headerlink" title="六种位运算符"></a>六种位运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">语法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移</td>
<td align="center"><code>a&lt;&lt;x</code></td>
<td>整数a按二进制位左移x位</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移</td>
<td align="center"><code>a&gt;&gt;x</code></td>
<td>整数a按二进制位右移x位</td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">位与</td>
<td align="center"><code>a&amp;b</code></td>
<td>整数a和b按二进制位对齐，按位进行与运算（除了11得1，其他均为0）</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">`</td>
<td align="center">位或</td>
<td>`a</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">位异或</td>
<td align="center"><code>a^b</code></td>
<td>整数a和b按二进制位对齐，按位进行异或运算（相同为0，不同为1）</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">位取反</td>
<td align="center"><code>~a</code></td>
<td>整数a的二进制的每一位进行0变1、1变0的操作</td>
</tr>
</tbody></table>
<h3 id="signed-amp-unsigned"><a href="#signed-amp-unsigned" class="headerlink" title="signed&amp;unsigned"></a>signed&amp;unsigned</h3><p>&emsp;&emsp;拿<code>char</code>和<code>unsigned char</code>类型举例：Q1：若将<code>char</code>类型强转为<code>unsigned char</code>类型，又会发什么什么样的变化？Q2：为什么<code>char</code>类型移位后与<code>unsigned char</code>类型移位后转化为int的结果不一样？</p>
<p>&emsp;&emsp;首先在内存中两者没有什么区别，都是占了8个比特——1个字节，唯一的区别是<code>char</code>的首位是符号位，而<code>unsigned char</code>的首位是数字位。所以这就导致了他俩所能表示的数的范围区间不同。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>十六进制0x80~0xFF</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>-128~127</td>
<td>表示-128~-1</td>
</tr>
<tr>
<td>unsigned char</td>
<td>0~255</td>
<td>表示+128~+255</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这已经差不多能够回答Q1了；倘若将char类型转换为unsigned char类型，其存储在内存当中的底层数据是不变的，而变化的是其高位由原来的符号位变成了数字位——即其意义发生了改变。换句话说，指针变了，数据的2进制表示没变，变的是根据指针类型来解释这段数据的方式。</p>
<h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><p>&emsp;&emsp;在回答第二个问题前，有必要简单说一下源码、反码、补码的相关概念。在计算机表示的二进制数以及相关的计算都与他们有着不可分割的关系。</p>
<p>&emsp;&emsp;在计算机系统中，数值一律用补码来存储。 因为使用补码，可以将符号位和其它位统一处理；同时，减法也可按加法来处理。另外，两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。更加符合计算机计算的逻辑。 </p>
<ul>
<li><p>源码：正整数转化为二进制数</p>
</li>
<li><p>反码：原码按位取反</p>
</li>
<li><p>补码：反码+1</p>
</li>
</ul>
<h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p>  数值的补码表示也分两种情况： </p>
<ol>
<li><p>正数的补码：与原码相同。 </p>
<p>例如：+9的原码是00001001，所以补码是00001001。 </p>
</li>
<li><p>负数的补码：符号位为1，其余位为该数绝对值的原码按位取反；然后整个数加1。</p>
<p>例如，-7的补码：因为是负数，则符号位为“1”,整个为10000111；其余7位为-7的绝对值+7的原码0000111按位取反为1111000；再加1，所以-7的补码是11111001。</p>
<blockquote>
<p>关于-16补码的计算方式：</p>
<p>原码：1001 0000 （最高位为1，后n-1位是其绝对值16的二进制表示）</p>
<p>反码：1110 1111 （符号位不变，后n-1位取反）</p>
<p>补码：1111 0000 （反码+1）</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>已知一个数的补码，求原码的操作分两种情况： </p>
<ul>
<li><p>如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码。</p>
</li>
<li><p>如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位为1，其余各位取反，然后再整个数加1。 </p>
<blockquote>
<p>例如，已知一个补码为11111001，则原码是10000111（-7）：因为符号位为“1”，表示是一个负数，所以该位不变，仍为“1”；其余7位1111001取反后为0000110；再加1，所以是10000111。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="短字节转长字节"><a href="#短字节转长字节" class="headerlink" title="短字节转长字节"></a>短字节转长字节</h4><p>&emsp;&emsp;char类型占1个字节，而int类型占4个字节，若将短字节类型转为长字节类型，则需要在前面三个字节补符号位；若将长字节类型转为短字节类型，则需要对长字节类型进行截取，因此会出现精度，或者数据的丢失。关于补充符号位的规则如下表所示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>补符号位</th>
</tr>
</thead>
<tbody><tr>
<td>signed char（首位为1，是负数）</td>
<td>补1，0xFFFFFF</td>
</tr>
<tr>
<td>signed char（首位为0，是正数）</td>
<td>补0，0x000000</td>
</tr>
<tr>
<td>unsigned char（无所谓正负，则认为是正）</td>
<td>补0，0x000000</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;至次，比可以回答Q2了，由于计算机里数值都是以补码形式存在，且buffer的高位为1，所以补0xFFFFFF，转化为int的Buffer 则为0xFFFFFFF0（将-16以补码形式的表现），然后在做右移操作；而作为unsigned char类型，则无所谓正负，补0x000000，最终Buffer 则为0x000000F0还是0xF0，所以不会有影响。</p>
<h4 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h4><p>主要想记录下带有小数点的十进制如何转换为二进制</p>
<p>心法口诀：<em>整数部分除基取余，小数部分乘基取整</em></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概论—除运算的理解</title>
    <url>/2020/02/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E2%80%94%E9%99%A4%E8%BF%90%E7%AE%97%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>之前学数据库都只是感觉单纯在学习sql而已，而sql语法又符合英语的语法，所以并没有觉的难学，直到翻开教材的那一次，各种概念术语搞得我甚是头疼。</p>
<p>闲话少说！众所周知，除运算是整个代数运算中最难理解的运算，没有之一。小编也是在学习这块内容的时候绞尽脑汁，在学习除运算之前，先引出象集的概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 通俗来说：象集就是有两个不相交的属性集A,B;属性集A取特定的属性值为x所对应的组元在属性集B上的投影;简单来说就是左边A中取一个值，对应右边B中每一行所能取的属性值的集合——即为象集。</span><br><span class="line"> </span><br><span class="line">教材定义：</span><br><span class="line">    给定一个关系R(X,Z),X和Z为属性组。当t[X]&#x3D;x时，x在R中的象集(images set)定义为</span><br><span class="line">                        Zx&#x3D;&#123; t[Z] | t ∈ A，t[X]&#x3D;x &#125;</span><br><span class="line">    他表示R中属性组X上值为x的诸元素组在Z上分量(对应属性值)的集合。</span><br><span class="line"> </span><br><span class="line">例子：</span><br><span class="line">        X  Y  Z</span><br><span class="line">        a1 b1 c2</span><br><span class="line">        a2 b3 c7</span><br><span class="line">        a3 b4 c6</span><br><span class="line">        a1 b2 c3</span><br><span class="line">        a4 b6 c6</span><br><span class="line">        a2 b2 c3</span><br><span class="line">        a1 b2 c1</span><br><span class="line"> </span><br><span class="line">a1在A中的象集为&#123;(b1,c2),(b2,c3),(b2,c1)&#125;</span><br></pre></td></tr></table></figure>

<p>那什么是除运算呢?</p>
<p>以下是书上除运算的定义：</p>
<p>设关系R除以关系S的结果为关系T，则T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定关系R(X,Y)和S(Y，Z),其中X,Y,Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。</span><br><span class="line">    R与S的除运算得到一个新的关系P(X),P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习导图</title>
    <url>/2020/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p><img src="/2020/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%9B%BE/%E6%95%B0%E6%8D%AE%E5%BA%93xmind%E5%AF%BC%E5%9B%BE.png" alt></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装操作系统</title>
    <url>/2020/05/25/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>8G以上Micro SD卡和读卡器，注意SD卡的读写速度直接影响系统的运行速度</p>
<h3 id="下载官网的最新系统"><a href="#下载官网的最新系统" class="headerlink" title="下载官网的最新系统"></a>下载官网的最新系统</h3><p><a href="www.baidu.com">百度网盘链接（系统镜像和烧录工具）</a></p>
<p>密码：</p>
<h3 id="使用win32DiskImager烧录"><a href="#使用win32DiskImager烧录" class="headerlink" title="使用win32DiskImager烧录"></a>使用win32DiskImager烧录</h3><ol>
<li>选择SD卡</li>
<li>选择下载好的镜像文件</li>
<li>点击“写入”</li>
<li>注意烧录完成后默认是不开启SSH，需要在SD卡根目录中（boot）新建SSH文件无后缀。</li>
</ol>
<h3 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a>疑问解答</h3><p>烧录好的TF卡被分为两个分区：一个FAT32的Boot分区，和一个（或数个）Ext4的Linux主分区。这也是Linux系统的典型需求。</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>文件操作fstream</title>
    <url>/2020/02/09/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cfstream/</url>
    <content><![CDATA[<p>&emsp;&emsp;文件操作是很高频的，文件的复制，编码，格式转换等等都要用到。因此熟悉对文件的操作就显得至关重要。C++中，文件被分为两类—文本文件、二进制文件。这就涉及到两个概念——字符流和字节流；拿二进制文件举例，每个二进制文件都可以理解为是由01表示的，只不过通过计算机的编码最终展示为我们能看懂的符号、文字或者图像等。用一个形象的比喻，二进制文件可以理解为一个大水缸，0和1就比作缸里的水，而字节流则可以理解为水流，文件的读取就可以形象的形容为水一边流，程序一边读取水流中的01。</p>
<p>&emsp;&emsp;C++中是通过<code>fstream</code>文件流来实现对文件的操作的，其中<code>ifstream</code>,<code>ofstream</code>是<code>fstream</code>的派生类，分别负责输入流和输出流。当我们使用<code>#include &lt;fstream&gt;</code> 时，我们就可以使用其中的 <code>ifstream</code>,<code>ofstream</code>以及<code>fstream</code>这三个类了，也就可以用这三个类来定义相应的对象了,例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个fin的对象了</span></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化的时候绑定文件地址和读写方式(以二进制读)</span></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"C:\\example.txt"</span>,ios::binary )</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;open()这个成员函数重载了好几种形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * filename:文件路径</span></span><br><span class="line"><span class="comment"> * mode:文件打开模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, ios_base::openmode mode = ios_base::in|ios_base::out )</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * filename:文件路径</span></span><br><span class="line"><span class="comment"> * mode:文件打开模式</span></span><br><span class="line"><span class="comment"> * prot:打开文件的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span> *_Filename, ios_base::openmode mode= ios_base::in|ios_base::out, 	<span class="keyword">int</span> prot = ios_base::_Openprot)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>prot属性表</em></li>
</ul>
<table>
<thead>
<tr>
<th>代码</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为输入(读)而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为输出(写)而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>所有输出附加在文件末尾</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件已存在则先删除该文件</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>*注：这些方式是能够进行组合使用的，以“或”运算（“|”）的方式,例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fin.<span class="built_in">open</span>(<span class="string">"test.txt"</span>, ios::in|ios::out|ios::binary)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第一个参数是一个常量字符指针，你可以填入所要打开文件的相对路径，也可以填入绝对路径；当然，你也可以填入一个指向文件名字符串的<strong>指针常量</strong>，或者内容等于文件名的<strong>string常量</strong>，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_path = <span class="string">"C:\\example.txt"</span>;</span><br><span class="line">fin.<span class="built_in">open</span>(c_path);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> str_path = <span class="string">"C:\\example.txt"</span>;</span><br><span class="line">fin.<span class="built_in">open</span>(str_path);</span><br></pre></td></tr></table></figure>

<p><strong><em>注：必须是指向常量的指针或string</em></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若非const string</span></span><br><span class="line"><span class="built_in">string</span> str_path = <span class="string">"test.txt"</span>;</span><br><span class="line">fin.<span class="built_in">open</span>(str_path.c_str()); </span><br><span class="line"><span class="comment">//这里的c_str()是 string 的一个成员函数，返回const型的char*指针，相当于第一种写法</span></span><br></pre></td></tr></table></figure>

<h4 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h4><ul>
<li><p>is_open()成员函数</p>
<p>&emsp;&emsp;<code>is_open()</code>判断文件是否正确打开，如果是，返回<code>true</code>,否则，返回<code>false</code>。一般用于检测文件的路径是否正确。</p>
</li>
<li><p>get()成员函数</p>
<ul>
<li><p>int get()</p>
<p>不带参数的get成员从输入流中提取一个字符（包括空白字符），并且返回该字符作为函数的返回值。当遇到文件结束符时，返回文件结束符常量EOF(-1)</p>
</li>
<li><p>ifstream&amp; get(char* c)</p>
<p>从输入流中提取一个字符（包括空白字符），并且把它放到字符引用c中。当遇到文件结束符时返回0，否则返回ifstream对象引用。</p>
</li>
<li><p>ifstream&amp; get(char* c，int n,char = ‘\n’)</p>
<p>与getline相似，从输入流中读取n-1个字符（包括空白字符），并为字符串结尾添加’\0’;第三个参数便是指定分隔符，默认为’\n’</p>
<p>注：最容易忽略的一点，也是与getline的不同点，get不会将输入流中读到的分隔符放入数组c中，因此分隔符仍保留在输入流中，若不妥善处理可能会影响下一次的读取。</p>
</li>
</ul>
</li>
<li><p>getline()成员函数</p>
<p>&emsp;&emsp;<em>在介绍这个成员函数之前，可能有些同学会对<strong>换行</strong>有些疑问。对于换行这个动作，不同的平台有不同的表示方式，比如：</em></p>
<table>
<thead>
<tr>
<th>平台</th>
<th>字符表示</th>
</tr>
</thead>
<tbody><tr>
<td>unix</td>
<td>用0x0A表示换行(‘\n’）</td>
</tr>
<tr>
<td>mac</td>
<td>用回车符CR表示下一行(‘\r’)</td>
</tr>
<tr>
<td>windows</td>
<td>0x0D和0x0A两个字符(“\r\n”)</td>
</tr>
</tbody></table>
<p>Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；</p>
<p>Mac系统里，每行结尾是“&lt;回车&gt;”,即“\r”；</p>
<p>Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”；。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 该函数从输入流中读取n-1个字符到c中，遇到指定的结束分隔符停止读取，结束分割符默认是&#39;\n&#39;</span><br><span class="line"> *&#x2F;</span><br><span class="line">ifstream&amp; getline(char* c,int n,char &#x3D; &#39;\n&#39;);</span><br><span class="line">&#x2F;&#x2F;注：getline读取时遇到分隔符会将其从输入流中删除</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&gt;&gt;</code>与<code>&lt;&lt;</code>操作符</p>
<p>&emsp;&emsp;由于ifstream以及ofstream分别继承于istream和ostream,所以他们也分别继承了相应的运算符，可与cin，cout一样使用&gt;&gt;, &lt;&lt;运算符。但需要注意一点，若从输入流中读到空白字符，则认为字符串结束了。换句话说，空白字符会终止文件读取。</p>
</li>
</ul>
<h4 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h4><p>&emsp;&emsp;读取文件时，二进制文件与文本文件在判定<strong><em>文件结束标识</em></strong>的方法存在区别。当get()之类的成员函数遇到文件标识符时，返回常量EOF（-1）作为文件结束标志，但二进制则不能用EOF，因为若文件中某个字节的值为-1，就会被误认为结束标志。C++提供了一个成员函数eof()来解决这个问题。</p>
<h5 id="get-和put-操作二进制文件"><a href="#get-和put-操作二进制文件" class="headerlink" title="get()和put()操作二进制文件"></a>get()和put()操作二进制文件</h5><ul>
<li><p><code>istream&amp; get(char &amp;ch)、ostream&amp; put(char ch)</code></p>
<p>由于文件流是从<code>istream</code>、<code>ostream</code>、<code>iostream</code>类继承来的，这些类的成员函数同样可用于文件流类。因此文件操作中可用get()从输入文件流中读取字符，用<code>put()</code>函数将字符插入到输出文件流中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">string</span>&amp; path,<span class="built_in">string</span>&amp; copyPath)</span> </span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(path,ios::binary)</span></span>;</span><br><span class="line">	<span class="function">ofstream <span class="title">fout</span><span class="params">(copyPath,ios::binary)</span></span>;</span><br><span class="line">    <span class="comment">//初始化buff</span></span><br><span class="line">	<span class="keyword">char</span> buff = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">if</span> (fin.is_open()&amp;&amp; fout.is_open()) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			 fin.<span class="built_in">get</span>(buff);</span><br><span class="line">			 <span class="built_in">printf</span>(<span class="string">"%c"</span>,buff);</span><br><span class="line">			 fout.<span class="built_in">put</span>(buff);</span><br><span class="line">		&#125; <span class="keyword">while</span> (!fin.eof());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="read-和write-操作二进制文件"><a href="#read-和write-操作二进制文件" class="headerlink" title="read()和write()操作二进制文件"></a>read()和write()操作二进制文件</h5><ul>
<li><code>istream&amp; read(char* buff,int n)、ostream&amp; write(const char* buff,int n)</code></li>
</ul>
<p>&emsp;&emsp;二进制读写的重点就是<code>read()</code>和<code>write()</code>函数的使用，这两个方法允许我们以更快的方式——数据块的形式读写文件，我们需要准备一个文件缓存区<code>char buff[1024]</code>——字符数组用来接受每次从数据流中读到的数据。并指定要读取的字节数，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取数据块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun4</span><span class="params">(<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(path, ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">if</span> (fin.is_open()) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">//每次读取5个字节</span></span><br><span class="line">			fin.<span class="built_in">read</span>(buff,<span class="number">5</span>);</span><br><span class="line">			<span class="keyword">int</span> count = fin.gcount();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"第%d次读取了%d个字节\n"</span>,i++,count);</span><br><span class="line">		&#125; <span class="keyword">while</span> (!fin.eof());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件结束"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件拷贝例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void copy(string&amp; path,string&amp; copyPath) &#123;</span><br><span class="line">	ifstream fin(path, ios::binary);</span><br><span class="line">	ofstream fout(copyPath,ios::binary);</span><br><span class="line">	char buff[5];</span><br><span class="line">	if (fin.is_open()&amp;&amp; fout.is_open()) &#123;</span><br><span class="line">		int i &#x3D; 1;</span><br><span class="line">		do &#123;</span><br><span class="line">			&#x2F;&#x2F;每次读取4个字节</span><br><span class="line">			fin.read(buff,5);</span><br><span class="line">			&#x2F;&#x2F;读取的字节数</span><br><span class="line">			int count &#x3D; fin.gcount();</span><br><span class="line">			printf(&quot;第%d次读取了%d个字节\n&quot;,i++,count);</span><br><span class="line">			if (count&gt;0) &#123;</span><br><span class="line">				fout.write(buff, count);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (!fin.eof());</span><br><span class="line">		printf(&quot;文件结束&quot;);</span><br><span class="line">		fin.close();</span><br><span class="line">		fout.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外浅显的说一下<strong>序列化和反序列化</strong>。</p>
<p>序列化： 将数据结构或对象转换成二进制串的过程。<br>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派开机发送ip地址到邮箱</title>
    <url>/2020/08/27/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E5%8F%91%E9%80%81ip%E5%9C%B0%E5%9D%80%E5%88%B0%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一直以来，获取树莓派的IP一直都是一个让人头疼的问题。因为可能会面对不同的场景，某些场景下真的不能判断哪个ip是树莓派的。由于公司局域网内的机器比较多，我用<strong>IP Scanner</strong>软件扫描局域网内的机器，并不知道哪个IP是树莓派的，一个个试过去也不太现实，因此<strong>利用开机脚本发送邮箱</strong>成了一个不错的解决方案。</p>
<p>下面我来介绍一下如何才能实现这个功能</p>
<h4 id="第一步、编写python脚本"><a href="#第一步、编写python脚本" class="headerlink" title="第一步、编写python脚本"></a>第一步、编写python脚本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import smtplib</span><br><span class="line">import time</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line"></span><br><span class="line"># 校验当前计算机的网络是否可用，是否可以连外网</span><br><span class="line">def check_network():</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            url &#x3D; &quot;www.baidu.com&quot; </span><br><span class="line">            host &#x3D; socket.gethostbyname(url)</span><br><span class="line">            socket.create_connection((host,80),2)</span><br><span class="line">            print(&quot;Network is Ready!&quot;)</span><br><span class="line">            break</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">            print(&quot;Network is not ready,Sleep 5s...&quot;)</span><br><span class="line">            time.sleep(5)</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line"># 获取本机的IP地址</span><br><span class="line">def get_host_ip():</span><br><span class="line">    try:</span><br><span class="line">        s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        s.connect((&#39;8.8.8.8&#39;, 80))</span><br><span class="line">        ip &#x3D; s.getsockname()[0]</span><br><span class="line">    finally:</span><br><span class="line">        s.close()</span><br><span class="line"></span><br><span class="line">    return ip</span><br><span class="line"></span><br><span class="line"># 发送邮件</span><br><span class="line">def send_email():</span><br><span class="line">    from_addr &#x3D; &quot;your email address@mail.com&quot;</span><br><span class="line">    password &#x3D; &quot;your password&quot;</span><br><span class="line">    smtp_server &#x3D; &#39;smtp.163.com&#39;</span><br><span class="line">    to_addr &#x3D; &quot;receive address&quot;</span><br><span class="line">    msg &#x3D; MIMEText(&#39;Your raspberry IP addr is:&#39;+get_host_ip())</span><br><span class="line">    msg[&quot;Subject&quot;] &#x3D; &quot;raspberry IP addr notify&quot;</span><br><span class="line">    msg[&#39;from&#39;] &#x3D; from_addr</span><br><span class="line">    msg[&#39;to&#39;] &#x3D; to_addr</span><br><span class="line">    try:</span><br><span class="line">        server &#x3D; smtplib.SMTP(smtp_server)</span><br><span class="line">        server.login(from_addr, password)</span><br><span class="line">        server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">        server.quit()</span><br><span class="line">        print(&#39;success&#39;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&#39;Faild:%s&#39; % e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    check_network()</span><br><span class="line">    send_email()</span><br></pre></td></tr></table></figure>

<h4 id="第二部、编写shell脚本"><a href="#第二部、编写shell脚本" class="headerlink" title="第二部、编写shell脚本"></a>第二部、编写shell脚本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下操作都在&#x2F;usr&#x2F;local&#x2F;src&#x2F;raspberryIP下</span><br><span class="line">&#x2F;&#x2F; 需要把上一步编写的python脚本放到该目录下</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;raspberryIP</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个*.sh可执行文件</span><br><span class="line">sudo vim clientStart.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 编写执行脚本</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;raspberryIP</span><br><span class="line">sudo python raspberryIP.py</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 保存后测试下是否可以执行</span><br><span class="line">.&#x2F;clientStart.sh</span><br></pre></td></tr></table></figure>

<h4 id="第三步、开机启动方法设置"><a href="#第三步、开机启动方法设置" class="headerlink" title="第三步、开机启动方法设置"></a>第三步、开机启动方法设置</h4><p>编辑/etc/rc.local文件，在rc.local文件里Exit 0 前加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;src&#x2F;raspberryIP&#x2F;clientStart.sh start</span><br></pre></td></tr></table></figure>

<p>至此，所有工作都已完成</p>
]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的二分查找</title>
    <url>/2020/03/03/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>&emsp;&emsp;二分查找的前提是序列有序，其高效之处在于每一步都可以去除当前区间中一半的元素，时间复杂度为O(logn)；刷题中若遇到有序序列的查找，第一联想到这个简单的算法。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(vector&lt;int&gt; arr,int begin,int end,int target)&#123;</span><br><span class="line">	int mid;</span><br><span class="line">	while(begin&lt;&#x3D;end)&#123;</span><br><span class="line">		mid &#x3D; (begin+end)&#x2F;2;</span><br><span class="line">		if(arr[mid]&#x3D;&#x3D;target)</span><br><span class="line">			return mid;</span><br><span class="line">		if(arr[mid]&gt;target)</span><br><span class="line">			end &#x3D; mid-1;</span><br><span class="line">		if(arr[mid]&lt;target)</span><br><span class="line">			begin &#x3D; mid+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/02/28/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>简单的快排</title>
    <url>/2020/03/04/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="空间效率"><a href="#空间效率" class="headerlink" title="空间效率"></a>空间效率</h4><p>&emsp;&emsp;由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。 最好情况下为[log<sub>2</sub>(n+1)]；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为<code>O(n)</code>；平均情况下，栈的深度为O(log<sub>2</sub>n)。因而空间复杂度在最坏情况下为O(n)，在平均情况下为O(log<sub>2</sub>n)。</p>
<h4 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h4><p>&emsp;&emsp;快速排序的运行时间与划分是否对称有关，而后者又与具体使用的划分算法有关。快速排序的最坏情况发生在两个区域分别包含n- 1个元素和0个元素时，这种最大程度的<strong>不对称性</strong>若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为O(n<sup>2</sup>)。</p>
<p>&emsp;&emsp;有很多方法可以提高算法的效率。一种方法是当递归过程中划分得到的子序列的规模较小时不要再继续递归调用快速排序，可以直接采用直接插入排序算法进行后续的排序工作。另一种方法就是尽量选取一个可以<strong>将数据中分的枢轴元素</strong>。如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。</p>
<p>&emsp;&emsp;在最理想的状态下，即Partition()可能做到最平衡的划分中，得到的两个子问题的大小都不可能大于n/2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为O(nlog<sub>2</sub>n)。好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。<strong>快速排序是所有内部排序算法中平均性能最优的排序算法</strong></p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>&emsp;&emsp;在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。例如，表L={3,2, 2}，经过一-趟排序后L= {2,2, 3}，最终排序序列也是L= {2,2,3},显然，2与2的相对次序已发生了变化。</p>
<p><em>注意:在快速排序算法中，并不产生有序子序列，但每趟排序后会将一个元素（基准元素）放到其最终位置的信置上。</em></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void quickSort(int A[],int left,int right)&#123;</span><br><span class="line">	if(left&lt;right)&#123;</span><br><span class="line">		int pos &#x3D; partition(A,left,right);</span><br><span class="line">		quickSort(A,left,pos-1);</span><br><span class="line">		quickSort(A,pos+1,right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二分：枢轴左侧的值比其小，右侧的值比其大。</span><br><span class="line">int partition(int A[],int left,int right)&#123;</span><br><span class="line">	int temp &#x3D; A[left];</span><br><span class="line">	while(left&lt;right)&#123;</span><br><span class="line">		while(left&lt;right&amp;&amp;A[right]&gt;temp)right--;&#x2F;&#x2F;反复左移right，直到遇到比temp小的</span><br><span class="line">			A[left]&#x3D;A[right];</span><br><span class="line">		while(left&lt;right&amp;&amp;A[left]&lt;temp)left++</span><br><span class="line">			A[right]&#x3D;A[left];</span><br><span class="line">	&#125;</span><br><span class="line">	A[left]&#x3D;temp;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派设置无线连接和静态IP</title>
    <url>/2020/05/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%AE%BE%E7%BD%AE%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%9D%99%E6%80%81IP/</url>
    <content><![CDATA[<h3 id="设置无线连接"><a href="#设置无线连接" class="headerlink" title="设置无线连接"></a>设置无线连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf</span><br><span class="line"> </span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">    ssid&#x3D;&quot;你的无线网络的名字&quot;</span><br><span class="line">    psk&#x3D;&quot;无线网络的密码&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;dhcpcd.conf</span><br><span class="line"> </span><br><span class="line">#在最后一行添加如下字段,注意是wlan0哦</span><br><span class="line"> </span><br><span class="line">interface wlan0</span><br><span class="line">static ip_address&#x3D;你的IP</span><br><span class="line">static routers&#x3D;你的路由器的管理地址</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>解决python pip安装模块时下载太慢</title>
    <url>/2020/04/17/%E8%A7%A3%E5%86%B3python-pip%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%E6%97%B6%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install XXX -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>

<p><code>XXX</code>为模块名，切换成清华大学下载源，下载直接提高无数倍</p>
<h5 id="国内其他源"><a href="#国内其他源" class="headerlink" title="国内其他源"></a>国内其他源</h5><blockquote>
<ul>
<li>豆瓣：<a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a></li>
<li>阿里：<a href="https://mirrors.aliyun.com/pypi/simple" target="_blank" rel="noopener">https://mirrors.aliyun.com/pypi/simple</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>结构体</title>
    <url>/2020/02/25/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>声明结构的形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct structName&#123;</span><br><span class="line">	int age;</span><br><span class="line">	int sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct&#123;</span><br><span class="line">	int age;</span><br><span class="line">	int sex;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"></span><br><span class="line">struct structName&#123;</span><br><span class="line">	int age;</span><br><span class="line">	int sex;</span><br><span class="line">&#125;p1,p2;</span><br></pre></td></tr></table></figure>

<h3 id="结构的初始化"><a href="#结构的初始化" class="headerlink" title="结构的初始化"></a>结构的初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct structName&#123;</span><br><span class="line">	int age;</span><br><span class="line">	int sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct structName s1 &#x3D; &#123;11,12&#125;;</span><br><span class="line">struct structName s1 &#x3D; &#123;.age&#x3D;11,.sex&#x3D;12&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：初始化不赋值则默认为0;<br>要访问整个结构，直接用结构变量的名字。<br>对于整个结构，可以做赋值、取地址、，也可以传递给函数参数。</p>
<p>p1=(struct point){5,10};强制类型转化，相当于p1.x=5;p1.y=10;<br>p1=p2;//相当于p1.x = p2.x; p1.y = p2.y;</p>
<p>##结构指针</p>
<p>和数组不同，结构变量的名字并不是结构变量的地址，必须要用&amp;运算符<br>struct date *pDate = &today;</p>
<p>#结构作为函数参数</p>
<p>int numberOfDate(struct date d)<br>1.整个结构可以作为参数的值传入函数<br>2.可在函数内新建一个结构变量，并将调用者的结构的值赋值给新建的结构变量<br>3.也可以返回一个结构<br>4.这与数组完全不同</p>
<h2 id="Typedef"><a href="#Typedef" class="headerlink" title="Typedef"></a>Typedef</h2><h1 id="申明新的类型名称"><a href="#申明新的类型名称" class="headerlink" title="申明新的类型名称"></a>申明新的类型名称</h1><p>typedef long int64_t;<br>typedef struct ADate {<br>    int month;<br>    int day;<br>    int year;<br>} Date;</p>
<p>int64_t i = 10000000;<br>Date t = {9,1,2005};</p>
<h2 id="union联合"><a href="#union联合" class="headerlink" title="union联合"></a>union联合</h2><p>可以用做文件的处理</p>
<h2 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a>静态本地变量</h2><p>静态本地变量实际上是特殊的全局变量<br>他们位于相同的内存区域<br>静态本地变量具有全局的生存期，函数内的局部作用域</p>
<p>note：关于返回指针的函数<br>1.返回本地变量的地址是危险的<br>2.返回全局变量或静态本地变量的地址是安全的。<br>3.返回在函数内malloc的内存是安全的，但是容易造成问题<br>4.最好的做法是返回传入的指针</p>
<p>tips：<br>1.不要使用全局来在函数传递参数的结果<br>2.尽量避免使用全局变量<br>3.*使用全局变量和静态本地变量的函数是线程不安全的</p>
<h2 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h2><p>#开头的是编译预处理指令<br>它们不是c语言的成分，但是c语言离不开编译预处理指令<br>#define用来定义一个宏</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#define PI 3.14</p>
<p>编译的过程</p>
<p>编译预处理<br>.c—&gt;.i—&gt;.s—&gt;.o—&gt;a.out</p>
<h1 id="定义像函数的宏"><a href="#定义像函数的宏" class="headerlink" title="定义像函数的宏"></a>定义像函数的宏</h1><p>原则：<br>一切都要有括号<br>    整个值要有括号<br>    参数出现的每个地方都要有括号</p>
<p>#define cube(x)((x)<em>(x)</em>(x))</p>
<h1 id="带参数的宏（没有类型检查）"><a href="#带参数的宏（没有类型检查）" class="headerlink" title="带参数的宏（没有类型检查）"></a>带参数的宏（没有类型检查）</h1><p> 在大型程序的代码中使用非常普遍<br> 可以非常复杂，如“产生”函数<br> 部分宏会被inline函数替代</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>对于项目，dev c++的编译会把一个项目中的所有的员代码文件都编译后，链接起来<br>有的ide有分开的编译(compile)和构建(build)两个按钮；前者是对单个源代码文件编译，后者是对整个项目做链接</p>
<p>##大程序文件</p>
<p>1.在函数前面加上static就使得它成为只能在所在的编译单元中被使用的函数<br>2.在全局变量前面加上static就使得他成为只能在所在的编译单元中被使用的全局变量</p>
<h2 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h2><p>int i;是变量的定义<br>extern int i;是变量的声明</p>
<h1 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h1><p>声明式不产生代码的东西<br>    函数原型<br>    变量声明<br>    结构声明<br>    宏声明<br>    枚举声明<br>    类型声明<br>    inline声明<br>定义是产生代码的东西</p>
<h3 id="标准头文件结构"><a href="#标准头文件结构" class="headerlink" title="标准头文件结构"></a>标准头文件结构</h3><p>运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次<br>#pragma once也能起到相同的作用，但不是所有的编译器都支持</p>
<p>#ifndef <em>LIST_HEAD</em><br>#define <em>LIST_HEAD</em></p>
<p>#include “node.h”</p>
<p>typedef struct _list{<br>    Node* head;<br>    Node* tail;<br>}List;</p>
<p>#endif</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>解决树莓派apt-get更新速度慢的方法</title>
    <url>/2020/05/25/%E8%A7%A3%E5%86%B3%E6%A0%91%E8%8E%93%E6%B4%BEapt-get%E6%9B%B4%E6%96%B0%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>原理就是使用国内的镜像源，代替国外的镜像源。</p>
<p>有两个推荐的源：</p>
<ul>
<li>清华大学镜像：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmirrors.tuna.tsinghua.edu.cn%2Fraspbian%2Fraspbian%2F" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a></li>
<li>阿里云镜像：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmirrors.aliyun.com%2Fraspbian%2Fraspbian%2F" target="_blank" rel="noopener">https://mirrors.aliyun.com/raspbian/raspbian/</a></li>
</ul>
<p>1.备份原系统的apt的源镜像列表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.<span class="built_in">list</span> /etc/apt/sources.<span class="built_in">list</span>.bak</span><br></pre></td></tr></table></figure>

<p>2.编辑sources.list 文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.<span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<p>3.注释掉原来的内容，添加以下内容：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">deb <span class="symbol">https:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span> buster main contrib non-free rpi</span><br><span class="line">deb-src <span class="symbol">https:</span>/<span class="regexp">/mirrors.aliyun.com/raspbian</span><span class="regexp">/raspbian/</span> buster main contrib non-free rpi</span><br></pre></td></tr></table></figure>

<p><strong>注意：这里编辑的时候需要注意版本（只需要更换链接部分的内容就可以）</strong></p>
<table>
<thead>
<tr>
<th>Debian版本</th>
<th>对应名称</th>
</tr>
</thead>
<tbody><tr>
<td>Debian7</td>
<td>wheezy</td>
</tr>
<tr>
<td>Debian8</td>
<td>jessie</td>
</tr>
<tr>
<td>Debian9</td>
<td>stretch</td>
</tr>
<tr>
<td>Debian10</td>
<td>buster</td>
</tr>
</tbody></table>
<p>保存退出。</p>
<p>再执行 <code>sudo apt-get update</code> 和 <code>sudo apt-get upgrade</code>，就能看到加速效果了</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>运算符优先级</title>
    <url>/2020/09/09/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th><strong>优先级</strong></th>
<th><strong>运算符</strong></th>
<th><strong>名称或含义</strong></th>
<th><strong>使用形式</strong></th>
<th><strong>结合方向</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>[]</strong></td>
<td>数组下标</td>
<td>数组名[常量表达式]</td>
<td>左到右</td>
<td>–</td>
</tr>
<tr>
<td><strong>()</strong></td>
<td>圆括号</td>
<td>(表达式）/函数名(形参表)</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>.</strong></td>
<td>成员选择（对象）</td>
<td>对象.成员名</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>-&gt;</strong></td>
<td>成员选择（指针）</td>
<td>对象指针-&gt;成员名</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>-</strong></td>
<td>负号运算符</td>
<td>-表达式</td>
<td><strong>右到左</strong></td>
<td>单目运算符</td>
</tr>
<tr>
<td><strong>~</strong></td>
<td>按位取反运算符</td>
<td>~表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>++</strong></td>
<td>自增运算符</td>
<td>++变量名/变量名++</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>–</strong></td>
<td>自减运算符</td>
<td>–变量名/变量名–</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*****</td>
<td>取值运算符</td>
<td>*指针变量</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>&amp;</strong></td>
<td>取地址运算符</td>
<td>&amp;变量名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>!</strong></td>
<td>逻辑非运算符</td>
<td>!表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>类型</strong></td>
<td>强制类型转换</td>
<td>(数据类型)表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>sizeof</strong></td>
<td>长度运算符</td>
<td>sizeof(表达式)</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>/</strong></td>
<td>除</td>
<td>表达式/表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>*****</td>
<td>乘</td>
<td>表达式*表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>%</strong></td>
<td>余数（取模）</td>
<td>整型表达式%整型表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong><em>\</em>+**</strong></td>
<td>加</td>
<td>表达式+表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>-</strong></td>
<td>减</td>
<td>表达式-表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong><em>\</em>&lt;&lt;**</strong></td>
<td>左移</td>
<td>变量&lt;&lt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>&gt;&gt;</strong></td>
<td>右移</td>
<td>变量&gt;&gt;表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong><em>\</em>&gt;**</strong></td>
<td>大于</td>
<td>表达式&gt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>&gt;=</strong></td>
<td>大于等于</td>
<td>表达式&gt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>&lt;</strong></td>
<td>小于</td>
<td>表达式&lt;表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>&lt;=</strong></td>
<td>小于等于</td>
<td>表达式&lt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>==</strong></td>
<td>等于</td>
<td>表达式==表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>!=</strong></td>
<td>不等于</td>
<td>表达式!= 表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong><em>\</em>&amp;**</strong></td>
<td>按位与</td>
<td>表达式&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong><em>\</em>^**</strong></td>
<td>按位异或</td>
<td>表达式^表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td><strong><em>\</em>|**</strong></td>
<td>按位或</td>
<td>表达式|表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td><strong><em>\</em>&amp;&amp;**</strong></td>
<td>逻辑与</td>
<td>表达式&amp;&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td><strong><em>\</em>||**</strong></td>
<td>逻辑或</td>
<td>表达式||表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>13</strong></td>
<td><strong><em>\</em>?:**</strong></td>
<td>条件运算符</td>
<td>表达式1?表达式2: 表达式3</td>
<td><strong><em>\</em>右到左**</strong></td>
<td>三目运算符</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>14</strong></td>
<td><strong><em>\</em>=**</strong></td>
<td>赋值运算符</td>
<td>变量=表达式</td>
<td><strong><em>\</em>右到左**</strong></td>
<td>–</td>
</tr>
<tr>
<td><strong>/=</strong></td>
<td>除后赋值</td>
<td>变量/=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>*=</strong></td>
<td>乘后赋值</td>
<td>变量*=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>%=</strong></td>
<td>取模后赋值</td>
<td>变量%=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>+=</strong></td>
<td>加后赋值</td>
<td>变量+=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>-=</strong></td>
<td>减后赋值</td>
<td>变量-=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>&lt;&lt;=</strong></td>
<td>左移后赋值</td>
<td>变量&lt;&lt;=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>&gt;&gt;=</strong></td>
<td>右移后赋值</td>
<td>变量&gt;&gt;=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>&amp;=</strong></td>
<td>按位与后赋值</td>
<td>变量&amp;=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>^=</strong></td>
<td>按位异或后赋值</td>
<td>变量^=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>|=</strong></td>
<td>按位或后赋值</td>
<td>变量|=表达式</td>
<td>–</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>15</strong></td>
<td><strong>，</strong></td>
<td>逗号运算符</td>
<td>表达式,表达式,…</td>
<td>左到右</td>
<td>–</td>
</tr>
</tbody></table>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>同一优先级的运算符，运算次序由结合方向所决定。</li>
<li>简单记就是：！ &gt;  算术运算符  &gt; 关系运算符 &gt;  &amp;&amp;  &gt; || &gt;  赋值运算符</li>
</ul>
]]></content>
  </entry>
</search>
